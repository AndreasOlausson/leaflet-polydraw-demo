import * as L from 'leaflet';
import { TurfHelper } from '../turf-helper';
import { PolygonInformationService } from '../polygon-information.service';
import type { Feature, Polygon, MultiPolygon } from 'geojson';
import type { PolydrawConfig, PolydrawPolygon } from '../types/polydraw-interfaces';
import { ModeManager } from './mode-manager';
import { EventManager, PolydrawEvent, PolydrawEventCallback } from './event-manager';
import { PolygonInteractionManager } from './polygon-interaction-manager';
export interface MutationResult {
    success: boolean;
    featureGroups?: L.FeatureGroup[];
    error?: string;
}
export interface AddPolygonOptions {
    simplify?: boolean;
    noMerge?: boolean;
    dynamicTolerance?: boolean;
    visualOptimizationLevel?: number;
}
export interface MutationManagerDependencies {
    turfHelper: TurfHelper;
    polygonInformation: PolygonInformationService;
    map: L.Map;
    config: PolydrawConfig;
    modeManager: ModeManager;
    eventManager: EventManager;
    getFeatureGroups: () => L.FeatureGroup[];
}
/**
 * PolygonMutationManager acts as a facade that coordinates between specialized managers.
 * It maintains the arrayOfFeatureGroups as the single source of truth and delegates
 * operations to the appropriate specialized managers.
 */
export declare class PolygonMutationManager {
    private turfHelper;
    private map;
    private config;
    private eventManager;
    private getFeatureGroups;
    private geometryManager;
    private interactionManager;
    constructor(dependencies: MutationManagerDependencies);
    /**
     * Initialize the three specialized managers
     */
    private initializeSpecializedManagers;
    /**
     * Set up event forwarding from specialized managers to facade
     */
    private setupEventForwarding;
    /**
     * Handle polygon modification from interaction manager
     */
    private handlePolygonModified;
    /**
     * Handle menu actions from interaction manager
     */
    private handleMenuAction;
    /**
     * Get the polygon interaction manager (for testing)
     */
    get polygonInteractionManager(): PolygonInteractionManager;
    /**
     * Add event listener
     */
    on<T extends PolydrawEvent>(event: T, callback: PolydrawEventCallback<T>): void;
    /**
     * Emit event to all listeners
     */
    private emit;
    /**
     * Add a polygon with optional merging logic
     */
    addPolygon(latlngs: Feature<Polygon | MultiPolygon>, options?: AddPolygonOptions): Promise<MutationResult>;
    /**
     * Subtract a polygon from existing polygons
     */
    subtractPolygon(latlngs: Feature<Polygon | MultiPolygon>): Promise<MutationResult>;
    /**
     * Create and add a polygon layer with all markers and interactions
     */
    private addPolygonLayer;
    /**
     * Merge a polygon with existing intersecting polygons
     */
    private mergePolygon;
    /**
     * Union multiple polygons together using geometry manager
     */
    private unionPolygons;
    /**
     * Create a polygon from GeoJSON feature
     */
    private isPositionArrayofArrays;
    private isPosition;
    /**
     * Create a polygon from GeoJSON feature
     */
    private getPolygon;
    /**
     * Internal method to add feature group to array
     */
    private addFeatureGroupInternal;
    /**
     * Internal method to remove feature group from array and map
     */
    private removeFeatureGroupInternal;
    /**
     * Get complete polygon GeoJSON including holes from a feature group
     */
    private getCompletePolygonFromFeatureGroup;
    /**
     * Update marker draggable state
     */
    updateMarkerDraggableState(): void;
    /**
     * Update all markers for edge deletion visual feedback
     */
    updateAllMarkersForEdgeDeletion(showFeedback: boolean): void;
    /**
     * Set modifier key held state
     */
    setModifierKeyHeld(isHeld: boolean): void;
    /**
     * Check if two polygons intersect (delegates to geometry manager)
     */
    checkPolygonIntersection(polygon1: Feature<Polygon | MultiPolygon>, polygon2: Feature<Polygon | MultiPolygon>): boolean;
    /**
     * Get polygon center (delegates to geometry manager)
     */
    getPolygonCenter(polygon: Feature<Polygon | MultiPolygon>): {
        lat: number;
        lng: number;
    } | null;
    /**
     * Get bounding box from polygon (delegates to geometry manager)
     */
    getBoundingBox(polygon: Feature<Polygon | MultiPolygon>): {
        minLat: number;
        maxLat: number;
        minLng: number;
        maxLng: number;
    } | null;
    addMarker(latlngs: L.LatLngLiteral[], featureGroup: L.FeatureGroup): void;
    addHoleMarker(latlngs: L.LatLngLiteral[], featureGroup: L.FeatureGroup): void;
    addEdgeClickListeners(polygon: L.Polygon, featureGroup: L.FeatureGroup): void;
    enablePolygonDragging(polygon: PolydrawPolygon, latlngs: Feature<Polygon | MultiPolygon>): void;
    getMarkerIndex(latlngs: L.LatLngLiteral[], position: L.LatLngLiteral): number;
    ensureMarkerSeparation(polygonLength: number, markers: {
        menu?: {
            index?: number;
        };
        delete?: {
            index?: number;
        };
        info?: {
            index?: number;
        };
    }): {
        menu: number;
        delete: number;
        info: number;
    };
    findAlternativeMarkerPosition(polygonLength: number, originalIndex: number, usedIndices: Set<number>): number;
    createDivIcon(processedClasses: string[]): L.DivIcon;
    getLatLngInfoString(latlng: L.LatLngLiteral): string;
    generateMenuMarkerPopup(latLngs: L.LatLngLiteral[], featureGroup: L.FeatureGroup): HTMLDivElement;
    getPolygonGeoJSONFromFeatureGroup(featureGroup: L.FeatureGroup): Feature<Polygon | MultiPolygon>;
    getTotalPolygonPerimeter(polygonGeoJSON: Feature<Polygon | MultiPolygon>): number;
    generateInfoMarkerPopup(area: number, perimeter: number): HTMLDivElement;
    onMarkerHoverForEdgeDeletion(marker: L.Marker, isHovering: boolean): void;
    highlightEdgeOnHover(edgePolyline: L.Polyline, isHovering: boolean): void;
    onEdgeClick(e: L.LeafletMouseEvent, edgePolyline: L.Polyline): void;
    removeFeatureGroup(featureGroup: L.FeatureGroup): void;
    onPolygonMouseMove(e: L.LeafletMouseEvent): void;
    onPolygonMouseUp(e: L.LeafletMouseEvent): void;
    updatePolygonAfterDrag(polygon: L.Polygon): void;
    setSubtractVisualMode(polygon: L.Polygon, enabled: boolean): void;
    performModifierSubtract(draggedGeoJSON: Feature<Polygon | MultiPolygon>, originalFeatureGroup: L.FeatureGroup): void;
}
//# sourceMappingURL=polygon-mutation-manager.d.ts.map