import { type Coord } from './geojson-helpers';
import type { Feature, Polygon, MultiPolygon, Position, Point } from 'geojson';
import * as L from 'leaflet';
export declare class TurfHelper {
    private config;
    constructor(config: object);
    union(poly1: Feature<Polygon | MultiPolygon>, poly2: Feature<Polygon | MultiPolygon>): Feature<Polygon | MultiPolygon> | null;
    /**
     * Create polygon from drawing trace using configured method
     */
    createPolygonFromTrace(feature: Feature<any>): Feature<Polygon | MultiPolygon>;
    /**
     * Original concaveman implementation
     */
    turfConcaveman(feature: Feature<Polygon | MultiPolygon>): Feature<Polygon | MultiPolygon>;
    /**
     * Create convex hull polygon (simplest, fewest edges)
     */
    private createConvexPolygon;
    /**
     * Create polygon directly from line coordinates (moderate edge count)
     */
    private createDirectPolygon;
    /**
     * Create polygon using buffer method (smooth curves)
     */
    private createBufferedPolygon;
    getSimplified(polygon: Feature<Polygon | MultiPolygon>, dynamicTolerance?: boolean): Feature<Polygon | MultiPolygon>;
    getTurfPolygon(polygon: Feature<Polygon | MultiPolygon>): Feature<Polygon | MultiPolygon>;
    getMultiPolygon(polygonArray: Position[][][]): Feature<Polygon | MultiPolygon>;
    getKinks(feature: Feature<Polygon | MultiPolygon>): Feature<Polygon | MultiPolygon, import("geojson").GeoJsonProperties>[];
    getCoords(feature: Feature<Polygon | MultiPolygon>): Position[][][];
    hasKinks(feature: Feature<Polygon | MultiPolygon>): boolean;
    /**
     * Get the convex hull of a polygon
     */
    getConvexHull(polygon: Feature<Polygon | MultiPolygon>): Feature<Polygon> | null;
    /**
     * Calculate midpoint between two LatLngLiteral points
     */
    getMidpoint(point1: L.LatLngLiteral, point2: L.LatLngLiteral): L.LatLngLiteral;
    polygonIntersect(polygon: Feature<Polygon | MultiPolygon>, latlngs: Feature<Polygon | MultiPolygon>): boolean;
    getIntersection(poly1: Feature<Polygon | MultiPolygon>, poly2: Feature<Polygon | MultiPolygon>): Feature<Polygon | MultiPolygon> | null;
    getDistance(point1: any, point2: any): number;
    isWithin(polygon1: Position[], polygon2: Position[]): boolean;
    /**
     * Check if one polygon is completely within another polygon
     */
    isPolygonCompletelyWithin(innerPolygon: Feature<Polygon | MultiPolygon>, outerPolygon: Feature<Polygon | MultiPolygon>): boolean;
    /**
     * Normalize various point-like inputs into a GeoJSON Feature<Point>.
     * Supports GeoJSON Feature<Point>, Turf Position [lng, lat], and Leaflet LatLngLiteral.
     */
    private toPointFeature;
    /**
     * Check if a point lies within a polygon.
     * Accepts Feature<Point>, Turf Position [lng, lat], or Leaflet LatLngLiteral.
     * This normalization prevents noisy console warnings in tests.
     */
    isPointInsidePolygon(pt: Feature<Point> | Position | L.LatLngLiteral, polygon: Feature<Polygon | MultiPolygon>): boolean;
    /**
     * Checks if two polygons are equal.
     * @param polygon1 First polygon.
     * @param polygon2 Second polygon.
     */
    equalPolygons(polygon1: Feature<Polygon | MultiPolygon>, polygon2: Feature<Polygon | MultiPolygon>): boolean;
    convertToBoundingBoxPolygon(polygon: Feature<Polygon | MultiPolygon>): Feature<Polygon>;
    polygonToMultiPolygon(poly: Feature<Polygon>): Feature<MultiPolygon>;
    injectPointToPolygon(polygon: Feature<Polygon | MultiPolygon>, point: Position, ringIndex: number): Feature<Polygon | MultiPolygon>;
    private distanceToLineSegment;
    polygonDifference(polygon1: Feature<Polygon | MultiPolygon>, polygon2: Feature<Polygon | MultiPolygon>): Feature<Polygon | MultiPolygon> | null;
    getBoundingBoxCompassPosition(_polygon: any, _MarkerPosition: any, _useOffset: any, _offsetDirection: any): null;
    getNearestPointIndex(targetPoint: Coord, points: any): number;
    /**
     * Convert LatLngLiteral object to js coordinate array format.
     *
     * This method serves as a semantic interface for coordinate conversion,
     * ensuring consistent lng/lat order when interfacing with js functions.
     * While simple, it provides a clear contract and future-proofing for any
     * coordinate validation or transformation that might be needed later.
     *
     * @param point - LatLngLiteral object with lat/lng properties
     * @returns js coordinate array in [lng, lat] format
     */
    getCoord(point: L.LatLngLiteral): Coord;
    /**
     * Create a GeoJSON polygon feature from coordinates.
     * This method provides access to the turf polygon helper function
     * while keeping all turf imports centralized in this file.
     *
     * @param coordinates - Array of coordinate rings (outer ring + holes)
     * @returns GeoJSON Feature<Polygon>
     */
    createPolygon(coordinates: Position[][]): Feature<Polygon>;
    getFeaturePointCollection(points: L.LatLngLiteral[]): any;
    getPolygonArea(poly: Feature<Polygon | MultiPolygon>): number;
    getPolygonPerimeter(poly: Feature<Polygon | MultiPolygon>): number;
    getCenterOfMass(feature: Feature<Polygon | MultiPolygon>): Feature<Point, import("geojson").GeoJsonProperties>;
    getDoubleElbowLatLngs(points: L.LatLngLiteral[]): L.LatLngLiteral[];
    getBezierMultiPolygon(polygonArray: Position[][][]): Feature<Polygon | MultiPolygon>;
    /**
     * Check if a polygon has holes (more than one ring)
     */
    private polygonHasHoles;
    /**
     * Handle kinks in polygons with holes while preserving hole structure
     */
    private getKinksWithHolePreservation;
    /**
     * Check if the drag line goes completely through a hole (like cutting cake)
     */
    private checkIfDragCompletelyThroughHole;
    /**
     * Find the line created by self-intersection in the outer ring
     */
    private findSelfIntersectionLine;
    /**
     * Check if a line completely traverses a hole
     */
    private lineCompletelyTraversesHole;
    /**
     * Check if a hole is cut by the kinks in the outer ring
     */
    private holeIsCutByKinks;
    /**
     * Find duplicate points in a ring (excluding first/last which should be the same)
     */
    private findDuplicatePoints;
    /**
     * Check if outer ring intersects with holes (fallback detection for hole traversal)
     */
    private checkOuterRingHoleIntersection;
    /**
     * Handle complete hole traversal - create solid polygons (cake cutting)
     */
    private handleCompleteHoleTraversal;
    /**
     * Subtract intersecting holes from a polygon to create proper "bite" shapes
     */
    private subtractIntersectingHoles;
    /**
     * Remove duplicate vertices from a polygon to prevent turf errors
     */
    removeDuplicateVertices(feature: Feature<Polygon | MultiPolygon>): Feature<Polygon | MultiPolygon>;
}
//# sourceMappingURL=turf-helper.d.ts.map