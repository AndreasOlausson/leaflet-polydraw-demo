import * as turf from '@turf/turf';
import type { Feature, Polygon, MultiPolygon, Position } from 'geojson';
import * as L from 'leaflet';
export declare class TurfHelper {
    private config;
    constructor(config: object);
    union(poly1: Feature<Polygon | MultiPolygon>, poly2: Feature<Polygon | MultiPolygon>): Feature<Polygon | MultiPolygon>;
    /**
     * Create polygon from drawing trace using configured method
     */
    createPolygonFromTrace(feature: Feature<any>): Feature<Polygon | MultiPolygon>;
    /**
     * Original concaveman implementation
     */
    turfConcaveman(feature: Feature<Polygon | MultiPolygon>): Feature<Polygon | MultiPolygon>;
    /**
     * Create convex hull polygon (simplest, fewest edges)
     */
    private createConvexPolygon;
    /**
     * Create polygon directly from line coordinates (moderate edge count)
     */
    private createDirectPolygon;
    /**
     * Create polygon using buffer method (smooth curves)
     */
    private createBufferedPolygon;
    getSimplified(polygon: Feature<Polygon | MultiPolygon>, dynamicTolerance?: boolean): Feature<Polygon | MultiPolygon>;
    getTurfPolygon(polygon: Feature<Polygon | MultiPolygon>): Feature<Polygon | MultiPolygon>;
    getMultiPolygon(polygonArray: Position[][][]): Feature<Polygon | MultiPolygon>;
    getKinks(feature: Feature<Polygon | MultiPolygon>): any[];
    getCoords(feature: Feature<Polygon | MultiPolygon>): any[];
    hasKinks(feature: Feature<Polygon | MultiPolygon>): boolean;
    /**
     * Get the convex hull of a polygon
     */
    getConvexHull(polygon: Feature<Polygon | MultiPolygon>): Feature<Polygon> | null;
    /**
     * Calculate midpoint between two LatLngLiteral points
     */
    getMidpoint(point1: L.LatLngLiteral, point2: L.LatLngLiteral): L.LatLngLiteral;
    polygonIntersect(polygon: Feature<Polygon | MultiPolygon>, latlngs: Feature<Polygon | MultiPolygon>): boolean;
    getIntersection(poly1: Feature<Polygon | MultiPolygon>, poly2: Feature<Polygon | MultiPolygon>): Feature<Polygon | MultiPolygon> | null;
    getDistance(point1: any, point2: any): number;
    isWithin(polygon1: Position[], polygon2: Position[]): boolean;
    /**
     * Check if one polygon is completely within another polygon
     */
    isPolygonCompletelyWithin(innerPolygon: Feature<Polygon | MultiPolygon>, outerPolygon: Feature<Polygon | MultiPolygon>): boolean;
    /**
     * Checks if two polygons are equal.
     * @param polygon1 First polygon.
     * @param polygon2 Second polygon.
     */
    equalPolygons(polygon1: Feature<Polygon | MultiPolygon>, polygon2: Feature<Polygon | MultiPolygon>): void;
    convertToBoundingBoxPolygon(polygon: Feature<Polygon | MultiPolygon>): Feature<Polygon>;
    polygonToMultiPolygon(poly: Feature<Polygon>): Feature<MultiPolygon>;
    injectPointToPolygon(polygon: any, point: any): any;
    private distanceToLineSegment;
    polygonDifference(polygon1: Feature<Polygon | MultiPolygon>, polygon2: Feature<Polygon | MultiPolygon>): Feature<Polygon | MultiPolygon>;
    getBoundingBoxCompassPosition(polygon: any, MarkerPosition: any, useOffset: any, offsetDirection: any): any;
    getNearestPointIndex(targetPoint: turf.Coord, points: any): number;
    /**
     * Convert LatLngLiteral object to Turf.js coordinate array format.
     *
     * This method serves as a semantic interface for coordinate conversion,
     * ensuring consistent lng/lat order when interfacing with Turf.js functions.
     * While simple, it provides a clear contract and future-proofing for any
     * coordinate validation or transformation that might be needed later.
     *
     * @param point - LatLngLiteral object with lat/lng properties
     * @returns Turf.js coordinate array in [lng, lat] format
     */
    getCoord(point: L.LatLngLiteral): turf.Coord;
    getFeaturePointCollection(points: L.LatLngLiteral[]): any;
    getPolygonArea(poly: Feature<Polygon | MultiPolygon>): number;
    getPolygonPerimeter(poly: Feature<Polygon | MultiPolygon>): number;
    getCenterOfMass(feature: Feature<Polygon | MultiPolygon>): Feature<import("geojson").Point, {
        [name: string]: any;
    }>;
    getDoubleElbowLatLngs(points: L.LatLngLiteral[]): L.LatLngLiteral[];
    getBezierMultiPolygon(polygonArray: Position[][][]): Feature<Polygon | MultiPolygon>;
    /**
     * Check if a polygon has holes (more than one ring)
     */
    private polygonHasHoles;
    /**
     * Handle kinks in polygons with holes while preserving hole structure
     */
    private getKinksWithHolePreservation;
    /**
     * Check if the drag line goes completely through a hole (like cutting cake)
     */
    private checkIfDragCompletelyThroughHole;
    /**
     * Find the line created by self-intersection in the outer ring
     */
    private findSelfIntersectionLine;
    /**
     * Check if a line completely traverses a hole
     */
    private lineCompletelyTraversesHole;
    /**
     * Check if a hole is cut by the kinks in the outer ring
     */
    private holeIsCutByKinks;
    /**
     * Find duplicate points in a ring (excluding first/last which should be the same)
     */
    private findDuplicatePoints;
    /**
     * Check if outer ring intersects with holes (fallback detection for hole traversal)
     */
    private checkOuterRingHoleIntersection;
    /**
     * Handle complete hole traversal - create solid polygons (cake cutting)
     */
    private handleCompleteHoleTraversal;
    /**
     * Assign holes to a polygon based on containment and intersection analysis
     */
    private assignHolesToPolygon;
    /**
     * Analyze the relationship between a hole and a polygon
     */
    private analyzeHolePolygonRelationship;
    /**
     * Subtract intersecting holes from a polygon to create proper "bite" shapes
     */
    private subtractIntersectingHoles;
    /**
     * Calculate the area of a ring using the shoelace formula
     */
    private calculateRingArea;
    /**
     * Remove duplicate vertices from a polygon to prevent turf errors
     */
    removeDuplicateVertices(feature: Feature<Polygon | MultiPolygon>): Feature<Polygon | MultiPolygon>;
    /**
     * Create a "bite" by subtracting the intersected part of the hole from the polygon
     */
    private createBiteFromHoleIntersection;
}
//# sourceMappingURL=turf-helper.d.ts.map