var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a, _b;
import * as L from "leaflet";
const touchSupport = true;
const mergePolygons = true;
const kinks$1 = false;
const modes = { "draw": true, "subtract": true, "deleteAll": true, "p2p": true, "attachElbow": true, "dragElbow": true, "dragPolygons": true, "edgeDeletion": true };
const dragPolygons = { "realTimeUpdate": false, "showDragHandle": false, "opacity": 0.7, "dragCursor": "move", "hoverCursor": "grab", "markerBehavior": "hide", "markerAnimationDuration": 200, "autoMergeOnIntersect": true, "autoHoleOnContained": false, "dragInteractionBehavior": "auto", "modifierSubtract": { "enabled": true, "keys": { "windows": "ctrlKey", "mac": "metaKey", "linux": "ctrlKey" }, "hideMarkersOnDrag": true } };
const edgeDeletion = { "enabled": true, "keys": { "windows": "ctrlKey", "mac": "metaKey", "linux": "ctrlKey" }, "confirmDeletion": false, "minVertices": 3 };
const markers = { "deleteMarker": true, "infoMarker": true, "menuMarker": true, "coordsTitle": true, "zIndexOffset": 0, "markerIcon": { "styleClasses": ["polygon-marker"], "zIndexOffset": null }, "holeIcon": { "styleClasses": ["polygon-marker", "hole"], "zIndexOffset": null }, "markerInfoIcon": { "position": 3, "showArea": true, "showPerimeter": true, "useMetrics": true, "usePerimeterMinValue": false, "areaLabel": "Area", "perimeterLabel": "Perimeter", "values": { "min": { "metric": "50", "imperial": "100" }, "unknown": { "metric": "-", "imperial": "-" } }, "units": { "unknownUnit": "", "metric": { "onlyMetrics": true, "perimeter": { "m": "m", "km": "km" }, "area": { "m2": "m²", "km2": "km²", "daa": "daa", "ha": "ha" } }, "imperial": { "perimeter": { "feet": "ft", "yards": "yd", "miles": "mi" }, "area": { "feet2": "ft²", "yards2": "yd²", "acres": "ac", "miles2": "mi²" } } }, "styleClasses": ["polygon-marker", "info"], "zIndexOffset": 1e4 }, "markerMenuIcon": { "position": 7, "styleClasses": ["polygon-marker", "menu"], "zIndexOffset": 1e4 }, "markerDeleteIcon": { "position": 5, "styleClasses": ["polygon-marker", "delete"], "zIndexOffset": 1e4 }, "holeMarkers": { "menuMarker": false, "deleteMarker": true, "infoMarker": false }, "visualOptimization": { "sharpAngleThreshold": 30, "thresholdBoundingBox": 0.05, "thresholdDistance": 0.05, "useDistance": true, "useBoundingBox": false, "useAngles": false } };
const polyLineOptions = { "opacity": 1, "smoothFactor": 0, "noClip": true, "clickable": false, "weight": 2 };
const subtractLineOptions = { "opacity": 1, "smoothFactor": 0, "noClip": true, "clickable": false, "weight": 2 };
const polygonOptions = { "smoothFactor": 0.3, "noClip": true };
const holeOptions = { "weight": 2, "opacity": 1, "fillOpacity": 0.5 };
const polygonCreation = { "method": "concaveman", "simplification": { "mode": "simple", "tolerance": 1e-5, "highQuality": false } };
const simplification = { "simplifyTolerance": { "tolerance": 1e-4, "highQuality": false, "mutate": false }, "dynamicMode": { "fractionGuard": 0.9, "multipiler": 2 } };
const menuOperations = { "simplify": { "processHoles": true }, "doubleElbows": { "processHoles": true }, "bbox": { "processHoles": true } };
const boundingBox = { "addMidPointMarkers": true };
const bezier$1 = { "resolution": 1e4, "sharpness": 0.75 };
const colors = { "dragPolygons": { "subtract": "#D9460F" }, "p2p": { "closingMarker": "#4CAF50" }, "edgeHover": "#7a9441", "edgeDeletion": { "hover": "#D9460F" }, "polyline": "#50622b", "subtractLine": "#50622b", "polygon": { "border": "#50622b", "fill": "#b4cd8a" }, "hole": { "border": "#aa0000", "fill": "#ffcccc" }, "styles": { "controlButton": { "backgroundColor": "#fff", "color": "#000" }, "controlButtonHover": { "backgroundColor": "#f4f4f4" }, "controlButtonActive": { "backgroundColor": "rgb(128, 218, 255)", "color": "#fff" }, "indicatorActive": { "backgroundColor": "#ffcc00" }, "p2pMarker": { "backgroundColor": "#fff", "borderColor": "#50622b" } } };
const defaultConfig = {
  touchSupport,
  mergePolygons,
  kinks: kinks$1,
  modes,
  dragPolygons,
  edgeDeletion,
  markers,
  polyLineOptions,
  subtractLineOptions,
  polygonOptions,
  holeOptions,
  polygonCreation,
  simplification,
  menuOperations,
  boundingBox,
  bezier: bezier$1,
  colors
};
var DrawMode = /* @__PURE__ */ ((DrawMode2) => {
  DrawMode2[DrawMode2["Off"] = 0] = "Off";
  DrawMode2[DrawMode2["Add"] = 1] = "Add";
  DrawMode2[DrawMode2["Edit"] = 2] = "Edit";
  DrawMode2[DrawMode2["Subtract"] = 4] = "Subtract";
  DrawMode2[DrawMode2["AppendMarker"] = 8] = "AppendMarker";
  DrawMode2[DrawMode2["LoadPredefined"] = 16] = "LoadPredefined";
  DrawMode2[DrawMode2["PointToPoint"] = 32] = "PointToPoint";
  return DrawMode2;
})(DrawMode || {});
var MarkerPosition = /* @__PURE__ */ ((MarkerPosition2) => {
  MarkerPosition2[MarkerPosition2["SouthWest"] = 0] = "SouthWest";
  MarkerPosition2[MarkerPosition2["South"] = 1] = "South";
  MarkerPosition2[MarkerPosition2["SouthEast"] = 2] = "SouthEast";
  MarkerPosition2[MarkerPosition2["East"] = 3] = "East";
  MarkerPosition2[MarkerPosition2["NorthEast"] = 4] = "NorthEast";
  MarkerPosition2[MarkerPosition2["North"] = 5] = "North";
  MarkerPosition2[MarkerPosition2["NorthWest"] = 6] = "NorthWest";
  MarkerPosition2[MarkerPosition2["West"] = 7] = "West";
  MarkerPosition2[MarkerPosition2["Hole"] = 8] = "Hole";
  return MarkerPosition2;
})(MarkerPosition || {});
var earthRadius = 63710088e-1;
var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: 360 / (2 * Math.PI),
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
function feature(geom, properties, options = {}) {
  const feat = { type: "Feature" };
  if (options.id === 0 || options.id) {
    feat.id = options.id;
  }
  if (options.bbox) {
    feat.bbox = options.bbox;
  }
  feat.properties = properties || {};
  feat.geometry = geom;
  return feat;
}
function point(coordinates, properties, options = {}) {
  if (!coordinates) {
    throw new Error("coordinates is required");
  }
  if (!Array.isArray(coordinates)) {
    throw new Error("coordinates must be an Array");
  }
  if (coordinates.length < 2) {
    throw new Error("coordinates must be at least 2 numbers long");
  }
  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
    throw new Error("coordinates must contain numbers");
  }
  const geom = {
    type: "Point",
    coordinates
  };
  return feature(geom, properties, options);
}
function polygon(coordinates, properties, options = {}) {
  for (const ring of coordinates) {
    if (ring.length < 4) {
      throw new Error(
        "Each LinearRing of a Polygon must have 4 or more Positions."
      );
    }
    if (ring[ring.length - 1].length !== ring[0].length) {
      throw new Error("First and last Position are not equivalent.");
    }
    for (let j = 0; j < ring[ring.length - 1].length; j++) {
      if (ring[ring.length - 1][j] !== ring[0][j]) {
        throw new Error("First and last Position are not equivalent.");
      }
    }
  }
  const geom = {
    type: "Polygon",
    coordinates
  };
  return feature(geom, properties, options);
}
function lineString(coordinates, properties, options = {}) {
  if (coordinates.length < 2) {
    throw new Error("coordinates must be an array of two or more positions");
  }
  const geom = {
    type: "LineString",
    coordinates
  };
  return feature(geom, properties, options);
}
function featureCollection(features, options = {}) {
  const fc = { type: "FeatureCollection" };
  if (options.id) {
    fc.id = options.id;
  }
  if (options.bbox) {
    fc.bbox = options.bbox;
  }
  fc.features = features;
  return fc;
}
function multiLineString(coordinates, properties, options = {}) {
  const geom = {
    type: "MultiLineString",
    coordinates
  };
  return feature(geom, properties, options);
}
function multiPolygon(coordinates, properties, options = {}) {
  const geom = {
    type: "MultiPolygon",
    coordinates
  };
  return feature(geom, properties, options);
}
function radiansToLength(radians2, units = "kilometers") {
  const factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return radians2 * factor;
}
function lengthToRadians(distance2, units = "kilometers") {
  const factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return distance2 / factor;
}
function radiansToDegrees(radians2) {
  const normalisedRadians = radians2 % (2 * Math.PI);
  return normalisedRadians * 180 / Math.PI;
}
function degreesToRadians(degrees2) {
  const normalisedDegrees = degrees2 % 360;
  return normalisedDegrees * Math.PI / 180;
}
function isNumber(num) {
  return !isNaN(num) && num !== null && !Array.isArray(num);
}
function isObject$1(input) {
  return input !== null && typeof input === "object" && !Array.isArray(input);
}
function getCoord(coord) {
  if (!coord) {
    throw new Error("coord is required");
  }
  if (!Array.isArray(coord)) {
    if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
      return [...coord.geometry.coordinates];
    }
    if (coord.type === "Point") {
      return [...coord.coordinates];
    }
  }
  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
    return [...coord];
  }
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function getCoords(coords) {
  if (Array.isArray(coords)) {
    return coords;
  }
  if (coords.type === "Feature") {
    if (coords.geometry !== null) {
      return coords.geometry.coordinates;
    }
  } else {
    if (coords.coordinates) {
      return coords.coordinates;
    }
  }
  throw new Error(
    "coords must be GeoJSON Feature, Geometry Object or an Array"
  );
}
function getGeom(geojson) {
  if (geojson.type === "Feature") {
    return geojson.geometry;
  }
  return geojson;
}
function getType(geojson, _name) {
  if (geojson.type === "FeatureCollection") {
    return "FeatureCollection";
  }
  if (geojson.type === "GeometryCollection") {
    return "GeometryCollection";
  }
  if (geojson.type === "Feature" && geojson.geometry !== null) {
    return geojson.geometry.type;
  }
  return geojson.type;
}
function bearing(start, end, options = {}) {
  if (options.final === true) {
    return calculateFinalBearing(start, end);
  }
  const coordinates1 = getCoord(start);
  const coordinates2 = getCoord(end);
  const lon1 = degreesToRadians(coordinates1[0]);
  const lon2 = degreesToRadians(coordinates2[0]);
  const lat1 = degreesToRadians(coordinates1[1]);
  const lat2 = degreesToRadians(coordinates2[1]);
  const a = Math.sin(lon2 - lon1) * Math.cos(lat2);
  const b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
  return radiansToDegrees(Math.atan2(a, b));
}
function calculateFinalBearing(start, end) {
  let bear = bearing(end, start);
  bear = (bear + 180) % 360;
  return bear;
}
function destination(origin, distance2, bearing2, options = {}) {
  const coordinates1 = getCoord(origin);
  const longitude1 = degreesToRadians(coordinates1[0]);
  const latitude1 = degreesToRadians(coordinates1[1]);
  const bearingRad = degreesToRadians(bearing2);
  const radians2 = lengthToRadians(distance2, options.units);
  const latitude2 = Math.asin(
    Math.sin(latitude1) * Math.cos(radians2) + Math.cos(latitude1) * Math.sin(radians2) * Math.cos(bearingRad)
  );
  const longitude2 = longitude1 + Math.atan2(
    Math.sin(bearingRad) * Math.sin(radians2) * Math.cos(latitude1),
    Math.cos(radians2) - Math.sin(latitude1) * Math.sin(latitude2)
  );
  const lng = radiansToDegrees(longitude2);
  const lat = radiansToDegrees(latitude2);
  return point([lng, lat], options.properties);
}
function distance(from, to, options = {}) {
  var coordinates1 = getCoord(from);
  var coordinates2 = getCoord(to);
  var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);
  var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);
  var lat1 = degreesToRadians(coordinates1[1]);
  var lat2 = degreesToRadians(coordinates2[1]);
  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
  return radiansToLength(
    2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)),
    options.units
  );
}
function coordEach(geojson, callback, excludeWrapCoord) {
  if (geojson === null) return;
  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
      var multiFeatureIndex = 0;
      var geometryIndex = 0;
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
      if (geometry === null) continue;
      coords = geometry.coordinates;
      var geomType = geometry.type;
      wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
      switch (geomType) {
        case null:
          break;
        case "Point":
          if (callback(
            coords,
            coordIndex,
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          ) === false)
            return false;
          coordIndex++;
          multiFeatureIndex++;
          break;
        case "LineString":
        case "MultiPoint":
          for (j = 0; j < coords.length; j++) {
            if (callback(
              coords[j],
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            if (geomType === "MultiPoint") multiFeatureIndex++;
          }
          if (geomType === "LineString") multiFeatureIndex++;
          break;
        case "Polygon":
        case "MultiLineString":
          for (j = 0; j < coords.length; j++) {
            for (k = 0; k < coords[j].length - wrapShrink; k++) {
              if (callback(
                coords[j][k],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
            }
            if (geomType === "MultiLineString") multiFeatureIndex++;
            if (geomType === "Polygon") geometryIndex++;
          }
          if (geomType === "Polygon") multiFeatureIndex++;
          break;
        case "MultiPolygon":
          for (j = 0; j < coords.length; j++) {
            geometryIndex = 0;
            for (k = 0; k < coords[j].length; k++) {
              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                if (callback(
                  coords[j][k][l],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              geometryIndex++;
            }
            multiFeatureIndex++;
          }
          break;
        case "GeometryCollection":
          for (j = 0; j < geometry.geometries.length; j++)
            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)
              return false;
          break;
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
  }
}
function featureEach(geojson, callback) {
  if (geojson.type === "Feature") {
    callback(geojson, 0);
  } else if (geojson.type === "FeatureCollection") {
    for (var i = 0; i < geojson.features.length; i++) {
      if (callback(geojson.features[i], i) === false) break;
    }
  }
}
function geomEach(geojson, callback) {
  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId2, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (i = 0; i < stop; i++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
    featureId2 = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (g = 0; g < stopG; g++) {
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
      if (geometry === null) {
        if (callback(
          null,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId2
        ) === false)
          return false;
        continue;
      }
      switch (geometry.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (callback(
            geometry,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId2
          ) === false)
            return false;
          break;
        }
        case "GeometryCollection": {
          for (j = 0; j < geometry.geometries.length; j++) {
            if (callback(
              geometry.geometries[j],
              featureIndex,
              featureProperties,
              featureBBox,
              featureId2
            ) === false)
              return false;
          }
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    featureIndex++;
  }
}
function geomReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  geomEach(
    geojson,
    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId2) {
      previousValue = callback(
        previousValue,
        currentGeometry,
        featureIndex,
        featureProperties,
        featureBBox,
        featureId2
      );
    }
  );
  return previousValue;
}
function flattenEach(geojson, callback) {
  geomEach(geojson, function(geometry, featureIndex, properties, bbox2, id) {
    var type = geometry === null ? null : geometry.type;
    switch (type) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        if (callback(
          feature(geometry, properties, { bbox: bbox2, id }),
          featureIndex,
          0
        ) === false)
          return false;
        return;
    }
    var geomType;
    switch (type) {
      case "MultiPoint":
        geomType = "Point";
        break;
      case "MultiLineString":
        geomType = "LineString";
        break;
      case "MultiPolygon":
        geomType = "Polygon";
        break;
    }
    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
      var coordinate = geometry.coordinates[multiFeatureIndex];
      var geom = {
        type: geomType,
        coordinates: coordinate
      };
      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)
        return false;
    }
  });
}
function segmentEach(geojson, callback) {
  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
    var segmentIndex = 0;
    if (!feature2.geometry) return;
    var type = feature2.geometry.type;
    if (type === "Point" || type === "MultiPoint") return;
    var previousCoords;
    var previousFeatureIndex = 0;
    var previousMultiIndex = 0;
    var prevGeomIndex = 0;
    if (coordEach(
      feature2,
      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
          previousCoords = currentCoord;
          previousFeatureIndex = featureIndex;
          previousMultiIndex = multiPartIndexCoord;
          prevGeomIndex = geometryIndex;
          segmentIndex = 0;
          return;
        }
        var currentSegment = lineString(
          [previousCoords, currentCoord],
          feature2.properties
        );
        if (callback(
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        ) === false)
          return false;
        segmentIndex++;
        previousCoords = currentCoord;
      }
    ) === false)
      return false;
  });
}
function segmentReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  var started = false;
  segmentEach(
    geojson,
    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
      if (started === false && initialValue === void 0)
        previousValue = currentSegment;
      else
        previousValue = callback(
          previousValue,
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        );
      started = true;
    }
  );
  return previousValue;
}
function area(geojson) {
  return geomReduce(
    geojson,
    (value, geom) => {
      return value + calculateArea$1(geom);
    },
    0
  );
}
function calculateArea$1(geom) {
  let total = 0;
  let i;
  switch (geom.type) {
    case "Polygon":
      return polygonArea(geom.coordinates);
    case "MultiPolygon":
      for (i = 0; i < geom.coordinates.length; i++) {
        total += polygonArea(geom.coordinates[i]);
      }
      return total;
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
      return 0;
  }
  return 0;
}
function polygonArea(coords) {
  let total = 0;
  if (coords && coords.length > 0) {
    total += Math.abs(ringArea(coords[0]));
    for (let i = 1; i < coords.length; i++) {
      total -= Math.abs(ringArea(coords[i]));
    }
  }
  return total;
}
var FACTOR = earthRadius * earthRadius / 2;
var PI_OVER_180 = Math.PI / 180;
function ringArea(coords) {
  const coordsLength = coords.length - 1;
  if (coordsLength <= 2) return 0;
  let total = 0;
  let i = 0;
  while (i < coordsLength) {
    const lower = coords[i];
    const middle = coords[i + 1 === coordsLength ? 0 : i + 1];
    const upper = coords[i + 2 >= coordsLength ? (i + 2) % coordsLength : i + 2];
    const lowerX = lower[0] * PI_OVER_180;
    const middleY = middle[1] * PI_OVER_180;
    const upperX = upper[0] * PI_OVER_180;
    total += (upperX - lowerX) * Math.sin(middleY);
    i++;
  }
  return total * FACTOR;
}
function bbox(geojson, options = {}) {
  if (geojson.bbox != null && true !== options.recompute) {
    return geojson.bbox;
  }
  const result = [Infinity, Infinity, -Infinity, -Infinity];
  coordEach(geojson, (coord) => {
    if (result[0] > coord[0]) {
      result[0] = coord[0];
    }
    if (result[1] > coord[1]) {
      result[1] = coord[1];
    }
    if (result[2] < coord[0]) {
      result[2] = coord[0];
    }
    if (result[3] < coord[1]) {
      result[3] = coord[1];
    }
  });
  return result;
}
function bboxPolygon(bbox2, options = {}) {
  const west = Number(bbox2[0]);
  const south = Number(bbox2[1]);
  const east = Number(bbox2[2]);
  const north = Number(bbox2[3]);
  if (bbox2.length === 6) {
    throw new Error(
      "@turf/bbox-polygon does not support BBox with 6 positions"
    );
  }
  const lowLeft = [west, south];
  const topLeft = [west, north];
  const topRight = [east, north];
  const lowRight = [east, south];
  return polygon(
    [[lowLeft, lowRight, topRight, topLeft, lowLeft]],
    options.properties,
    { bbox: bbox2, id: options.id }
  );
}
var Spline = class {
  constructor(options) {
    this.points = options.points || [];
    this.duration = options.duration || 1e4;
    this.sharpness = options.sharpness || 0.85;
    this.centers = [];
    this.controls = [];
    this.stepLength = options.stepLength || 60;
    this.length = this.points.length;
    this.delay = 0;
    for (let i = 0; i < this.length; i++) {
      this.points[i].z = this.points[i].z || 0;
    }
    for (let i = 0; i < this.length - 1; i++) {
      const p1 = this.points[i];
      const p2 = this.points[i + 1];
      this.centers.push({
        x: (p1.x + p2.x) / 2,
        y: (p1.y + p2.y) / 2,
        z: (p1.z + p2.z) / 2
      });
    }
    this.controls.push([this.points[0], this.points[0]]);
    for (let i = 0; i < this.centers.length - 1; i++) {
      const dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;
      const dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;
      const dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;
      this.controls.push([
        {
          x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i].x + dx),
          y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i].y + dy),
          z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i].z + dz)
        },
        {
          x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i + 1].x + dx),
          y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i + 1].y + dy),
          z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i + 1].z + dz)
        }
      ]);
    }
    this.controls.push([
      this.points[this.length - 1],
      this.points[this.length - 1]
    ]);
    this.steps = this.cacheSteps(this.stepLength);
    return this;
  }
  /**
   * Caches an array of equidistant (more or less) points on the curve.
   */
  cacheSteps(mindist) {
    const steps = [];
    let laststep = this.pos(0);
    steps.push(0);
    for (let t = 0; t < this.duration; t += 10) {
      const step = this.pos(t);
      const dist = Math.sqrt(
        (step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z)
      );
      if (dist > mindist) {
        steps.push(t);
        laststep = step;
      }
    }
    return steps;
  }
  /**
   * returns angle and speed in the given point in the curve
   */
  vector(t) {
    const p1 = this.pos(t + 10);
    const p2 = this.pos(t - 10);
    return {
      angle: 180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,
      speed: Math.sqrt(
        (p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z)
      )
    };
  }
  /**
   * Gets the position of the point, given time.
   *
   * WARNING: The speed is not constant. The time it takes between control points is constant.
   *
   * For constant speed, use Spline.steps[i];
   */
  pos(time) {
    let t = time - this.delay;
    if (t < 0) {
      t = 0;
    }
    if (t > this.duration) {
      t = this.duration - 1;
    }
    const t2 = t / this.duration;
    if (t2 >= 1) {
      return this.points[this.length - 1];
    }
    const n = Math.floor((this.points.length - 1) * t2);
    const t1 = (this.length - 1) * t2 - n;
    return bezier(
      t1,
      this.points[n],
      this.controls[n][1],
      this.controls[n + 1][0],
      this.points[n + 1]
    );
  }
};
function bezier(t, p1, c1, c2, p2) {
  const b = B$1(t);
  const pos = {
    x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],
    y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],
    z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]
  };
  return pos;
}
function B$1(t) {
  const t2 = t * t;
  const t3 = t2 * t;
  return [
    t3,
    3 * t2 * (1 - t),
    3 * t * (1 - t) * (1 - t),
    (1 - t) * (1 - t) * (1 - t)
  ];
}
function bezierSpline(line, options = {}) {
  const resolution = options.resolution || 1e4;
  const sharpness = options.sharpness || 0.85;
  const coords = [];
  const points = getGeom(line).coordinates.map((pt) => {
    return { x: pt[0], y: pt[1] };
  });
  const spline = new Spline({
    duration: resolution,
    points,
    sharpness
  });
  const pushCoord = (time) => {
    var pos = spline.pos(time);
    if (Math.floor(time / 100) % 2 === 0) {
      coords.push([pos.x, pos.y]);
    }
  };
  for (var i = 0; i < spline.duration; i += 10) {
    pushCoord(i);
  }
  pushCoord(spline.duration);
  return lineString(coords, options.properties);
}
const epsilon$1 = 11102230246251565e-32;
const splitter = 134217729;
const resulterrbound = (3 + 8 * epsilon$1) * epsilon$1;
function sum$1(elen, e, flen, f, h) {
  let Q, Qnew, hh, bvirt;
  let enow = e[0];
  let fnow = f[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q = enow;
    enow = e[++eindex];
  } else {
    Q = fnow;
    fnow = f[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q;
      hh = Q - (Qnew - enow);
      enow = e[++eindex];
    } else {
      Qnew = fnow + Q;
      hh = Q - (Qnew - fnow);
      fnow = f[++findex];
    }
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e[++eindex];
      } else {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q + enow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (enow - bvirt);
    enow = e[++eindex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q + fnow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f[++findex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  if (Q !== 0 || hindex === 0) {
    h[hindex++] = Q;
  }
  return hindex;
}
function estimate(elen, e) {
  let Q = e[0];
  for (let i = 1; i < elen; i++) Q += e[i];
  return Q;
}
function vec(n) {
  return new Float64Array(n);
}
const ccwerrboundA = (3 + 16 * epsilon$1) * epsilon$1;
const ccwerrboundB = (2 + 12 * epsilon$1) * epsilon$1;
const ccwerrboundC = (9 + 64 * epsilon$1) * epsilon$1 * epsilon$1;
const B = vec(4);
const C1 = vec(8);
const C2 = vec(12);
const D = vec(16);
const u = vec(4);
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c = splitter * acx;
  ahi = c - (c - acx);
  alo = acx - ahi;
  c = splitter * bcy;
  bhi = c - (c - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcx;
  c = splitter * acy;
  ahi = c - (c - acy);
  alo = acy - ahi;
  c = splitter * bcx;
  bhi = c - (c - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  B[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  B[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  B[2] = _j - (u3 - bvirt) + (_i - bvirt);
  B[3] = u3;
  let det = estimate(4, B);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound) return det;
  s1 = acxtail * bcy;
  c = splitter * acxtail;
  ahi = c - (c - acxtail);
  alo = acxtail - ahi;
  c = splitter * bcy;
  bhi = c - (c - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcx;
  c = splitter * acytail;
  ahi = c - (c - acytail);
  alo = acytail - ahi;
  c = splitter * bcx;
  bhi = c - (c - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  u[2] = _j - (u3 - bvirt) + (_i - bvirt);
  u[3] = u3;
  const C1len = sum$1(4, B, 4, u, C1);
  s1 = acx * bcytail;
  c = splitter * acx;
  ahi = c - (c - acx);
  alo = acx - ahi;
  c = splitter * bcytail;
  bhi = c - (c - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcxtail;
  c = splitter * acy;
  ahi = c - (c - acy);
  alo = acy - ahi;
  c = splitter * bcxtail;
  bhi = c - (c - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  u[2] = _j - (u3 - bvirt) + (_i - bvirt);
  u[3] = u3;
  const C2len = sum$1(C1len, C1, 4, u, C2);
  s1 = acxtail * bcytail;
  c = splitter * acxtail;
  ahi = c - (c - acxtail);
  alo = acxtail - ahi;
  c = splitter * bcytail;
  bhi = c - (c - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcxtail;
  c = splitter * acytail;
  ahi = c - (c - acytail);
  alo = acytail - ahi;
  c = splitter * bcxtail;
  bhi = c - (c - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  u[2] = _j - (u3 - bvirt) + (_i - bvirt);
  u[3] = u3;
  const Dlen = sum$1(C2len, C2, 4, u, D);
  return D[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum) return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}
function pointInPolygon$1(p, polygon2) {
  var i;
  var ii;
  var k = 0;
  var f;
  var u1;
  var v1;
  var u2;
  var v2;
  var currentP;
  var nextP;
  var x = p[0];
  var y = p[1];
  var numContours = polygon2.length;
  for (i = 0; i < numContours; i++) {
    ii = 0;
    var contour = polygon2[i];
    var contourLen = contour.length - 1;
    currentP = contour[0];
    if (currentP[0] !== contour[contourLen][0] && currentP[1] !== contour[contourLen][1]) {
      throw new Error("First and last coordinates in a ring must be the same");
    }
    u1 = currentP[0] - x;
    v1 = currentP[1] - y;
    for (ii; ii < contourLen; ii++) {
      nextP = contour[ii + 1];
      u2 = nextP[0] - x;
      v2 = nextP[1] - y;
      if (v1 === 0 && v2 === 0) {
        if (u2 <= 0 && u1 >= 0 || u1 <= 0 && u2 >= 0) {
          return 0;
        }
      } else if (v2 >= 0 && v1 <= 0 || v2 <= 0 && v1 >= 0) {
        f = orient2d(u1, u2, v1, v2, 0, 0);
        if (f === 0) {
          return 0;
        }
        if (f > 0 && v2 > 0 && v1 <= 0 || f < 0 && v2 <= 0 && v1 > 0) {
          k++;
        }
      }
      currentP = nextP;
      v1 = v2;
      u1 = u2;
    }
  }
  if (k % 2 === 0) {
    return false;
  }
  return true;
}
function booleanPointInPolygon(point2, polygon2, options = {}) {
  if (!point2) {
    throw new Error("point is required");
  }
  if (!polygon2) {
    throw new Error("polygon is required");
  }
  const pt = getCoord(point2);
  const geom = getGeom(polygon2);
  const type = geom.type;
  const bbox2 = polygon2.bbox;
  let polys = geom.coordinates;
  if (bbox2 && inBBox(pt, bbox2) === false) {
    return false;
  }
  if (type === "Polygon") {
    polys = [polys];
  }
  let result = false;
  for (var i = 0; i < polys.length; ++i) {
    const polyResult = pointInPolygon$1(pt, polys[i]);
    if (polyResult === 0) return options.ignoreBoundary ? false : true;
    else if (polyResult) result = true;
  }
  return result;
}
function inBBox(pt, bbox2) {
  return bbox2[0] <= pt[0] && bbox2[1] <= pt[1] && bbox2[2] >= pt[0] && bbox2[3] >= pt[1];
}
function booleanPointOnLine(pt, line, options = {}) {
  const ptCoords = getCoord(pt);
  const lineCoords = getCoords(line);
  for (let i = 0; i < lineCoords.length - 1; i++) {
    let ignoreBoundary = false;
    if (options.ignoreEndVertices) {
      if (i === 0) {
        ignoreBoundary = "start";
      }
      if (i === lineCoords.length - 2) {
        ignoreBoundary = "end";
      }
      if (i === 0 && i + 1 === lineCoords.length - 1) {
        ignoreBoundary = "both";
      }
    }
    if (isPointOnLineSegment$1(
      lineCoords[i],
      lineCoords[i + 1],
      ptCoords,
      ignoreBoundary,
      typeof options.epsilon === "undefined" ? null : options.epsilon
    )) {
      return true;
    }
  }
  return false;
}
function isPointOnLineSegment$1(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon2) {
  const x = pt[0];
  const y = pt[1];
  const x12 = lineSegmentStart[0];
  const y12 = lineSegmentStart[1];
  const x2 = lineSegmentEnd[0];
  const y2 = lineSegmentEnd[1];
  const dxc = pt[0] - x12;
  const dyc = pt[1] - y12;
  const dxl = x2 - x12;
  const dyl = y2 - y12;
  const cross = dxc * dyl - dyc * dxl;
  if (epsilon2 !== null) {
    if (Math.abs(cross) > epsilon2) {
      return false;
    }
  } else if (cross !== 0) {
    return false;
  }
  if (Math.abs(dxl) === Math.abs(dyl) && Math.abs(dxl) === 0) {
    if (excludeBoundary) {
      return false;
    }
    if (pt[0] === lineSegmentStart[0] && pt[1] === lineSegmentStart[1]) {
      return true;
    } else {
      return false;
    }
  }
  if (!excludeBoundary) {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? x12 <= x && x <= x2 : x2 <= x && x <= x12;
    }
    return dyl > 0 ? y12 <= y && y <= y2 : y2 <= y && y <= y12;
  } else if (excludeBoundary === "start") {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? x12 < x && x <= x2 : x2 <= x && x < x12;
    }
    return dyl > 0 ? y12 < y && y <= y2 : y2 <= y && y < y12;
  } else if (excludeBoundary === "end") {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? x12 <= x && x < x2 : x2 < x && x <= x12;
    }
    return dyl > 0 ? y12 <= y && y < y2 : y2 < y && y <= y12;
  } else if (excludeBoundary === "both") {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? x12 < x && x < x2 : x2 < x && x < x12;
    }
    return dyl > 0 ? y12 < y && y < y2 : y2 < y && y < y12;
  }
  return false;
}
let TinyQueue$1 = class TinyQueue {
  constructor(data = [], compare2 = defaultCompare$2) {
    this.data = data;
    this.length = this.data.length;
    this.compare = compare2;
    if (this.length > 0) {
      for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
    }
  }
  push(item) {
    this.data.push(item);
    this.length++;
    this._up(this.length - 1);
  }
  pop() {
    if (this.length === 0) return void 0;
    const top = this.data[0];
    const bottom = this.data.pop();
    this.length--;
    if (this.length > 0) {
      this.data[0] = bottom;
      this._down(0);
    }
    return top;
  }
  peek() {
    return this.data[0];
  }
  _up(pos) {
    const { data, compare: compare2 } = this;
    const item = data[pos];
    while (pos > 0) {
      const parent = pos - 1 >> 1;
      const current = data[parent];
      if (compare2(item, current) >= 0) break;
      data[pos] = current;
      pos = parent;
    }
    data[pos] = item;
  }
  _down(pos) {
    const { data, compare: compare2 } = this;
    const halfLength = this.length >> 1;
    const item = data[pos];
    while (pos < halfLength) {
      let left = (pos << 1) + 1;
      let best = data[left];
      const right = left + 1;
      if (right < this.length && compare2(data[right], best) < 0) {
        left = right;
        best = data[right];
      }
      if (compare2(best, item) >= 0) break;
      data[pos] = best;
      pos = left;
    }
    data[pos] = item;
  }
};
function defaultCompare$2(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
function checkWhichEventIsLeft(e1, e2) {
  if (e1.p.x > e2.p.x) return 1;
  if (e1.p.x < e2.p.x) return -1;
  if (e1.p.y !== e2.p.y) return e1.p.y > e2.p.y ? 1 : -1;
  return 1;
}
function checkWhichSegmentHasRightEndpointFirst(seg1, seg2) {
  if (seg1.rightSweepEvent.p.x > seg2.rightSweepEvent.p.x) return 1;
  if (seg1.rightSweepEvent.p.x < seg2.rightSweepEvent.p.x) return -1;
  if (seg1.rightSweepEvent.p.y !== seg2.rightSweepEvent.p.y) return seg1.rightSweepEvent.p.y < seg2.rightSweepEvent.p.y ? 1 : -1;
  return 1;
}
class Event {
  constructor(p, featureId2, ringId2, eventId2) {
    this.p = {
      x: p[0],
      y: p[1]
    };
    this.featureId = featureId2;
    this.ringId = ringId2;
    this.eventId = eventId2;
    this.otherEvent = null;
    this.isLeftEndpoint = null;
  }
  isSamePoint(eventToCheck) {
    return this.p.x === eventToCheck.p.x && this.p.y === eventToCheck.p.y;
  }
}
function fillEventQueue(geojson, eventQueue) {
  if (geojson.type === "FeatureCollection") {
    const features = geojson.features;
    for (let i = 0; i < features.length; i++) {
      processFeature(features[i], eventQueue);
    }
  } else {
    processFeature(geojson, eventQueue);
  }
}
let featureId = 0;
let ringId = 0;
let eventId = 0;
function processFeature(featureOrGeometry, eventQueue) {
  const geom = featureOrGeometry.type === "Feature" ? featureOrGeometry.geometry : featureOrGeometry;
  let coords = geom.coordinates;
  if (geom.type === "Polygon" || geom.type === "MultiLineString") coords = [coords];
  if (geom.type === "LineString") coords = [[coords]];
  for (let i = 0; i < coords.length; i++) {
    for (let ii = 0; ii < coords[i].length; ii++) {
      let currentP = coords[i][ii][0];
      let nextP = null;
      ringId = ringId + 1;
      for (let iii = 0; iii < coords[i][ii].length - 1; iii++) {
        nextP = coords[i][ii][iii + 1];
        const e1 = new Event(currentP, featureId, ringId, eventId);
        const e2 = new Event(nextP, featureId, ringId, eventId + 1);
        e1.otherEvent = e2;
        e2.otherEvent = e1;
        if (checkWhichEventIsLeft(e1, e2) > 0) {
          e2.isLeftEndpoint = true;
          e1.isLeftEndpoint = false;
        } else {
          e1.isLeftEndpoint = true;
          e2.isLeftEndpoint = false;
        }
        eventQueue.push(e1);
        eventQueue.push(e2);
        currentP = nextP;
        eventId = eventId + 1;
      }
    }
  }
  featureId = featureId + 1;
}
let Segment$1 = class Segment {
  constructor(event) {
    this.leftSweepEvent = event;
    this.rightSweepEvent = event.otherEvent;
  }
};
function testSegmentIntersect(seg1, seg2) {
  if (seg1 === null || seg2 === null) return false;
  if (seg1.leftSweepEvent.ringId === seg2.leftSweepEvent.ringId && (seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) || seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) || seg1.rightSweepEvent.isSamePoint(seg2.rightSweepEvent) || seg1.leftSweepEvent.isSamePoint(seg2.leftSweepEvent) || seg1.leftSweepEvent.isSamePoint(seg2.rightSweepEvent))) return false;
  const x12 = seg1.leftSweepEvent.p.x;
  const y12 = seg1.leftSweepEvent.p.y;
  const x2 = seg1.rightSweepEvent.p.x;
  const y2 = seg1.rightSweepEvent.p.y;
  const x3 = seg2.leftSweepEvent.p.x;
  const y3 = seg2.leftSweepEvent.p.y;
  const x4 = seg2.rightSweepEvent.p.x;
  const y4 = seg2.rightSweepEvent.p.y;
  const denom = (y4 - y3) * (x2 - x12) - (x4 - x3) * (y2 - y12);
  const numeA = (x4 - x3) * (y12 - y3) - (y4 - y3) * (x12 - x3);
  const numeB = (x2 - x12) * (y12 - y3) - (y2 - y12) * (x12 - x3);
  if (denom === 0) {
    if (numeA === 0 && numeB === 0) return false;
    return false;
  }
  const uA = numeA / denom;
  const uB = numeB / denom;
  if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
    const x = x12 + uA * (x2 - x12);
    const y = y12 + uA * (y2 - y12);
    return [x, y];
  }
  return false;
}
function runCheck(eventQueue, ignoreSelfIntersections) {
  ignoreSelfIntersections = ignoreSelfIntersections ? ignoreSelfIntersections : false;
  const intersectionPoints = [];
  const outQueue = new TinyQueue$1([], checkWhichSegmentHasRightEndpointFirst);
  while (eventQueue.length) {
    const event = eventQueue.pop();
    if (event.isLeftEndpoint) {
      const segment = new Segment$1(event);
      for (let i = 0; i < outQueue.data.length; i++) {
        const otherSeg = outQueue.data[i];
        if (ignoreSelfIntersections) {
          if (otherSeg.leftSweepEvent.featureId === event.featureId) continue;
        }
        const intersection3 = testSegmentIntersect(segment, otherSeg);
        if (intersection3 !== false) intersectionPoints.push(intersection3);
      }
      outQueue.push(segment);
    } else if (event.isLeftEndpoint === false) {
      outQueue.pop();
    }
  }
  return intersectionPoints;
}
function sweeplineIntersections$1(geojson, ignoreSelfIntersections) {
  const eventQueue = new TinyQueue$1([], checkWhichEventIsLeft);
  fillEventQueue(geojson, eventQueue);
  return runCheck(eventQueue, ignoreSelfIntersections);
}
var sweeplineIntersections = sweeplineIntersections$1;
function lineIntersect(line1, line2, options = {}) {
  const { removeDuplicates = true, ignoreSelfIntersections = true } = options;
  let features = [];
  if (line1.type === "FeatureCollection")
    features = features.concat(line1.features);
  else if (line1.type === "Feature") features.push(line1);
  else if (line1.type === "LineString" || line1.type === "Polygon" || line1.type === "MultiLineString" || line1.type === "MultiPolygon") {
    features.push(feature(line1));
  }
  if (line2.type === "FeatureCollection")
    features = features.concat(line2.features);
  else if (line2.type === "Feature") features.push(line2);
  else if (line2.type === "LineString" || line2.type === "Polygon" || line2.type === "MultiLineString" || line2.type === "MultiPolygon") {
    features.push(feature(line2));
  }
  const intersections = sweeplineIntersections(
    featureCollection(features),
    ignoreSelfIntersections
  );
  let results = [];
  if (removeDuplicates) {
    const unique = {};
    intersections.forEach((intersection3) => {
      const key = intersection3.join(",");
      if (!unique[key]) {
        unique[key] = true;
        results.push(intersection3);
      }
    });
  } else {
    results = intersections;
  }
  return featureCollection(results.map((r) => point(r)));
}
function polygonToLine(poly, options = {}) {
  const geom = getGeom(poly);
  if (!options.properties && poly.type === "Feature") {
    options.properties = poly.properties;
  }
  switch (geom.type) {
    case "Polygon":
      return singlePolygonToLine(geom, options);
    case "MultiPolygon":
      return multiPolygonToLine(geom, options);
    default:
      throw new Error("invalid poly");
  }
}
function singlePolygonToLine(poly, options = {}) {
  const geom = getGeom(poly);
  const coords = geom.coordinates;
  const properties = options.properties ? options.properties : poly.type === "Feature" ? poly.properties : {};
  return coordsToLine(coords, properties);
}
function multiPolygonToLine(multiPoly, options = {}) {
  const geom = getGeom(multiPoly);
  const coords = geom.coordinates;
  const properties = options.properties ? options.properties : multiPoly.type === "Feature" ? multiPoly.properties : {};
  const lines = [];
  coords.forEach((coord) => {
    lines.push(coordsToLine(coord, properties));
  });
  return featureCollection(lines);
}
function coordsToLine(coords, properties) {
  if (coords.length > 1) {
    return multiLineString(coords, properties);
  }
  return lineString(coords[0], properties);
}
var __defProp$1 = Object.defineProperty;
var __name = (target, value) => __defProp$1(target, "name", { value, configurable: true });
var _GeojsonEquality = class _GeojsonEquality2 {
  constructor(opts) {
    this.direction = false;
    this.compareProperties = true;
    var _a2, _b2, _c;
    this.precision = 10 ** -((_a2 = opts == null ? void 0 : opts.precision) != null ? _a2 : 17);
    this.direction = (_b2 = opts == null ? void 0 : opts.direction) != null ? _b2 : false;
    this.compareProperties = (_c = opts == null ? void 0 : opts.compareProperties) != null ? _c : true;
  }
  compare(g1, g2) {
    if (g1.type !== g2.type) {
      return false;
    }
    if (!sameLength(g1, g2)) {
      return false;
    }
    switch (g1.type) {
      case "Point":
        return this.compareCoord(g1.coordinates, g2.coordinates);
      case "LineString":
        return this.compareLine(g1.coordinates, g2.coordinates);
      case "Polygon":
        return this.comparePolygon(g1, g2);
      case "GeometryCollection":
        return this.compareGeometryCollection(g1, g2);
      case "Feature":
        return this.compareFeature(g1, g2);
      case "FeatureCollection":
        return this.compareFeatureCollection(g1, g2);
      default:
        if (g1.type.startsWith("Multi")) {
          const g1s = explode$1(g1);
          const g2s = explode$1(
            g2
          );
          return g1s.every(
            (g1part) => g2s.some((g2part) => this.compare(g1part, g2part))
          );
        }
    }
    return false;
  }
  compareCoord(c1, c2) {
    return c1.length === c2.length && c1.every((c, i) => Math.abs(c - c2[i]) < this.precision);
  }
  compareLine(path1, path2, ind = 0, isPoly = false) {
    if (!sameLength(path1, path2)) {
      return false;
    }
    const p1 = path1;
    let p2 = path2;
    if (isPoly && !this.compareCoord(p1[0], p2[0])) {
      const startIndex = this.fixStartIndex(p2, p1);
      if (!startIndex) {
        return false;
      } else {
        p2 = startIndex;
      }
    }
    const sameDirection = this.compareCoord(p1[ind], p2[ind]);
    if (this.direction || sameDirection) {
      return this.comparePath(p1, p2);
    } else {
      if (this.compareCoord(p1[ind], p2[p2.length - (1 + ind)])) {
        return this.comparePath(p1.slice().reverse(), p2);
      }
      return false;
    }
  }
  fixStartIndex(sourcePath, targetPath) {
    let correctPath, ind = -1;
    for (let i = 0; i < sourcePath.length; i++) {
      if (this.compareCoord(sourcePath[i], targetPath[0])) {
        ind = i;
        break;
      }
    }
    if (ind >= 0) {
      correctPath = [].concat(
        sourcePath.slice(ind, sourcePath.length),
        sourcePath.slice(1, ind + 1)
      );
    }
    return correctPath;
  }
  comparePath(p1, p2) {
    return p1.every((c, i) => this.compareCoord(c, p2[i]));
  }
  comparePolygon(g1, g2) {
    if (this.compareLine(g1.coordinates[0], g2.coordinates[0], 1, true)) {
      const holes1 = g1.coordinates.slice(1, g1.coordinates.length);
      const holes2 = g2.coordinates.slice(1, g2.coordinates.length);
      return holes1.every(
        (h1) => holes2.some((h2) => this.compareLine(h1, h2, 1, true))
      );
    }
    return false;
  }
  compareGeometryCollection(g1, g2) {
    return sameLength(g1.geometries, g2.geometries) && this.compareBBox(g1, g2) && g1.geometries.every((g, i) => this.compare(g, g2.geometries[i]));
  }
  compareFeature(g1, g2) {
    return g1.id === g2.id && (this.compareProperties ? equal(g1.properties, g2.properties) : true) && this.compareBBox(g1, g2) && this.compare(g1.geometry, g2.geometry);
  }
  compareFeatureCollection(g1, g2) {
    return sameLength(g1.features, g2.features) && this.compareBBox(g1, g2) && g1.features.every((f, i) => this.compare(f, g2.features[i]));
  }
  compareBBox(g1, g2) {
    return Boolean(!g1.bbox && !g2.bbox) || (g1.bbox && g2.bbox ? this.compareCoord(g1.bbox, g2.bbox) : false);
  }
};
__name(_GeojsonEquality, "GeojsonEquality");
var GeojsonEquality = _GeojsonEquality;
function sameLength(g1, g2) {
  return g1.coordinates ? g1.coordinates.length === g2.coordinates.length : g1.length === g2.length;
}
__name(sameLength, "sameLength");
function explode$1(g) {
  return g.coordinates.map((part) => ({
    type: g.type.replace("Multi", ""),
    coordinates: part
  }));
}
__name(explode$1, "explode");
function geojsonEquality(g1, g2, opts) {
  const eq = new GeojsonEquality(opts);
  return eq.compare(g1, g2);
}
__name(geojsonEquality, "geojsonEquality");
function equal(object1, object2) {
  if (object1 === null && object2 === null) {
    return true;
  }
  if (object1 === null || object2 === null) {
    return false;
  }
  const objKeys1 = Object.keys(object1);
  const objKeys2 = Object.keys(object2);
  if (objKeys1.length !== objKeys2.length) return false;
  for (var key of objKeys1) {
    const value1 = object1[key];
    const value2 = object2[key];
    const isObjects = isObject(value1) && isObject(value2);
    if (isObjects && !equal(value1, value2) || !isObjects && value1 !== value2) {
      return false;
    }
  }
  return true;
}
__name(equal, "equal");
var isObject = /* @__PURE__ */ __name((object) => {
  return object != null && typeof object === "object";
}, "isObject");
function cleanCoords(geojson, options = {}) {
  var mutate = typeof options === "object" ? options.mutate : options;
  if (!geojson) throw new Error("geojson is required");
  var type = getType(geojson);
  var newCoords = [];
  switch (type) {
    case "LineString":
      newCoords = cleanLine(geojson, type);
      break;
    case "MultiLineString":
    case "Polygon":
      getCoords(geojson).forEach(function(line) {
        newCoords.push(cleanLine(line, type));
      });
      break;
    case "MultiPolygon":
      getCoords(geojson).forEach(function(polygons) {
        var polyPoints = [];
        polygons.forEach(function(ring) {
          polyPoints.push(cleanLine(ring, type));
        });
        newCoords.push(polyPoints);
      });
      break;
    case "Point":
      return geojson;
    case "MultiPoint":
      var existing = {};
      getCoords(geojson).forEach(function(coord) {
        var key = coord.join("-");
        if (!Object.prototype.hasOwnProperty.call(existing, key)) {
          newCoords.push(coord);
          existing[key] = true;
        }
      });
      break;
    default:
      throw new Error(type + " geometry not supported");
  }
  if (geojson.coordinates) {
    if (mutate === true) {
      geojson.coordinates = newCoords;
      return geojson;
    }
    return { type, coordinates: newCoords };
  } else {
    if (mutate === true) {
      geojson.geometry.coordinates = newCoords;
      return geojson;
    }
    return feature({ type, coordinates: newCoords }, geojson.properties, {
      bbox: geojson.bbox,
      id: geojson.id
    });
  }
}
function cleanLine(line, type) {
  var points = getCoords(line);
  if (points.length === 2 && !equals(points[0], points[1])) return points;
  var newPoints = [];
  var secondToLast = points.length - 1;
  var newPointsLength = newPoints.length;
  newPoints.push(points[0]);
  for (var i = 1; i < secondToLast; i++) {
    var prevAddedPoint = newPoints[newPoints.length - 1];
    if (points[i][0] === prevAddedPoint[0] && points[i][1] === prevAddedPoint[1])
      continue;
    else {
      newPoints.push(points[i]);
      newPointsLength = newPoints.length;
      if (newPointsLength > 2) {
        if (isPointOnLineSegment(
          newPoints[newPointsLength - 3],
          newPoints[newPointsLength - 1],
          newPoints[newPointsLength - 2]
        ))
          newPoints.splice(newPoints.length - 2, 1);
      }
    }
  }
  newPoints.push(points[points.length - 1]);
  newPointsLength = newPoints.length;
  if ((type === "Polygon" || type === "MultiPolygon") && equals(points[0], points[points.length - 1]) && newPointsLength < 4) {
    throw new Error("invalid polygon");
  }
  if (type === "LineString" && newPointsLength < 3) {
    return newPoints;
  }
  if (isPointOnLineSegment(
    newPoints[newPointsLength - 3],
    newPoints[newPointsLength - 1],
    newPoints[newPointsLength - 2]
  ))
    newPoints.splice(newPoints.length - 2, 1);
  return newPoints;
}
function equals(pt1, pt2) {
  return pt1[0] === pt2[0] && pt1[1] === pt2[1];
}
function isPointOnLineSegment(start, end, point2) {
  var x = point2[0], y = point2[1];
  var startX = start[0], startY = start[1];
  var endX = end[0], endY = end[1];
  var dxc = x - startX;
  var dyc = y - startY;
  var dxl = endX - startX;
  var dyl = endY - startY;
  var cross = dxc * dyl - dyc * dxl;
  if (cross !== 0) return false;
  else if (Math.abs(dxl) >= Math.abs(dyl))
    return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;
  else return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;
}
function booleanEqual(feature1, feature2, options = {}) {
  let precision2 = options.precision;
  precision2 = precision2 === void 0 || precision2 === null || isNaN(precision2) ? 6 : precision2;
  if (typeof precision2 !== "number" || !(precision2 >= 0)) {
    throw new Error("precision must be a positive number");
  }
  const type1 = getGeom(feature1).type;
  const type2 = getGeom(feature2).type;
  if (type1 !== type2) return false;
  return geojsonEquality(cleanCoords(feature1), cleanCoords(feature2), {
    precision: precision2
  });
}
function quickselect(arr, k, left, right, compare2) {
  quickselectStep(arr, k, left || 0, right || arr.length - 1, compare2 || defaultCompare$1);
}
function quickselectStep(arr, k, left, right, compare2) {
  while (right > left) {
    if (right - left > 600) {
      var n = right - left + 1;
      var m = k - left + 1;
      var z = Math.log(n);
      var s = 0.5 * Math.exp(2 * z / 3);
      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselectStep(arr, k, newLeft, newRight, compare2);
    }
    var t = arr[k];
    var i = left;
    var j = right;
    swap(arr, left, k);
    if (compare2(arr[right], t) > 0) swap(arr, left, right);
    while (i < j) {
      swap(arr, i, j);
      i++;
      j--;
      while (compare2(arr[i], t) < 0) i++;
      while (compare2(arr[j], t) > 0) j--;
    }
    if (compare2(arr[left], t) === 0) swap(arr, left, j);
    else {
      j++;
      swap(arr, j, right);
    }
    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
}
function swap(arr, i, j) {
  var tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultCompare$1(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
class RBush {
  constructor(maxEntries = 9) {
    this._maxEntries = Math.max(4, maxEntries);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
    this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(bbox2) {
    let node = this.data;
    const result = [];
    if (!intersects(bbox2, node)) return result;
    const toBBox = this.toBBox;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? toBBox(child) : child;
        if (intersects(bbox2, childBBox)) {
          if (node.leaf) result.push(child);
          else if (contains(bbox2, childBBox)) this._all(child, result);
          else nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return result;
  }
  collides(bbox2) {
    let node = this.data;
    if (!intersects(bbox2, node)) return false;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? this.toBBox(child) : child;
        if (intersects(bbox2, childBBox)) {
          if (node.leaf || contains(bbox2, childBBox)) return true;
          nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return false;
  }
  load(data) {
    if (!(data && data.length)) return this;
    if (data.length < this._minEntries) {
      for (let i = 0; i < data.length; i++) {
        this.insert(data[i]);
      }
      return this;
    }
    let node = this._build(data.slice(), 0, data.length - 1, 0);
    if (!this.data.children.length) {
      this.data = node;
    } else if (this.data.height === node.height) {
      this._splitRoot(this.data, node);
    } else {
      if (this.data.height < node.height) {
        const tmpNode = this.data;
        this.data = node;
        node = tmpNode;
      }
      this._insert(node, this.data.height - node.height - 1, true);
    }
    return this;
  }
  insert(item) {
    if (item) this._insert(item, this.data.height - 1);
    return this;
  }
  clear() {
    this.data = createNode([]);
    return this;
  }
  remove(item, equalsFn) {
    if (!item) return this;
    let node = this.data;
    const bbox2 = this.toBBox(item);
    const path = [];
    const indexes = [];
    let i, parent, goingUp;
    while (node || path.length) {
      if (!node) {
        node = path.pop();
        parent = path[path.length - 1];
        i = indexes.pop();
        goingUp = true;
      }
      if (node.leaf) {
        const index = findItem(item, node.children, equalsFn);
        if (index !== -1) {
          node.children.splice(index, 1);
          path.push(node);
          this._condense(path);
          return this;
        }
      }
      if (!goingUp && !node.leaf && contains(node, bbox2)) {
        path.push(node);
        indexes.push(i);
        i = 0;
        parent = node;
        node = node.children[0];
      } else if (parent) {
        i++;
        node = parent.children[i];
        goingUp = false;
      } else node = null;
    }
    return this;
  }
  toBBox(item) {
    return item;
  }
  compareMinX(a, b) {
    return a.minX - b.minX;
  }
  compareMinY(a, b) {
    return a.minY - b.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(data) {
    this.data = data;
    return this;
  }
  _all(node, result) {
    const nodesToSearch = [];
    while (node) {
      if (node.leaf) result.push(...node.children);
      else nodesToSearch.push(...node.children);
      node = nodesToSearch.pop();
    }
    return result;
  }
  _build(items, left, right, height) {
    const N = right - left + 1;
    let M = this._maxEntries;
    let node;
    if (N <= M) {
      node = createNode(items.slice(left, right + 1));
      calcBBox(node, this.toBBox);
      return node;
    }
    if (!height) {
      height = Math.ceil(Math.log(N) / Math.log(M));
      M = Math.ceil(N / Math.pow(M, height - 1));
    }
    node = createNode([]);
    node.leaf = false;
    node.height = height;
    const N2 = Math.ceil(N / M);
    const N1 = N2 * Math.ceil(Math.sqrt(M));
    multiSelect(items, left, right, N1, this.compareMinX);
    for (let i = left; i <= right; i += N1) {
      const right2 = Math.min(i + N1 - 1, right);
      multiSelect(items, i, right2, N2, this.compareMinY);
      for (let j = i; j <= right2; j += N2) {
        const right3 = Math.min(j + N2 - 1, right2);
        node.children.push(this._build(items, j, right3, height - 1));
      }
    }
    calcBBox(node, this.toBBox);
    return node;
  }
  _chooseSubtree(bbox2, node, level, path) {
    while (true) {
      path.push(node);
      if (node.leaf || path.length - 1 === level) break;
      let minArea = Infinity;
      let minEnlargement = Infinity;
      let targetNode;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const area2 = bboxArea(child);
        const enlargement = enlargedArea(bbox2, child) - area2;
        if (enlargement < minEnlargement) {
          minEnlargement = enlargement;
          minArea = area2 < minArea ? area2 : minArea;
          targetNode = child;
        } else if (enlargement === minEnlargement) {
          if (area2 < minArea) {
            minArea = area2;
            targetNode = child;
          }
        }
      }
      node = targetNode || node.children[0];
    }
    return node;
  }
  _insert(item, level, isNode) {
    const bbox2 = isNode ? item : this.toBBox(item);
    const insertPath = [];
    const node = this._chooseSubtree(bbox2, this.data, level, insertPath);
    node.children.push(item);
    extend(node, bbox2);
    while (level >= 0) {
      if (insertPath[level].children.length > this._maxEntries) {
        this._split(insertPath, level);
        level--;
      } else break;
    }
    this._adjustParentBBoxes(bbox2, insertPath, level);
  }
  // split overflowed node into two
  _split(insertPath, level) {
    const node = insertPath[level];
    const M = node.children.length;
    const m = this._minEntries;
    this._chooseSplitAxis(node, m, M);
    const splitIndex = this._chooseSplitIndex(node, m, M);
    const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
    newNode.height = node.height;
    newNode.leaf = node.leaf;
    calcBBox(node, this.toBBox);
    calcBBox(newNode, this.toBBox);
    if (level) insertPath[level - 1].children.push(newNode);
    else this._splitRoot(node, newNode);
  }
  _splitRoot(node, newNode) {
    this.data = createNode([node, newNode]);
    this.data.height = node.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
  }
  _chooseSplitIndex(node, m, M) {
    let index;
    let minOverlap = Infinity;
    let minArea = Infinity;
    for (let i = m; i <= M - m; i++) {
      const bbox1 = distBBox(node, 0, i, this.toBBox);
      const bbox2 = distBBox(node, i, M, this.toBBox);
      const overlap = intersectionArea(bbox1, bbox2);
      const area2 = bboxArea(bbox1) + bboxArea(bbox2);
      if (overlap < minOverlap) {
        minOverlap = overlap;
        index = i;
        minArea = area2 < minArea ? area2 : minArea;
      } else if (overlap === minOverlap) {
        if (area2 < minArea) {
          minArea = area2;
          index = i;
        }
      }
    }
    return index || M - m;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(node, m, M) {
    const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
    const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
    const xMargin = this._allDistMargin(node, m, M, compareMinX);
    const yMargin = this._allDistMargin(node, m, M, compareMinY);
    if (xMargin < yMargin) node.children.sort(compareMinX);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(node, m, M, compare2) {
    node.children.sort(compare2);
    const toBBox = this.toBBox;
    const leftBBox = distBBox(node, 0, m, toBBox);
    const rightBBox = distBBox(node, M - m, M, toBBox);
    let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
    for (let i = m; i < M - m; i++) {
      const child = node.children[i];
      extend(leftBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(leftBBox);
    }
    for (let i = M - m - 1; i >= m; i--) {
      const child = node.children[i];
      extend(rightBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(rightBBox);
    }
    return margin;
  }
  _adjustParentBBoxes(bbox2, path, level) {
    for (let i = level; i >= 0; i--) {
      extend(path[i], bbox2);
    }
  }
  _condense(path) {
    for (let i = path.length - 1, siblings; i >= 0; i--) {
      if (path[i].children.length === 0) {
        if (i > 0) {
          siblings = path[i - 1].children;
          siblings.splice(siblings.indexOf(path[i]), 1);
        } else this.clear();
      } else calcBBox(path[i], this.toBBox);
    }
  }
}
function findItem(item, items, equalsFn) {
  if (!equalsFn) return items.indexOf(item);
  for (let i = 0; i < items.length; i++) {
    if (equalsFn(item, items[i])) return i;
  }
  return -1;
}
function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
}
function distBBox(node, k, p, toBBox, destNode) {
  if (!destNode) destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (let i = k; i < p; i++) {
    const child = node.children[i];
    extend(destNode, node.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend(a, b) {
  a.minX = Math.min(a.minX, b.minX);
  a.minY = Math.min(a.minY, b.minY);
  a.maxX = Math.max(a.maxX, b.maxX);
  a.maxY = Math.max(a.maxY, b.maxY);
  return a;
}
function compareNodeMinX(a, b) {
  return a.minX - b.minX;
}
function compareNodeMinY(a, b) {
  return a.minY - b.minY;
}
function bboxArea(a) {
  return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function bboxMargin(a) {
  return a.maxX - a.minX + (a.maxY - a.minY);
}
function enlargedArea(a, b) {
  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}
function intersectionArea(a, b) {
  const minX = Math.max(a.minX, b.minX);
  const minY = Math.max(a.minY, b.minY);
  const maxX = Math.min(a.maxX, b.maxX);
  const maxY = Math.min(a.maxY, b.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains(a, b) {
  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
}
function intersects(a, b) {
  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n, compare2) {
  const stack = [left, right];
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n) continue;
    const mid = left + Math.ceil((right - left) / n / 2) * n;
    quickselect(arr, mid, left, right, compare2);
    stack.push(left, mid, mid, right);
  }
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
function booleanWithin(feature1, feature2) {
  var geom1 = getGeom(feature1);
  var geom2 = getGeom(feature2);
  var type1 = geom1.type;
  var type2 = geom2.type;
  switch (type1) {
    case "Point":
      switch (type2) {
        case "MultiPoint":
          return isPointInMultiPoint(geom1, geom2);
        case "LineString":
          return booleanPointOnLine(geom1, geom2, { ignoreEndVertices: true });
        case "Polygon":
        case "MultiPolygon":
          return booleanPointInPolygon(geom1, geom2, { ignoreBoundary: true });
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "MultiPoint":
      switch (type2) {
        case "MultiPoint":
          return isMultiPointInMultiPoint(geom1, geom2);
        case "LineString":
          return isMultiPointOnLine(geom1, geom2);
        case "Polygon":
        case "MultiPolygon":
          return isMultiPointInPoly(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "LineString":
      switch (type2) {
        case "LineString":
          return isLineOnLine(geom1, geom2);
        case "Polygon":
        case "MultiPolygon":
          return isLineInPoly(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "Polygon":
      switch (type2) {
        case "Polygon":
        case "MultiPolygon":
          return isPolyInPoly(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + type1 + " geometry not supported");
  }
}
function isPointInMultiPoint(point2, multiPoint) {
  var i;
  var output = false;
  for (i = 0; i < multiPoint.coordinates.length; i++) {
    if (compareCoords(multiPoint.coordinates[i], point2.coordinates)) {
      output = true;
      break;
    }
  }
  return output;
}
function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {
  for (var i = 0; i < multiPoint1.coordinates.length; i++) {
    var anyMatch = false;
    for (var i2 = 0; i2 < multiPoint2.coordinates.length; i2++) {
      if (compareCoords(multiPoint1.coordinates[i], multiPoint2.coordinates[i2])) {
        anyMatch = true;
      }
    }
    if (!anyMatch) {
      return false;
    }
  }
  return true;
}
function isMultiPointOnLine(multiPoint, lineString2) {
  var foundInsidePoint = false;
  for (var i = 0; i < multiPoint.coordinates.length; i++) {
    if (!booleanPointOnLine(multiPoint.coordinates[i], lineString2)) {
      return false;
    }
    if (!foundInsidePoint) {
      foundInsidePoint = booleanPointOnLine(
        multiPoint.coordinates[i],
        lineString2,
        { ignoreEndVertices: true }
      );
    }
  }
  return foundInsidePoint;
}
function isMultiPointInPoly(multiPoint, polygon2) {
  var output = true;
  var isInside = false;
  for (var i = 0; i < multiPoint.coordinates.length; i++) {
    isInside = booleanPointInPolygon(multiPoint.coordinates[i], polygon2);
    if (!isInside) {
      output = false;
      break;
    }
    {
      isInside = booleanPointInPolygon(multiPoint.coordinates[i], polygon2, {
        ignoreBoundary: true
      });
    }
  }
  return output && isInside;
}
function isLineOnLine(lineString1, lineString2) {
  for (var i = 0; i < lineString1.coordinates.length; i++) {
    if (!booleanPointOnLine(lineString1.coordinates[i], lineString2)) {
      return false;
    }
  }
  return true;
}
function isLineInPoly(linestring, polygon2) {
  var polyBbox = bbox(polygon2);
  var lineBbox = bbox(linestring);
  if (!doBBoxOverlap(polyBbox, lineBbox)) {
    return false;
  }
  var foundInsidePoint = false;
  for (var i = 0; i < linestring.coordinates.length; i++) {
    if (!booleanPointInPolygon(linestring.coordinates[i], polygon2)) {
      return false;
    }
    if (!foundInsidePoint) {
      foundInsidePoint = booleanPointInPolygon(
        linestring.coordinates[i],
        polygon2,
        { ignoreBoundary: true }
      );
    }
    if (!foundInsidePoint && i < linestring.coordinates.length - 1) {
      var midpoint2 = getMidpoint(
        linestring.coordinates[i],
        linestring.coordinates[i + 1]
      );
      foundInsidePoint = booleanPointInPolygon(midpoint2, polygon2, {
        ignoreBoundary: true
      });
    }
  }
  return foundInsidePoint;
}
function isPolyInPoly(geometry1, geometry2) {
  var poly1Bbox = bbox(geometry1);
  var poly2Bbox = bbox(geometry2);
  if (!doBBoxOverlap(poly2Bbox, poly1Bbox)) {
    return false;
  }
  for (var i = 0; i < geometry1.coordinates[0].length; i++) {
    if (!booleanPointInPolygon(geometry1.coordinates[0][i], geometry2)) {
      return false;
    }
  }
  return true;
}
function doBBoxOverlap(bbox1, bbox2) {
  if (bbox1[0] > bbox2[0]) return false;
  if (bbox1[2] < bbox2[2]) return false;
  if (bbox1[1] > bbox2[1]) return false;
  if (bbox1[3] < bbox2[3]) return false;
  return true;
}
function compareCoords(pair1, pair2) {
  return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
function getMidpoint(pair1, pair2) {
  return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];
}
function center(geojson, options = {}) {
  const ext = bbox(geojson);
  const x = (ext[0] + ext[2]) / 2;
  const y = (ext[1] + ext[3]) / 2;
  return point([x, y], options.properties, options);
}
var jsts_min$1 = { exports: {} };
var jsts_min = jsts_min$1.exports;
var hasRequiredJsts_min;
function requireJsts_min() {
  if (hasRequiredJsts_min) return jsts_min$1.exports;
  hasRequiredJsts_min = 1;
  (function(module, exports) {
    !function(t, e) {
      module.exports = e();
    }(jsts_min, function() {
      function t(t2, e2) {
        (null == e2 || e2 > t2.length) && (e2 = t2.length);
        for (var n2 = 0, i2 = Array(e2); n2 < e2; n2++) i2[n2] = t2[n2];
        return i2;
      }
      function e(t2, e2, n2) {
        return e2 = u2(e2), function(t3, e3) {
          if (e3 && ("object" == typeof e3 || "function" == typeof e3)) return e3;
          if (void 0 !== e3) throw new TypeError("Derived constructors may only return object or undefined");
          return function(t4) {
            if (void 0 === t4) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t4;
          }(t3);
        }(t2, h() ? Reflect.construct(e2, n2 || [], u2(t2).constructor) : e2.apply(t2, n2));
      }
      function n(t2, e2) {
        if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
      }
      function i(t2, e2, n2) {
        if (h()) return Reflect.construct.apply(null, arguments);
        var i2 = [null];
        i2.push.apply(i2, e2);
        var r2 = new (t2.bind.apply(t2, i2))();
        return n2 && c(r2, n2.prototype), r2;
      }
      function r(t2, e2) {
        for (var n2 = 0; n2 < e2.length; n2++) {
          var i2 = e2[n2];
          i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(t2, v(i2.key), i2);
        }
      }
      function s(t2, e2, n2) {
        return e2 && r(t2.prototype, e2), n2 && r(t2, n2), Object.defineProperty(t2, "prototype", { writable: false }), t2;
      }
      function a(t2, e2) {
        var n2 = "undefined" != typeof Symbol && t2[Symbol.iterator] || t2["@@iterator"];
        if (!n2) {
          if (Array.isArray(t2) || (n2 = y(t2)) || e2) {
            n2 && (t2 = n2);
            var i2 = 0, r2 = function() {
            };
            return { s: r2, n: function() {
              return i2 >= t2.length ? { done: true } : { done: false, value: t2[i2++] };
            }, e: function(t3) {
              throw t3;
            }, f: r2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var s2, a2 = true, o2 = false;
        return { s: function() {
          n2 = n2.call(t2);
        }, n: function() {
          var t3 = n2.next();
          return a2 = t3.done, t3;
        }, e: function(t3) {
          o2 = true, s2 = t3;
        }, f: function() {
          try {
            a2 || null == n2.return || n2.return();
          } finally {
            if (o2) throw s2;
          }
        } };
      }
      function o() {
        return o = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t2, e2, n2) {
          var i2 = function(t3, e3) {
            for (; !{}.hasOwnProperty.call(t3, e3) && null !== (t3 = u2(t3)); ) ;
            return t3;
          }(t2, e2);
          if (i2) {
            var r2 = Object.getOwnPropertyDescriptor(i2, e2);
            return r2.get ? r2.get.call(arguments.length < 3 ? t2 : n2) : r2.value;
          }
        }, o.apply(null, arguments);
      }
      function u2(t2) {
        return u2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        }, u2(t2);
      }
      function l(t2, e2) {
        if ("function" != typeof e2 && null !== e2) throw new TypeError("Super expression must either be null or a function");
        t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), Object.defineProperty(t2, "prototype", { writable: false }), e2 && c(t2, e2);
      }
      function h() {
        try {
          var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t3) {
        }
        return (h = function() {
          return !!t2;
        })();
      }
      function c(t2, e2) {
        return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
          return t3.__proto__ = e3, t3;
        }, c(t2, e2);
      }
      function f(t2, e2, n2, i2) {
        var r2 = o(u2(1 & i2 ? t2.prototype : t2), e2, n2);
        return 2 & i2 && "function" == typeof r2 ? function(t3) {
          return r2.apply(n2, t3);
        } : r2;
      }
      function g(e2) {
        return function(e3) {
          if (Array.isArray(e3)) return t(e3);
        }(e2) || function(t2) {
          if ("undefined" != typeof Symbol && null != t2[Symbol.iterator] || null != t2["@@iterator"]) return Array.from(t2);
        }(e2) || y(e2) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function v(t2) {
        var e2 = function(t3, e3) {
          if ("object" != typeof t3 || !t3) return t3;
          var n2 = t3[Symbol.toPrimitive];
          if (void 0 !== n2) {
            var i2 = n2.call(t3, e3);
            if ("object" != typeof i2) return i2;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t3);
        }(t2, "string");
        return "symbol" == typeof e2 ? e2 : e2 + "";
      }
      function y(e2, n2) {
        if (e2) {
          if ("string" == typeof e2) return t(e2, n2);
          var i2 = {}.toString.call(e2).slice(8, -1);
          return "Object" === i2 && e2.constructor && (i2 = e2.constructor.name), "Map" === i2 || "Set" === i2 ? Array.from(e2) : "Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2) ? t(e2, n2) : void 0;
        }
      }
      function d(t2) {
        var e2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
        return d = function(t3) {
          if (null === t3 || !function(t4) {
            try {
              return -1 !== Function.toString.call(t4).indexOf("[native code]");
            } catch (e3) {
              return "function" == typeof t4;
            }
          }(t3)) return t3;
          if ("function" != typeof t3) throw new TypeError("Super expression must either be null or a function");
          if (void 0 !== e2) {
            if (e2.has(t3)) return e2.get(t3);
            e2.set(t3, n2);
          }
          function n2() {
            return i(t3, arguments, u2(this).constructor);
          }
          return n2.prototype = Object.create(t3.prototype, { constructor: { value: n2, enumerable: false, writable: true, configurable: true } }), c(n2, t3);
        }, d(t2);
      }
      var _ = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "getEndCapStyle", value: function() {
          return this._endCapStyle;
        } }, { key: "isSingleSided", value: function() {
          return this._isSingleSided;
        } }, { key: "setQuadrantSegments", value: function(e2) {
          this._quadrantSegments = e2, 0 === this._quadrantSegments && (this._joinStyle = t2.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = t2.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), e2 <= 0 && (this._quadrantSegments = 1), this._joinStyle !== t2.JOIN_ROUND && (this._quadrantSegments = t2.DEFAULT_QUADRANT_SEGMENTS);
        } }, { key: "getJoinStyle", value: function() {
          return this._joinStyle;
        } }, { key: "setJoinStyle", value: function(t3) {
          this._joinStyle = t3;
        } }, { key: "setSimplifyFactor", value: function(t3) {
          this._simplifyFactor = t3 < 0 ? 0 : t3;
        } }, { key: "getSimplifyFactor", value: function() {
          return this._simplifyFactor;
        } }, { key: "getQuadrantSegments", value: function() {
          return this._quadrantSegments;
        } }, { key: "setEndCapStyle", value: function(t3) {
          this._endCapStyle = t3;
        } }, { key: "getMitreLimit", value: function() {
          return this._mitreLimit;
        } }, { key: "setMitreLimit", value: function(t3) {
          this._mitreLimit = t3;
        } }, { key: "setSingleSided", value: function(t3) {
          this._isSingleSided = t3;
        } }], [{ key: "constructor_", value: function() {
          if (this._quadrantSegments = t2.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = t2.CAP_ROUND, this._joinStyle = t2.JOIN_ROUND, this._mitreLimit = t2.DEFAULT_MITRE_LIMIT, this._isSingleSided = false, this._simplifyFactor = t2.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length) ;
          else if (1 === arguments.length) {
            var e2 = arguments[0];
            this.setQuadrantSegments(e2);
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this.setQuadrantSegments(n2), this.setEndCapStyle(i2);
          } else if (4 === arguments.length) {
            var r2 = arguments[0], s2 = arguments[1], a2 = arguments[2], o2 = arguments[3];
            this.setQuadrantSegments(r2), this.setEndCapStyle(s2), this.setJoinStyle(a2), this.setMitreLimit(o2);
          }
        } }, { key: "bufferDistanceError", value: function(t3) {
          var e2 = Math.PI / 2 / t3;
          return 1 - Math.cos(e2 / 2);
        } }]);
      }();
      _.CAP_ROUND = 1, _.CAP_FLAT = 2, _.CAP_SQUARE = 3, _.JOIN_ROUND = 1, _.JOIN_MITRE = 2, _.JOIN_BEVEL = 3, _.DEFAULT_QUADRANT_SEGMENTS = 8, _.DEFAULT_MITRE_LIMIT = 5, _.DEFAULT_SIMPLIFY_FACTOR = 0.01;
      var p = function(t2) {
        function i2(t3) {
          var r2;
          return n(this, i2), (r2 = e(this, i2, [t3])).name = Object.keys({ Exception: i2 })[0], r2;
        }
        return l(i2, t2), s(i2, [{ key: "toString", value: function() {
          return this.message;
        } }]);
      }(d(Error)), m = function(t2) {
        function i2(t3) {
          var r2;
          return n(this, i2), (r2 = e(this, i2, [t3])).name = Object.keys({ IllegalArgumentException: i2 })[0], r2;
        }
        return l(i2, t2), s(i2);
      }(p), k = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "filter", value: function(t2) {
        } }]);
      }();
      function x() {
      }
      function I() {
      }
      function E() {
      }
      var N, T, S, L2, C, R, w, O, b = function() {
        return s(function t2() {
          n(this, t2);
        }, null, [{ key: "equalsWithTolerance", value: function(t2, e2, n2) {
          return Math.abs(t2 - e2) <= n2;
        } }]);
      }(), M = function() {
        return s(function t2(e2, i2) {
          n(this, t2), this.low = i2 || 0, this.high = e2 || 0;
        }, null, [{ key: "toBinaryString", value: function(t2) {
          var e2, n2 = "";
          for (e2 = 2147483648; e2 > 0; e2 >>>= 1) n2 += (t2.high & e2) === e2 ? "1" : "0";
          for (e2 = 2147483648; e2 > 0; e2 >>>= 1) n2 += (t2.low & e2) === e2 ? "1" : "0";
          return n2;
        } }]);
      }();
      function A() {
      }
      function P() {
      }
      A.NaN = NaN, A.isNaN = function(t2) {
        return Number.isNaN(t2);
      }, A.isInfinite = function(t2) {
        return !Number.isFinite(t2);
      }, A.MAX_VALUE = Number.MAX_VALUE, A.POSITIVE_INFINITY = Number.POSITIVE_INFINITY, A.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, "function" == typeof Float64Array && "function" == typeof Int32Array ? (R = 2146435072, w = new Float64Array(1), O = new Int32Array(w.buffer), A.doubleToLongBits = function(t2) {
        w[0] = t2;
        var e2 = 0 | O[0], n2 = 0 | O[1];
        return (n2 & R) === R && 1048575 & n2 && 0 !== e2 && (e2 = 0, n2 = 2146959360), new M(n2, e2);
      }, A.longBitsToDouble = function(t2) {
        return O[0] = t2.low, O[1] = t2.high, w[0];
      }) : (N = 1023, T = Math.log2, S = Math.floor, L2 = Math.pow, C = function() {
        for (var t2 = 53; t2 > 0; t2--) {
          var e2 = L2(2, t2) - 1;
          if (S(T(e2)) + 1 === t2) return e2;
        }
        return 0;
      }(), A.doubleToLongBits = function(t2) {
        var e2, n2, i2, r2, s2, a2, o2, u3, l2;
        if (t2 < 0 || 1 / t2 === Number.NEGATIVE_INFINITY ? (a2 = 1 << 31, t2 = -t2) : a2 = 0, 0 === t2) return new M(u3 = a2, l2 = 0);
        if (t2 === 1 / 0) return new M(u3 = 2146435072 | a2, l2 = 0);
        if (t2 != t2) return new M(u3 = 2146959360, l2 = 0);
        if (r2 = 0, l2 = 0, (e2 = S(t2)) > 1) if (e2 <= C) (r2 = S(T(e2))) <= 20 ? (l2 = 0, u3 = e2 << 20 - r2 & 1048575) : (l2 = e2 % (n2 = L2(2, i2 = r2 - 20)) << 32 - i2, u3 = e2 / n2 & 1048575);
        else for (i2 = e2, l2 = 0; 0 !== (i2 = S(n2 = i2 / 2)); ) r2++, l2 >>>= 1, l2 |= (1 & u3) << 31, u3 >>>= 1, n2 !== i2 && (u3 |= 524288);
        if (o2 = r2 + N, s2 = 0 === e2, e2 = t2 - e2, r2 < 52 && 0 !== e2) for (i2 = 0; ; ) {
          if ((n2 = 2 * e2) >= 1 ? (e2 = n2 - 1, s2 ? (o2--, s2 = false) : (i2 <<= 1, i2 |= 1, r2++)) : (e2 = n2, s2 ? 0 == --o2 && (r2++, s2 = false) : (i2 <<= 1, r2++)), 20 === r2) u3 |= i2, i2 = 0;
          else if (52 === r2) {
            l2 |= i2;
            break;
          }
          if (1 === n2) {
            r2 < 20 ? u3 |= i2 << 20 - r2 : r2 < 52 && (l2 |= i2 << 52 - r2);
            break;
          }
        }
        return u3 |= o2 << 20, new M(u3 |= a2, l2);
      }, A.longBitsToDouble = function(t2) {
        var e2, n2, i2, r2, s2 = t2.high, a2 = t2.low, o2 = s2 & 1 << 31 ? -1 : 1;
        for (i2 = ((2146435072 & s2) >> 20) - N, r2 = 0, n2 = 1 << 19, e2 = 1; e2 <= 20; e2++) s2 & n2 && (r2 += L2(2, -e2)), n2 >>>= 1;
        for (n2 = 1 << 31, e2 = 21; e2 <= 52; e2++) a2 & n2 && (r2 += L2(2, -e2)), n2 >>>= 1;
        if (-1023 === i2) {
          if (0 === r2) return 0 * o2;
          i2 = -1022;
        } else {
          if (1024 === i2) return 0 === r2 ? o2 / 0 : NaN;
          r2 += 1;
        }
        return o2 * r2 * L2(2, i2);
      });
      var D2 = function(t2) {
        function i2(t3) {
          var r2;
          return n(this, i2), (r2 = e(this, i2, [t3])).name = Object.keys({ RuntimeException: i2 })[0], r2;
        }
        return l(i2, t2), s(i2);
      }(p), F = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, null, [{ key: "constructor_", value: function() {
          if (0 === arguments.length) D2.constructor_.call(this);
          else if (1 === arguments.length) {
            var t3 = arguments[0];
            D2.constructor_.call(this, t3);
          }
        } }]);
      }(D2), G = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "shouldNeverReachHere", value: function() {
          if (0 === arguments.length) t2.shouldNeverReachHere(null);
          else if (1 === arguments.length) {
            var e2 = arguments[0];
            throw new F("Should never reach here" + (null !== e2 ? ": " + e2 : ""));
          }
        } }, { key: "isTrue", value: function() {
          if (1 === arguments.length) {
            var e2 = arguments[0];
            t2.isTrue(e2, null);
          } else if (2 === arguments.length) {
            var n2 = arguments[1];
            if (!arguments[0]) throw null === n2 ? new F() : new F(n2);
          }
        } }, { key: "equals", value: function() {
          if (2 === arguments.length) {
            var e2 = arguments[0], n2 = arguments[1];
            t2.equals(e2, n2, null);
          } else if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], s2 = arguments[2];
            if (!r2.equals(i2)) throw new F("Expected " + i2 + " but encountered " + r2 + (null !== s2 ? ": " + s2 : ""));
          }
        } }]);
      }(), q = new ArrayBuffer(8), Y = new Float64Array(q), z = new Int32Array(q), X = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "getM", value: function() {
          return A.NaN;
        } }, { key: "setOrdinate", value: function(e2, n2) {
          switch (e2) {
            case t2.X:
              this.x = n2;
              break;
            case t2.Y:
              this.y = n2;
              break;
            case t2.Z:
              this.setZ(n2);
              break;
            default:
              throw new m("Invalid ordinate index: " + e2);
          }
        } }, { key: "equals2D", value: function() {
          if (1 === arguments.length) {
            var t3 = arguments[0];
            return this.x === t3.x && this.y === t3.y;
          }
          if (2 === arguments.length) {
            var e2 = arguments[0], n2 = arguments[1];
            return !!b.equalsWithTolerance(this.x, e2.x, n2) && !!b.equalsWithTolerance(this.y, e2.y, n2);
          }
        } }, { key: "setM", value: function(e2) {
          throw new m("Invalid ordinate index: " + t2.M);
        } }, { key: "getZ", value: function() {
          return this.z;
        } }, { key: "getOrdinate", value: function(e2) {
          switch (e2) {
            case t2.X:
              return this.x;
            case t2.Y:
              return this.y;
            case t2.Z:
              return this.getZ();
          }
          throw new m("Invalid ordinate index: " + e2);
        } }, { key: "equals3D", value: function(t3) {
          return this.x === t3.x && this.y === t3.y && (this.getZ() === t3.getZ() || A.isNaN(this.getZ()) && A.isNaN(t3.getZ()));
        } }, { key: "equals", value: function(e2) {
          return e2 instanceof t2 && this.equals2D(e2);
        } }, { key: "equalInZ", value: function(t3, e2) {
          return b.equalsWithTolerance(this.getZ(), t3.getZ(), e2);
        } }, { key: "setX", value: function(t3) {
          this.x = t3;
        } }, { key: "compareTo", value: function(t3) {
          var e2 = t3;
          return this.x < e2.x ? -1 : this.x > e2.x ? 1 : this.y < e2.y ? -1 : this.y > e2.y ? 1 : 0;
        } }, { key: "getX", value: function() {
          return this.x;
        } }, { key: "setZ", value: function(t3) {
          this.z = t3;
        } }, { key: "clone", value: function() {
          try {
            return null;
          } catch (t3) {
            if (t3 instanceof CloneNotSupportedException) return G.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null;
            throw t3;
          }
        } }, { key: "copy", value: function() {
          return new t2(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + ", " + this.getZ() + ")";
        } }, { key: "distance3D", value: function(t3) {
          var e2 = this.x - t3.x, n2 = this.y - t3.y, i2 = this.getZ() - t3.getZ();
          return Math.sqrt(e2 * e2 + n2 * n2 + i2 * i2);
        } }, { key: "getY", value: function() {
          return this.y;
        } }, { key: "setY", value: function(t3) {
          this.y = t3;
        } }, { key: "distance", value: function(t3) {
          var e2 = this.x - t3.x, n2 = this.y - t3.y;
          return Math.sqrt(e2 * e2 + n2 * n2);
        } }, { key: "hashCode", value: function() {
          var e2 = 17;
          return e2 = 37 * (e2 = 37 * e2 + t2.hashCode(this.x)) + t2.hashCode(this.y);
        } }, { key: "setCoordinate", value: function(t3) {
          this.x = t3.x, this.y = t3.y, this.z = t3.getZ();
        } }, { key: "interfaces_", get: function() {
          return [x, I, E];
        } }], [{ key: "constructor_", value: function() {
          if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) t2.constructor_.call(this, 0, 0);
          else if (1 === arguments.length) {
            var e2 = arguments[0];
            t2.constructor_.call(this, e2.x, e2.y, e2.getZ());
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            t2.constructor_.call(this, n2, i2, t2.NULL_ORDINATE);
          } else if (3 === arguments.length) {
            var r2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
            this.x = r2, this.y = s2, this.z = a2;
          }
        } }, { key: "hashCode", value: function(t3) {
          return Y[0] = t3, z[0] ^ z[1];
        } }]);
      }(), B2 = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "compare", value: function(e2, n2) {
          var i2 = t2.compare(e2.x, n2.x);
          if (0 !== i2) return i2;
          var r2 = t2.compare(e2.y, n2.y);
          return 0 !== r2 ? r2 : this._dimensionsToTest <= 2 ? 0 : t2.compare(e2.getZ(), n2.getZ());
        } }, { key: "interfaces_", get: function() {
          return [P];
        } }], [{ key: "constructor_", value: function() {
          if (this._dimensionsToTest = 2, 0 === arguments.length) t2.constructor_.call(this, 2);
          else if (1 === arguments.length) {
            var e2 = arguments[0];
            if (2 !== e2 && 3 !== e2) throw new m("only 2 or 3 dimensions may be specified");
            this._dimensionsToTest = e2;
          }
        } }, { key: "compare", value: function(t3, e2) {
          return t3 < e2 ? -1 : t3 > e2 ? 1 : A.isNaN(t3) ? A.isNaN(e2) ? 0 : -1 : A.isNaN(e2) ? 1 : 0;
        } }]);
      }();
      X.DimensionalComparator = B2, X.NULL_ORDINATE = A.NaN, X.X = 0, X.Y = 1, X.Z = 2, X.M = 3;
      var U = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "getArea", value: function() {
          return this.getWidth() * this.getHeight();
        } }, { key: "equals", value: function(e2) {
          if (!(e2 instanceof t2)) return false;
          var n2 = e2;
          return this.isNull() ? n2.isNull() : this._maxx === n2.getMaxX() && this._maxy === n2.getMaxY() && this._minx === n2.getMinX() && this._miny === n2.getMinY();
        } }, { key: "intersection", value: function(e2) {
          if (this.isNull() || e2.isNull() || !this.intersects(e2)) return new t2();
          var n2 = this._minx > e2._minx ? this._minx : e2._minx, i2 = this._miny > e2._miny ? this._miny : e2._miny;
          return new t2(n2, this._maxx < e2._maxx ? this._maxx : e2._maxx, i2, this._maxy < e2._maxy ? this._maxy : e2._maxy);
        } }, { key: "isNull", value: function() {
          return this._maxx < this._minx;
        } }, { key: "getMaxX", value: function() {
          return this._maxx;
        } }, { key: "covers", value: function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof X) {
              var e2 = arguments[0];
              return this.covers(e2.x, e2.y);
            }
            if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              return !this.isNull() && !n2.isNull() && (n2.getMinX() >= this._minx && n2.getMaxX() <= this._maxx && n2.getMinY() >= this._miny && n2.getMaxY() <= this._maxy);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            return !this.isNull() && (i2 >= this._minx && i2 <= this._maxx && r2 >= this._miny && r2 <= this._maxy);
          }
        } }, { key: "intersects", value: function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof t2) {
              var e2 = arguments[0];
              return !this.isNull() && !e2.isNull() && !(e2._minx > this._maxx || e2._maxx < this._minx || e2._miny > this._maxy || e2._maxy < this._miny);
            }
            if (arguments[0] instanceof X) {
              var n2 = arguments[0];
              return this.intersects(n2.x, n2.y);
            }
          } else if (2 === arguments.length) {
            if (arguments[0] instanceof X && arguments[1] instanceof X) {
              var i2 = arguments[0], r2 = arguments[1];
              return !this.isNull() && (!((i2.x < r2.x ? i2.x : r2.x) > this._maxx) && (!((i2.x > r2.x ? i2.x : r2.x) < this._minx) && (!((i2.y < r2.y ? i2.y : r2.y) > this._maxy) && !((i2.y > r2.y ? i2.y : r2.y) < this._miny))));
            }
            if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
              var s2 = arguments[0], a2 = arguments[1];
              return !this.isNull() && !(s2 > this._maxx || s2 < this._minx || a2 > this._maxy || a2 < this._miny);
            }
          }
        } }, { key: "getMinY", value: function() {
          return this._miny;
        } }, { key: "getDiameter", value: function() {
          if (this.isNull()) return 0;
          var t3 = this.getWidth(), e2 = this.getHeight();
          return Math.sqrt(t3 * t3 + e2 * e2);
        } }, { key: "getMinX", value: function() {
          return this._minx;
        } }, { key: "expandToInclude", value: function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof X) {
              var e2 = arguments[0];
              this.expandToInclude(e2.x, e2.y);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              if (n2.isNull()) return null;
              this.isNull() ? (this._minx = n2.getMinX(), this._maxx = n2.getMaxX(), this._miny = n2.getMinY(), this._maxy = n2.getMaxY()) : (n2._minx < this._minx && (this._minx = n2._minx), n2._maxx > this._maxx && (this._maxx = n2._maxx), n2._miny < this._miny && (this._miny = n2._miny), n2._maxy > this._maxy && (this._maxy = n2._maxy));
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this.isNull() ? (this._minx = i2, this._maxx = i2, this._miny = r2, this._maxy = r2) : (i2 < this._minx && (this._minx = i2), i2 > this._maxx && (this._maxx = i2), r2 < this._miny && (this._miny = r2), r2 > this._maxy && (this._maxy = r2));
          }
        } }, { key: "minExtent", value: function() {
          if (this.isNull()) return 0;
          var t3 = this.getWidth(), e2 = this.getHeight();
          return t3 < e2 ? t3 : e2;
        } }, { key: "getWidth", value: function() {
          return this.isNull() ? 0 : this._maxx - this._minx;
        } }, { key: "compareTo", value: function(t3) {
          var e2 = t3;
          return this.isNull() ? e2.isNull() ? 0 : -1 : e2.isNull() ? 1 : this._minx < e2._minx ? -1 : this._minx > e2._minx ? 1 : this._miny < e2._miny ? -1 : this._miny > e2._miny ? 1 : this._maxx < e2._maxx ? -1 : this._maxx > e2._maxx ? 1 : this._maxy < e2._maxy ? -1 : this._maxy > e2._maxy ? 1 : 0;
        } }, { key: "translate", value: function(t3, e2) {
          if (this.isNull()) return null;
          this.init(this.getMinX() + t3, this.getMaxX() + t3, this.getMinY() + e2, this.getMaxY() + e2);
        } }, { key: "copy", value: function() {
          return new t2(this);
        } }, { key: "toString", value: function() {
          return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
        } }, { key: "setToNull", value: function() {
          this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
        } }, { key: "disjoint", value: function(t3) {
          return !(!this.isNull() && !t3.isNull()) || (t3._minx > this._maxx || t3._maxx < this._minx || t3._miny > this._maxy || t3._maxy < this._miny);
        } }, { key: "getHeight", value: function() {
          return this.isNull() ? 0 : this._maxy - this._miny;
        } }, { key: "maxExtent", value: function() {
          if (this.isNull()) return 0;
          var t3 = this.getWidth(), e2 = this.getHeight();
          return t3 > e2 ? t3 : e2;
        } }, { key: "expandBy", value: function() {
          if (1 === arguments.length) {
            var t3 = arguments[0];
            this.expandBy(t3, t3);
          } else if (2 === arguments.length) {
            var e2 = arguments[0], n2 = arguments[1];
            if (this.isNull()) return null;
            this._minx -= e2, this._maxx += e2, this._miny -= n2, this._maxy += n2, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
          }
        } }, { key: "contains", value: function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof t2) {
              var e2 = arguments[0];
              return this.covers(e2);
            }
            if (arguments[0] instanceof X) {
              var n2 = arguments[0];
              return this.covers(n2);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            return this.covers(i2, r2);
          }
        } }, { key: "centre", value: function() {
          return this.isNull() ? null : new X((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
        } }, { key: "init", value: function() {
          if (0 === arguments.length) this.setToNull();
          else if (1 === arguments.length) {
            if (arguments[0] instanceof X) {
              var e2 = arguments[0];
              this.init(e2.x, e2.x, e2.y, e2.y);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this._minx = n2._minx, this._maxx = n2._maxx, this._miny = n2._miny, this._maxy = n2._maxy;
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this.init(i2.x, r2.x, i2.y, r2.y);
          } else if (4 === arguments.length) {
            var s2 = arguments[0], a2 = arguments[1], o2 = arguments[2], u3 = arguments[3];
            s2 < a2 ? (this._minx = s2, this._maxx = a2) : (this._minx = a2, this._maxx = s2), o2 < u3 ? (this._miny = o2, this._maxy = u3) : (this._miny = u3, this._maxy = o2);
          }
        } }, { key: "getMaxY", value: function() {
          return this._maxy;
        } }, { key: "distance", value: function(t3) {
          if (this.intersects(t3)) return 0;
          var e2 = 0;
          this._maxx < t3._minx ? e2 = t3._minx - this._maxx : this._minx > t3._maxx && (e2 = this._minx - t3._maxx);
          var n2 = 0;
          return this._maxy < t3._miny ? n2 = t3._miny - this._maxy : this._miny > t3._maxy && (n2 = this._miny - t3._maxy), 0 === e2 ? n2 : 0 === n2 ? e2 : Math.sqrt(e2 * e2 + n2 * n2);
        } }, { key: "hashCode", value: function() {
          var t3 = 17;
          return t3 = 37 * (t3 = 37 * (t3 = 37 * (t3 = 37 * t3 + X.hashCode(this._minx)) + X.hashCode(this._maxx)) + X.hashCode(this._miny)) + X.hashCode(this._maxy);
        } }, { key: "interfaces_", get: function() {
          return [x, E];
        } }], [{ key: "constructor_", value: function() {
          if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length) this.init();
          else if (1 === arguments.length) {
            if (arguments[0] instanceof X) {
              var e2 = arguments[0];
              this.init(e2.x, e2.x, e2.y, e2.y);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this.init(n2);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this.init(i2.x, r2.x, i2.y, r2.y);
          } else if (4 === arguments.length) {
            var s2 = arguments[0], a2 = arguments[1], o2 = arguments[2], u3 = arguments[3];
            this.init(s2, a2, o2, u3);
          }
        } }, { key: "intersects", value: function() {
          if (3 === arguments.length) {
            var t3 = arguments[0], e2 = arguments[1], n2 = arguments[2];
            return n2.x >= (t3.x < e2.x ? t3.x : e2.x) && n2.x <= (t3.x > e2.x ? t3.x : e2.x) && n2.y >= (t3.y < e2.y ? t3.y : e2.y) && n2.y <= (t3.y > e2.y ? t3.y : e2.y);
          }
          if (4 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], s2 = arguments[2], a2 = arguments[3], o2 = Math.min(s2.x, a2.x), u3 = Math.max(s2.x, a2.x), l2 = Math.min(i2.x, r2.x), h2 = Math.max(i2.x, r2.x);
            return !(l2 > u3) && (!(h2 < o2) && (o2 = Math.min(s2.y, a2.y), u3 = Math.max(s2.y, a2.y), l2 = Math.min(i2.y, r2.y), h2 = Math.max(i2.y, r2.y), !(l2 > u3) && !(h2 < o2)));
          }
        } }]);
      }(), V = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "isGeometryCollection", value: function() {
          return this.getTypeCode() === t2.TYPECODE_GEOMETRYCOLLECTION;
        } }, { key: "getFactory", value: function() {
          return this._factory;
        } }, { key: "getGeometryN", value: function(t3) {
          return this;
        } }, { key: "getArea", value: function() {
          return 0;
        } }, { key: "isRectangle", value: function() {
          return false;
        } }, { key: "equalsExact", value: function(t3) {
          return this === t3 || this.equalsExact(t3, 0);
        } }, { key: "geometryChanged", value: function() {
          this.apply(t2.geometryChangedFilter);
        } }, { key: "geometryChangedAction", value: function() {
          this._envelope = null;
        } }, { key: "equalsNorm", value: function(t3) {
          return null !== t3 && this.norm().equalsExact(t3.norm());
        } }, { key: "getLength", value: function() {
          return 0;
        } }, { key: "getNumGeometries", value: function() {
          return 1;
        } }, { key: "compareTo", value: function() {
          var t3;
          if (1 === arguments.length) {
            var e2 = arguments[0];
            return t3 = e2, this.getTypeCode() !== t3.getTypeCode() ? this.getTypeCode() - t3.getTypeCode() : this.isEmpty() && t3.isEmpty() ? 0 : this.isEmpty() ? -1 : t3.isEmpty() ? 1 : this.compareToSameClass(e2);
          }
          if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return t3 = n2, this.getTypeCode() !== t3.getTypeCode() ? this.getTypeCode() - t3.getTypeCode() : this.isEmpty() && t3.isEmpty() ? 0 : this.isEmpty() ? -1 : t3.isEmpty() ? 1 : this.compareToSameClass(n2, i2);
          }
        } }, { key: "getUserData", value: function() {
          return this._userData;
        } }, { key: "getSRID", value: function() {
          return this._SRID;
        } }, { key: "getEnvelope", value: function() {
          return this.getFactory().toGeometry(this.getEnvelopeInternal());
        } }, { key: "checkNotGeometryCollection", value: function(e2) {
          if (e2.getTypeCode() === t2.TYPECODE_GEOMETRYCOLLECTION) throw new m("This method does not support GeometryCollection arguments");
        } }, { key: "equal", value: function(t3, e2, n2) {
          return 0 === n2 ? t3.equals(e2) : t3.distance(e2) <= n2;
        } }, { key: "norm", value: function() {
          var t3 = this.copy();
          return t3.normalize(), t3;
        } }, { key: "reverse", value: function() {
          var t3 = this.reverseInternal();
          return null != this.envelope && (t3.envelope = this.envelope.copy()), t3.setSRID(this.getSRID()), t3;
        } }, { key: "copy", value: function() {
          var t3 = this.copyInternal();
          return t3.envelope = null == this._envelope ? null : this._envelope.copy(), t3._SRID = this._SRID, t3._userData = this._userData, t3;
        } }, { key: "getPrecisionModel", value: function() {
          return this._factory.getPrecisionModel();
        } }, { key: "getEnvelopeInternal", value: function() {
          return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new U(this._envelope);
        } }, { key: "setSRID", value: function(t3) {
          this._SRID = t3;
        } }, { key: "setUserData", value: function(t3) {
          this._userData = t3;
        } }, { key: "compare", value: function(t3, e2) {
          for (var n2 = t3.iterator(), i2 = e2.iterator(); n2.hasNext() && i2.hasNext(); ) {
            var r2 = n2.next(), s2 = i2.next(), a2 = r2.compareTo(s2);
            if (0 !== a2) return a2;
          }
          return n2.hasNext() ? 1 : i2.hasNext() ? -1 : 0;
        } }, { key: "hashCode", value: function() {
          return this.getEnvelopeInternal().hashCode();
        } }, { key: "isEquivalentClass", value: function(t3) {
          return this.getClass() === t3.getClass();
        } }, { key: "isGeometryCollectionOrDerived", value: function() {
          return this.getTypeCode() === t2.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === t2.TYPECODE_MULTIPOINT || this.getTypeCode() === t2.TYPECODE_MULTILINESTRING || this.getTypeCode() === t2.TYPECODE_MULTIPOLYGON;
        } }, { key: "interfaces_", get: function() {
          return [I, x, E];
        } }, { key: "getClass", value: function() {
          return t2;
        } }], [{ key: "hasNonEmptyElements", value: function(t3) {
          for (var e2 = 0; e2 < t3.length; e2++) if (!t3[e2].isEmpty()) return true;
          return false;
        } }, { key: "hasNullElements", value: function(t3) {
          for (var e2 = 0; e2 < t3.length; e2++) if (null === t3[e2]) return true;
          return false;
        } }]);
      }();
      V.constructor_ = function(t2) {
        t2 && (this._envelope = null, this._userData = null, this._factory = t2, this._SRID = t2.getSRID());
      }, V.TYPECODE_POINT = 0, V.TYPECODE_MULTIPOINT = 1, V.TYPECODE_LINESTRING = 2, V.TYPECODE_LINEARRING = 3, V.TYPECODE_MULTILINESTRING = 4, V.TYPECODE_POLYGON = 5, V.TYPECODE_MULTIPOLYGON = 6, V.TYPECODE_GEOMETRYCOLLECTION = 7, V.TYPENAME_POINT = "Point", V.TYPENAME_MULTIPOINT = "MultiPoint", V.TYPENAME_LINESTRING = "LineString", V.TYPENAME_LINEARRING = "LinearRing", V.TYPENAME_MULTILINESTRING = "MultiLineString", V.TYPENAME_POLYGON = "Polygon", V.TYPENAME_MULTIPOLYGON = "MultiPolygon", V.TYPENAME_GEOMETRYCOLLECTION = "GeometryCollection", V.geometryChangedFilter = { get interfaces_() {
        return [k];
      }, filter: function(t2) {
        t2.geometryChangedAction();
      } };
      var H = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "toLocationSymbol", value: function(e2) {
          switch (e2) {
            case t2.EXTERIOR:
              return "e";
            case t2.BOUNDARY:
              return "b";
            case t2.INTERIOR:
              return "i";
            case t2.NONE:
              return "-";
          }
          throw new m("Unknown location value: " + e2);
        } }]);
      }();
      H.INTERIOR = 0, H.BOUNDARY = 1, H.EXTERIOR = 2, H.NONE = -1;
      var Z = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "add", value: function() {
        } }, { key: "addAll", value: function() {
        } }, { key: "isEmpty", value: function() {
        } }, { key: "iterator", value: function() {
        } }, { key: "size", value: function() {
        } }, { key: "toArray", value: function() {
        } }, { key: "remove", value: function() {
        } }]);
      }(), j = function(t2) {
        function i2(t3) {
          var r2;
          return n(this, i2), (r2 = e(this, i2, [t3])).name = Object.keys({ NoSuchElementException: i2 })[0], r2;
        }
        return l(i2, t2), s(i2);
      }(p), W = function(t2) {
        function i2(t3) {
          var r2;
          return n(this, i2), (r2 = e(this, i2, [t3])).name = Object.keys({ UnsupportedOperationException: i2 })[0], r2;
        }
        return l(i2, t2), s(i2);
      }(p), K = function(t2) {
        function i2() {
          return n(this, i2), e(this, i2, arguments);
        }
        return l(i2, t2), s(i2, [{ key: "contains", value: function() {
        } }]);
      }(Z), J = function(t2) {
        function i2(t3) {
          var r2;
          return n(this, i2), (r2 = e(this, i2)).map = /* @__PURE__ */ new Map(), t3 instanceof Z && r2.addAll(t3), r2;
        }
        return l(i2, t2), s(i2, [{ key: "contains", value: function(t3) {
          var e2 = t3.hashCode ? t3.hashCode() : t3;
          return !!this.map.has(e2);
        } }, { key: "add", value: function(t3) {
          var e2 = t3.hashCode ? t3.hashCode() : t3;
          return !this.map.has(e2) && !!this.map.set(e2, t3);
        } }, { key: "addAll", value: function(t3) {
          var e2, n2 = a(t3);
          try {
            for (n2.s(); !(e2 = n2.n()).done; ) {
              var i3 = e2.value;
              this.add(i3);
            }
          } catch (t4) {
            n2.e(t4);
          } finally {
            n2.f();
          }
          return true;
        } }, { key: "remove", value: function() {
          throw new W();
        } }, { key: "size", value: function() {
          return this.map.size;
        } }, { key: "isEmpty", value: function() {
          return 0 === this.map.size;
        } }, { key: "toArray", value: function() {
          return Array.from(this.map.values());
        } }, { key: "iterator", value: function() {
          return new Q(this.map);
        } }, { key: Symbol.iterator, value: function() {
          return this.map;
        } }]);
      }(K), Q = function() {
        return s(function t2(e2) {
          n(this, t2), this.iterator = e2.values();
          var i2 = this.iterator.next(), r2 = i2.done, s2 = i2.value;
          this.done = r2, this.value = s2;
        }, [{ key: "next", value: function() {
          if (this.done) throw new j();
          var t2 = this.value, e2 = this.iterator.next(), n2 = e2.done, i2 = e2.value;
          return this.done = n2, this.value = i2, t2;
        } }, { key: "hasNext", value: function() {
          return !this.done;
        } }, { key: "remove", value: function() {
          throw new W();
        } }]);
      }(), $ = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "opposite", value: function(e2) {
          return e2 === t2.LEFT ? t2.RIGHT : e2 === t2.RIGHT ? t2.LEFT : e2;
        } }]);
      }();
      $.ON = 0, $.LEFT = 1, $.RIGHT = 2;
      var tt = function(t2) {
        function i2(t3) {
          var r2;
          return n(this, i2), (r2 = e(this, i2, [t3])).name = Object.keys({ EmptyStackException: i2 })[0], r2;
        }
        return l(i2, t2), s(i2);
      }(p), et = function(t2) {
        function i2(t3) {
          var r2;
          return n(this, i2), (r2 = e(this, i2, [t3])).name = Object.keys({ IndexOutOfBoundsException: i2 })[0], r2;
        }
        return l(i2, t2), s(i2);
      }(p), nt = function(t2) {
        function i2() {
          return n(this, i2), e(this, i2, arguments);
        }
        return l(i2, t2), s(i2, [{ key: "get", value: function() {
        } }, { key: "set", value: function() {
        } }, { key: "isEmpty", value: function() {
        } }]);
      }(Z), it = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), (t3 = e(this, i2)).array = [], t3;
        }
        return l(i2, t2), s(i2, [{ key: "add", value: function(t3) {
          return this.array.push(t3), true;
        } }, { key: "get", value: function(t3) {
          if (t3 < 0 || t3 >= this.size()) throw new et();
          return this.array[t3];
        } }, { key: "push", value: function(t3) {
          return this.array.push(t3), t3;
        } }, { key: "pop", value: function() {
          if (0 === this.array.length) throw new tt();
          return this.array.pop();
        } }, { key: "peek", value: function() {
          if (0 === this.array.length) throw new tt();
          return this.array[this.array.length - 1];
        } }, { key: "empty", value: function() {
          return 0 === this.array.length;
        } }, { key: "isEmpty", value: function() {
          return this.empty();
        } }, { key: "search", value: function(t3) {
          return this.array.indexOf(t3);
        } }, { key: "size", value: function() {
          return this.array.length;
        } }, { key: "toArray", value: function() {
          return this.array.slice();
        } }]);
      }(nt);
      function rt(t2, e2) {
        return t2.interfaces_ && t2.interfaces_.indexOf(e2) > -1;
      }
      var st = function() {
        return s(function t2(e2) {
          n(this, t2), this.str = e2;
        }, [{ key: "append", value: function(t2) {
          this.str += t2;
        } }, { key: "setCharAt", value: function(t2, e2) {
          this.str = this.str.substr(0, t2) + e2 + this.str.substr(t2 + 1);
        } }, { key: "toString", value: function() {
          return this.str;
        } }]);
      }(), at = function() {
        function t2(e2) {
          n(this, t2), this.value = e2;
        }
        return s(t2, [{ key: "intValue", value: function() {
          return this.value;
        } }, { key: "compareTo", value: function(t3) {
          return this.value < t3 ? -1 : this.value > t3 ? 1 : 0;
        } }], [{ key: "compare", value: function(t3, e2) {
          return t3 < e2 ? -1 : t3 > e2 ? 1 : 0;
        } }, { key: "isNan", value: function(t3) {
          return Number.isNaN(t3);
        } }, { key: "valueOf", value: function(e2) {
          return new t2(e2);
        } }]);
      }(), ot = function() {
        return s(function t2() {
          n(this, t2);
        }, null, [{ key: "isWhitespace", value: function(t2) {
          return t2 <= 32 && t2 >= 0 || 127 === t2;
        } }, { key: "toUpperCase", value: function(t2) {
          return t2.toUpperCase();
        } }]);
      }(), ut = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "le", value: function(t3) {
          return this._hi < t3._hi || this._hi === t3._hi && this._lo <= t3._lo;
        } }, { key: "extractSignificantDigits", value: function(e2, n2) {
          var i2 = this.abs(), r2 = t2.magnitude(i2._hi), s2 = t2.TEN.pow(r2);
          (i2 = i2.divide(s2)).gt(t2.TEN) ? (i2 = i2.divide(t2.TEN), r2 += 1) : i2.lt(t2.ONE) && (i2 = i2.multiply(t2.TEN), r2 -= 1);
          for (var a2 = r2 + 1, o2 = new st(), u3 = t2.MAX_PRINT_DIGITS - 1, l2 = 0; l2 <= u3; l2++) {
            e2 && l2 === a2 && o2.append(".");
            var h2 = Math.trunc(i2._hi);
            if (h2 < 0) break;
            var c2 = false, f2 = 0;
            h2 > 9 ? (c2 = true, f2 = "9") : f2 = "0" + h2, o2.append(f2), i2 = i2.subtract(t2.valueOf(h2)).multiply(t2.TEN), c2 && i2.selfAdd(t2.TEN);
            var g2 = true, v2 = t2.magnitude(i2._hi);
            if (v2 < 0 && Math.abs(v2) >= u3 - l2 && (g2 = false), !g2) break;
          }
          return n2[0] = r2, o2.toString();
        } }, { key: "sqr", value: function() {
          return this.multiply(this);
        } }, { key: "doubleValue", value: function() {
          return this._hi + this._lo;
        } }, { key: "subtract", value: function() {
          if (arguments[0] instanceof t2) {
            var e2 = arguments[0];
            return this.add(e2.negate());
          }
          if ("number" == typeof arguments[0]) {
            var n2 = arguments[0];
            return this.add(-n2);
          }
        } }, { key: "equals", value: function() {
          if (1 === arguments.length && arguments[0] instanceof t2) {
            var e2 = arguments[0];
            return this._hi === e2._hi && this._lo === e2._lo;
          }
        } }, { key: "isZero", value: function() {
          return 0 === this._hi && 0 === this._lo;
        } }, { key: "selfSubtract", value: function() {
          if (arguments[0] instanceof t2) {
            var e2 = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-e2._hi, -e2._lo);
          }
          if ("number" == typeof arguments[0]) {
            var n2 = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-n2, 0);
          }
        } }, { key: "getSpecialNumberString", value: function() {
          return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
        } }, { key: "min", value: function(t3) {
          return this.le(t3) ? this : t3;
        } }, { key: "selfDivide", value: function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof t2) {
              var e2 = arguments[0];
              return this.selfDivide(e2._hi, e2._lo);
            }
            if ("number" == typeof arguments[0]) {
              var n2 = arguments[0];
              return this.selfDivide(n2, 0);
            }
          } else if (2 === arguments.length) {
            var i2, r2, s2, a2, o2 = arguments[0], u3 = arguments[1], l2 = null, h2 = null, c2 = null, f2 = null;
            return s2 = this._hi / o2, f2 = (l2 = (c2 = t2.SPLIT * s2) - (l2 = c2 - s2)) * (h2 = (f2 = t2.SPLIT * o2) - (h2 = f2 - o2)) - (a2 = s2 * o2) + l2 * (r2 = o2 - h2) + (i2 = s2 - l2) * h2 + i2 * r2, f2 = s2 + (c2 = (this._hi - a2 - f2 + this._lo - s2 * u3) / o2), this._hi = f2, this._lo = s2 - f2 + c2, this;
          }
        } }, { key: "dump", value: function() {
          return "DD<" + this._hi + ", " + this._lo + ">";
        } }, { key: "divide", value: function() {
          if (arguments[0] instanceof t2) {
            var e2, n2, i2, r2, s2 = arguments[0], a2 = null, o2 = null, u3 = null, l2 = null;
            return e2 = (i2 = this._hi / s2._hi) - (a2 = (u3 = t2.SPLIT * i2) - (a2 = u3 - i2)), l2 = a2 * (o2 = (l2 = t2.SPLIT * s2._hi) - (o2 = l2 - s2._hi)) - (r2 = i2 * s2._hi) + a2 * (n2 = s2._hi - o2) + e2 * o2 + e2 * n2, new t2(l2 = i2 + (u3 = (this._hi - r2 - l2 + this._lo - i2 * s2._lo) / s2._hi), i2 - l2 + u3);
          }
          if ("number" == typeof arguments[0]) {
            var h2 = arguments[0];
            return A.isNaN(h2) ? t2.createNaN() : t2.copy(this).selfDivide(h2, 0);
          }
        } }, { key: "ge", value: function(t3) {
          return this._hi > t3._hi || this._hi === t3._hi && this._lo >= t3._lo;
        } }, { key: "pow", value: function(e2) {
          if (0 === e2) return t2.valueOf(1);
          var n2 = new t2(this), i2 = t2.valueOf(1), r2 = Math.abs(e2);
          if (r2 > 1) for (; r2 > 0; ) r2 % 2 == 1 && i2.selfMultiply(n2), (r2 /= 2) > 0 && (n2 = n2.sqr());
          else i2 = n2;
          return e2 < 0 ? i2.reciprocal() : i2;
        } }, { key: "ceil", value: function() {
          if (this.isNaN()) return t2.NaN;
          var e2 = Math.ceil(this._hi), n2 = 0;
          return e2 === this._hi && (n2 = Math.ceil(this._lo)), new t2(e2, n2);
        } }, { key: "compareTo", value: function(t3) {
          var e2 = t3;
          return this._hi < e2._hi ? -1 : this._hi > e2._hi ? 1 : this._lo < e2._lo ? -1 : this._lo > e2._lo ? 1 : 0;
        } }, { key: "rint", value: function() {
          return this.isNaN() ? this : this.add(0.5).floor();
        } }, { key: "setValue", value: function() {
          if (arguments[0] instanceof t2) {
            var e2 = arguments[0];
            return this.init(e2), this;
          }
          if ("number" == typeof arguments[0]) {
            var n2 = arguments[0];
            return this.init(n2), this;
          }
        } }, { key: "max", value: function(t3) {
          return this.ge(t3) ? this : t3;
        } }, { key: "sqrt", value: function() {
          if (this.isZero()) return t2.valueOf(0);
          if (this.isNegative()) return t2.NaN;
          var e2 = 1 / Math.sqrt(this._hi), n2 = this._hi * e2, i2 = t2.valueOf(n2), r2 = this.subtract(i2.sqr())._hi * (0.5 * e2);
          return i2.add(r2);
        } }, { key: "selfAdd", value: function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof t2) {
              var e2 = arguments[0];
              return this.selfAdd(e2._hi, e2._lo);
            }
            if ("number" == typeof arguments[0]) {
              var n2, i2, r2, s2, a2, o2 = arguments[0], u3 = null;
              return u3 = (r2 = this._hi + o2) - (s2 = r2 - this._hi), i2 = (a2 = (u3 = o2 - s2 + (this._hi - u3)) + this._lo) + (r2 - (n2 = r2 + a2)), this._hi = n2 + i2, this._lo = i2 + (n2 - this._hi), this;
            }
          } else if (2 === arguments.length) {
            var l2, h2, c2, f2, g2 = arguments[0], v2 = arguments[1], y2 = null, d2 = null, _2 = null;
            c2 = this._hi + g2, h2 = this._lo + v2, d2 = c2 - (_2 = c2 - this._hi), y2 = h2 - (f2 = h2 - this._lo);
            var p2 = (l2 = c2 + (_2 = (d2 = g2 - _2 + (this._hi - d2)) + h2)) + (_2 = (y2 = v2 - f2 + (this._lo - y2)) + (_2 + (c2 - l2))), m2 = _2 + (l2 - p2);
            return this._hi = p2, this._lo = m2, this;
          }
        } }, { key: "selfMultiply", value: function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof t2) {
              var e2 = arguments[0];
              return this.selfMultiply(e2._hi, e2._lo);
            }
            if ("number" == typeof arguments[0]) {
              var n2 = arguments[0];
              return this.selfMultiply(n2, 0);
            }
          } else if (2 === arguments.length) {
            var i2, r2, s2 = arguments[0], a2 = arguments[1], o2 = null, u3 = null, l2 = null, h2 = null;
            o2 = (l2 = t2.SPLIT * this._hi) - this._hi, h2 = t2.SPLIT * s2, o2 = l2 - o2, i2 = this._hi - o2, u3 = h2 - s2;
            var c2 = (l2 = this._hi * s2) + (h2 = o2 * (u3 = h2 - u3) - l2 + o2 * (r2 = s2 - u3) + i2 * u3 + i2 * r2 + (this._hi * a2 + this._lo * s2)), f2 = h2 + (o2 = l2 - c2);
            return this._hi = c2, this._lo = f2, this;
          }
        } }, { key: "selfSqr", value: function() {
          return this.selfMultiply(this);
        } }, { key: "floor", value: function() {
          if (this.isNaN()) return t2.NaN;
          var e2 = Math.floor(this._hi), n2 = 0;
          return e2 === this._hi && (n2 = Math.floor(this._lo)), new t2(e2, n2);
        } }, { key: "negate", value: function() {
          return this.isNaN() ? this : new t2(-this._hi, -this._lo);
        } }, { key: "clone", value: function() {
          try {
            return null;
          } catch (t3) {
            if (t3 instanceof CloneNotSupportedException) return null;
            throw t3;
          }
        } }, { key: "multiply", value: function() {
          if (arguments[0] instanceof t2) {
            var e2 = arguments[0];
            return e2.isNaN() ? t2.createNaN() : t2.copy(this).selfMultiply(e2);
          }
          if ("number" == typeof arguments[0]) {
            var n2 = arguments[0];
            return A.isNaN(n2) ? t2.createNaN() : t2.copy(this).selfMultiply(n2, 0);
          }
        } }, { key: "isNaN", value: function() {
          return A.isNaN(this._hi);
        } }, { key: "intValue", value: function() {
          return Math.trunc(this._hi);
        } }, { key: "toString", value: function() {
          var e2 = t2.magnitude(this._hi);
          return e2 >= -3 && e2 <= 20 ? this.toStandardNotation() : this.toSciNotation();
        } }, { key: "toStandardNotation", value: function() {
          var e2 = this.getSpecialNumberString();
          if (null !== e2) return e2;
          var n2 = new Array(1).fill(null), i2 = this.extractSignificantDigits(true, n2), r2 = n2[0] + 1, s2 = i2;
          if ("." === i2.charAt(0)) s2 = "0" + i2;
          else if (r2 < 0) s2 = "0." + t2.stringOfChar("0", -r2) + i2;
          else if (-1 === i2.indexOf(".")) {
            var a2 = r2 - i2.length;
            s2 = i2 + t2.stringOfChar("0", a2) + ".0";
          }
          return this.isNegative() ? "-" + s2 : s2;
        } }, { key: "reciprocal", value: function() {
          var e2, n2, i2, r2, s2 = null, a2 = null, o2 = null, u3 = null;
          e2 = (i2 = 1 / this._hi) - (s2 = (o2 = t2.SPLIT * i2) - (s2 = o2 - i2)), a2 = (u3 = t2.SPLIT * this._hi) - this._hi;
          var l2 = i2 + (o2 = (1 - (r2 = i2 * this._hi) - (u3 = s2 * (a2 = u3 - a2) - r2 + s2 * (n2 = this._hi - a2) + e2 * a2 + e2 * n2) - i2 * this._lo) / this._hi);
          return new t2(l2, i2 - l2 + o2);
        } }, { key: "toSciNotation", value: function() {
          if (this.isZero()) return t2.SCI_NOT_ZERO;
          var e2 = this.getSpecialNumberString();
          if (null !== e2) return e2;
          var n2 = new Array(1).fill(null), i2 = this.extractSignificantDigits(false, n2), r2 = t2.SCI_NOT_EXPONENT_CHAR + n2[0];
          if ("0" === i2.charAt(0)) throw new IllegalStateException("Found leading zero: " + i2);
          var s2 = "";
          i2.length > 1 && (s2 = i2.substring(1));
          var a2 = i2.charAt(0) + "." + s2;
          return this.isNegative() ? "-" + a2 + r2 : a2 + r2;
        } }, { key: "abs", value: function() {
          return this.isNaN() ? t2.NaN : this.isNegative() ? this.negate() : new t2(this);
        } }, { key: "isPositive", value: function() {
          return this._hi > 0 || 0 === this._hi && this._lo > 0;
        } }, { key: "lt", value: function(t3) {
          return this._hi < t3._hi || this._hi === t3._hi && this._lo < t3._lo;
        } }, { key: "add", value: function() {
          if (arguments[0] instanceof t2) {
            var e2 = arguments[0];
            return t2.copy(this).selfAdd(e2);
          }
          if ("number" == typeof arguments[0]) {
            var n2 = arguments[0];
            return t2.copy(this).selfAdd(n2);
          }
        } }, { key: "init", value: function() {
          if (1 === arguments.length) {
            if ("number" == typeof arguments[0]) {
              var e2 = arguments[0];
              this._hi = e2, this._lo = 0;
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this._hi = n2._hi, this._lo = n2._lo;
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this._hi = i2, this._lo = r2;
          }
        } }, { key: "gt", value: function(t3) {
          return this._hi > t3._hi || this._hi === t3._hi && this._lo > t3._lo;
        } }, { key: "isNegative", value: function() {
          return this._hi < 0 || 0 === this._hi && this._lo < 0;
        } }, { key: "trunc", value: function() {
          return this.isNaN() ? t2.NaN : this.isPositive() ? this.floor() : this.ceil();
        } }, { key: "signum", value: function() {
          return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
        } }, { key: "interfaces_", get: function() {
          return [E, x, I];
        } }], [{ key: "constructor_", value: function() {
          if (this._hi = 0, this._lo = 0, 0 === arguments.length) this.init(0);
          else if (1 === arguments.length) {
            if ("number" == typeof arguments[0]) {
              var e2 = arguments[0];
              this.init(e2);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this.init(n2);
            } else if ("string" == typeof arguments[0]) {
              var i2 = arguments[0];
              t2.constructor_.call(this, t2.parse(i2));
            }
          } else if (2 === arguments.length) {
            var r2 = arguments[0], s2 = arguments[1];
            this.init(r2, s2);
          }
        } }, { key: "determinant", value: function() {
          if ("number" == typeof arguments[3] && "number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var e2 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = arguments[3];
            return t2.determinant(t2.valueOf(e2), t2.valueOf(n2), t2.valueOf(i2), t2.valueOf(r2));
          }
          if (arguments[3] instanceof t2 && arguments[2] instanceof t2 && arguments[0] instanceof t2 && arguments[1] instanceof t2) {
            var s2 = arguments[1], a2 = arguments[2], o2 = arguments[3];
            return arguments[0].multiply(o2).selfSubtract(s2.multiply(a2));
          }
        } }, { key: "sqr", value: function(e2) {
          return t2.valueOf(e2).selfMultiply(e2);
        } }, { key: "valueOf", value: function() {
          if ("string" == typeof arguments[0]) {
            var e2 = arguments[0];
            return t2.parse(e2);
          }
          if ("number" == typeof arguments[0]) return new t2(arguments[0]);
        } }, { key: "sqrt", value: function(e2) {
          return t2.valueOf(e2).sqrt();
        } }, { key: "parse", value: function(e2) {
          for (var n2 = 0, i2 = e2.length; ot.isWhitespace(e2.charAt(n2)); ) n2++;
          var r2 = false;
          if (n2 < i2) {
            var s2 = e2.charAt(n2);
            "-" !== s2 && "+" !== s2 || (n2++, "-" === s2 && (r2 = true));
          }
          for (var a2 = new t2(), o2 = 0, u3 = 0, l2 = 0, h2 = false; !(n2 >= i2); ) {
            var c2 = e2.charAt(n2);
            if (n2++, ot.isDigit(c2)) {
              var f2 = c2 - "0";
              a2.selfMultiply(t2.TEN), a2.selfAdd(f2), o2++;
            } else {
              if ("." !== c2) {
                if ("e" === c2 || "E" === c2) {
                  var g2 = e2.substring(n2);
                  try {
                    l2 = at.parseInt(g2);
                  } catch (t3) {
                    throw t3 instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + g2 + " in string " + e2) : t3;
                  }
                  break;
                }
                throw new NumberFormatException("Unexpected character '" + c2 + "' at position " + n2 + " in string " + e2);
              }
              u3 = o2, h2 = true;
            }
          }
          var v2 = a2;
          h2 || (u3 = o2);
          var y2 = o2 - u3 - l2;
          if (0 === y2) v2 = a2;
          else if (y2 > 0) {
            var d2 = t2.TEN.pow(y2);
            v2 = a2.divide(d2);
          } else if (y2 < 0) {
            var _2 = t2.TEN.pow(-y2);
            v2 = a2.multiply(_2);
          }
          return r2 ? v2.negate() : v2;
        } }, { key: "createNaN", value: function() {
          return new t2(A.NaN, A.NaN);
        } }, { key: "copy", value: function(e2) {
          return new t2(e2);
        } }, { key: "magnitude", value: function(t3) {
          var e2 = Math.abs(t3), n2 = Math.log(e2) / Math.log(10), i2 = Math.trunc(Math.floor(n2));
          return 10 * Math.pow(10, i2) <= e2 && (i2 += 1), i2;
        } }, { key: "stringOfChar", value: function(t3, e2) {
          for (var n2 = new st(), i2 = 0; i2 < e2; i2++) n2.append(t3);
          return n2.toString();
        } }]);
      }();
      ut.PI = new ut(3.141592653589793, 12246467991473532e-32), ut.TWO_PI = new ut(6.283185307179586, 24492935982947064e-32), ut.PI_2 = new ut(1.5707963267948966, 6123233995736766e-32), ut.E = new ut(2.718281828459045, 14456468917292502e-32), ut.NaN = new ut(A.NaN, A.NaN), ut.EPS = 123259516440783e-46, ut.SPLIT = 134217729, ut.MAX_PRINT_DIGITS = 32, ut.TEN = ut.valueOf(10), ut.ONE = ut.valueOf(1), ut.SCI_NOT_EXPONENT_CHAR = "E", ut.SCI_NOT_ZERO = "0.0E0";
      var lt = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "orientationIndex", value: function(e2, n2, i2) {
          var r2 = t2.orientationIndexFilter(e2, n2, i2);
          if (r2 <= 1) return r2;
          var s2 = ut.valueOf(n2.x).selfAdd(-e2.x), a2 = ut.valueOf(n2.y).selfAdd(-e2.y), o2 = ut.valueOf(i2.x).selfAdd(-n2.x), u3 = ut.valueOf(i2.y).selfAdd(-n2.y);
          return s2.selfMultiply(u3).selfSubtract(a2.selfMultiply(o2)).signum();
        } }, { key: "signOfDet2x2", value: function() {
          if (arguments[3] instanceof ut && arguments[2] instanceof ut && arguments[0] instanceof ut && arguments[1] instanceof ut) {
            var t3 = arguments[1], e2 = arguments[2], n2 = arguments[3];
            return arguments[0].multiply(n2).selfSubtract(t3.multiply(e2)).signum();
          }
          if ("number" == typeof arguments[3] && "number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var i2 = arguments[0], r2 = arguments[1], s2 = arguments[2], a2 = arguments[3], o2 = ut.valueOf(i2), u3 = ut.valueOf(r2), l2 = ut.valueOf(s2), h2 = ut.valueOf(a2);
            return o2.multiply(h2).selfSubtract(u3.multiply(l2)).signum();
          }
        } }, { key: "intersection", value: function(t3, e2, n2, i2) {
          var r2 = new ut(t3.y).selfSubtract(e2.y), s2 = new ut(e2.x).selfSubtract(t3.x), a2 = new ut(t3.x).selfMultiply(e2.y).selfSubtract(new ut(e2.x).selfMultiply(t3.y)), o2 = new ut(n2.y).selfSubtract(i2.y), u3 = new ut(i2.x).selfSubtract(n2.x), l2 = new ut(n2.x).selfMultiply(i2.y).selfSubtract(new ut(i2.x).selfMultiply(n2.y)), h2 = s2.multiply(l2).selfSubtract(u3.multiply(a2)), c2 = o2.multiply(a2).selfSubtract(r2.multiply(l2)), f2 = r2.multiply(u3).selfSubtract(o2.multiply(s2)), g2 = h2.selfDivide(f2).doubleValue(), v2 = c2.selfDivide(f2).doubleValue();
          return A.isNaN(g2) || A.isInfinite(g2) || A.isNaN(v2) || A.isInfinite(v2) ? null : new X(g2, v2);
        } }, { key: "orientationIndexFilter", value: function(e2, n2, i2) {
          var r2 = null, s2 = (e2.x - i2.x) * (n2.y - i2.y), a2 = (e2.y - i2.y) * (n2.x - i2.x), o2 = s2 - a2;
          if (s2 > 0) {
            if (a2 <= 0) return t2.signum(o2);
            r2 = s2 + a2;
          } else {
            if (!(s2 < 0)) return t2.signum(o2);
            if (a2 >= 0) return t2.signum(o2);
            r2 = -s2 - a2;
          }
          var u3 = t2.DP_SAFE_EPSILON * r2;
          return o2 >= u3 || -o2 >= u3 ? t2.signum(o2) : 2;
        } }, { key: "signum", value: function(t3) {
          return t3 > 0 ? 1 : t3 < 0 ? -1 : 0;
        } }]);
      }();
      lt.DP_SAFE_EPSILON = 1e-15;
      var ht = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "getM", value: function(t2) {
          if (this.hasM()) {
            var e2 = this.getDimension() - this.getMeasures();
            return this.getOrdinate(t2, e2);
          }
          return A.NaN;
        } }, { key: "setOrdinate", value: function(t2, e2, n2) {
        } }, { key: "getZ", value: function(t2) {
          return this.hasZ() ? this.getOrdinate(t2, 2) : A.NaN;
        } }, { key: "size", value: function() {
        } }, { key: "getOrdinate", value: function(t2, e2) {
        } }, { key: "getCoordinate", value: function() {
        } }, { key: "getCoordinateCopy", value: function(t2) {
        } }, { key: "createCoordinate", value: function() {
        } }, { key: "getDimension", value: function() {
        } }, { key: "hasM", value: function() {
          return this.getMeasures() > 0;
        } }, { key: "getX", value: function(t2) {
        } }, { key: "hasZ", value: function() {
          return this.getDimension() - this.getMeasures() > 2;
        } }, { key: "getMeasures", value: function() {
          return 0;
        } }, { key: "expandEnvelope", value: function(t2) {
        } }, { key: "copy", value: function() {
        } }, { key: "getY", value: function(t2) {
        } }, { key: "toCoordinateArray", value: function() {
        } }, { key: "interfaces_", get: function() {
          return [I];
        } }]);
      }();
      ht.X = 0, ht.Y = 1, ht.Z = 2, ht.M = 3;
      var ct = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "index", value: function(t3, e2, n2) {
          return lt.orientationIndex(t3, e2, n2);
        } }, { key: "isCCW", value: function() {
          if (arguments[0] instanceof Array) {
            var e2 = arguments[0], n2 = e2.length - 1;
            if (n2 < 3) throw new m("Ring has fewer than 4 points, so orientation cannot be determined");
            for (var i2 = e2[0], r2 = 0, s2 = 1; s2 <= n2; s2++) {
              var a2 = e2[s2];
              a2.y > i2.y && (i2 = a2, r2 = s2);
            }
            var o2 = r2;
            do {
              (o2 -= 1) < 0 && (o2 = n2);
            } while (e2[o2].equals2D(i2) && o2 !== r2);
            var u3 = r2;
            do {
              u3 = (u3 + 1) % n2;
            } while (e2[u3].equals2D(i2) && u3 !== r2);
            var l2 = e2[o2], h2 = e2[u3];
            if (l2.equals2D(i2) || h2.equals2D(i2) || l2.equals2D(h2)) return false;
            var c2 = t2.index(l2, i2, h2);
            return 0 === c2 ? l2.x > h2.x : c2 > 0;
          }
          if (rt(arguments[0], ht)) {
            var f2 = arguments[0], g2 = f2.size() - 1;
            if (g2 < 3) throw new m("Ring has fewer than 4 points, so orientation cannot be determined");
            for (var v2 = f2.getCoordinate(0), y2 = 0, d2 = 1; d2 <= g2; d2++) {
              var _2 = f2.getCoordinate(d2);
              _2.y > v2.y && (v2 = _2, y2 = d2);
            }
            var p2 = null, k2 = y2;
            do {
              (k2 -= 1) < 0 && (k2 = g2), p2 = f2.getCoordinate(k2);
            } while (p2.equals2D(v2) && k2 !== y2);
            var x2 = null, I2 = y2;
            do {
              I2 = (I2 + 1) % g2, x2 = f2.getCoordinate(I2);
            } while (x2.equals2D(v2) && I2 !== y2);
            if (p2.equals2D(v2) || x2.equals2D(v2) || p2.equals2D(x2)) return false;
            var E2 = t2.index(p2, v2, x2);
            return 0 === E2 ? p2.x > x2.x : E2 > 0;
          }
        } }]);
      }();
      ct.CLOCKWISE = -1, ct.RIGHT = ct.CLOCKWISE, ct.COUNTERCLOCKWISE = 1, ct.LEFT = ct.COUNTERCLOCKWISE, ct.COLLINEAR = 0, ct.STRAIGHT = ct.COLLINEAR;
      var ft = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "getCoordinate", value: function() {
          return this._minCoord;
        } }, { key: "getRightmostSide", value: function(t2, e2) {
          var n2 = this.getRightmostSideOfSegment(t2, e2);
          return n2 < 0 && (n2 = this.getRightmostSideOfSegment(t2, e2 - 1)), n2 < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t2)), n2;
        } }, { key: "findRightmostEdgeAtVertex", value: function() {
          var t2 = this._minDe.getEdge().getCoordinates();
          G.isTrue(this._minIndex > 0 && this._minIndex < t2.length, "rightmost point expected to be interior vertex of edge");
          var e2 = t2[this._minIndex - 1], n2 = t2[this._minIndex + 1], i2 = ct.index(this._minCoord, n2, e2), r2 = false;
          (e2.y < this._minCoord.y && n2.y < this._minCoord.y && i2 === ct.COUNTERCLOCKWISE || e2.y > this._minCoord.y && n2.y > this._minCoord.y && i2 === ct.CLOCKWISE) && (r2 = true), r2 && (this._minIndex = this._minIndex - 1);
        } }, { key: "getRightmostSideOfSegment", value: function(t2, e2) {
          var n2 = t2.getEdge().getCoordinates();
          if (e2 < 0 || e2 + 1 >= n2.length) return -1;
          if (n2[e2].y === n2[e2 + 1].y) return -1;
          var i2 = $.LEFT;
          return n2[e2].y < n2[e2 + 1].y && (i2 = $.RIGHT), i2;
        } }, { key: "getEdge", value: function() {
          return this._orientedDe;
        } }, { key: "checkForRightmostCoordinate", value: function(t2) {
          for (var e2 = t2.getEdge().getCoordinates(), n2 = 0; n2 < e2.length - 1; n2++) (null === this._minCoord || e2[n2].x > this._minCoord.x) && (this._minDe = t2, this._minIndex = n2, this._minCoord = e2[n2]);
        } }, { key: "findRightmostEdgeAtNode", value: function() {
          var t2 = this._minDe.getNode().getEdges();
          this._minDe = t2.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
        } }, { key: "findEdge", value: function(t2) {
          for (var e2 = t2.iterator(); e2.hasNext(); ) {
            var n2 = e2.next();
            n2.isForward() && this.checkForRightmostCoordinate(n2);
          }
          G.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe, this.getRightmostSide(this._minDe, this._minIndex) === $.LEFT && (this._orientedDe = this._minDe.getSym());
        } }], [{ key: "constructor_", value: function() {
          this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
        } }]);
      }(), gt = function(t2) {
        function i2(t3, r2) {
          var s2;
          return n(this, i2), (s2 = e(this, i2, [r2 ? t3 + " [ " + r2 + " ]" : t3])).pt = r2 ? new X(r2) : void 0, s2.name = Object.keys({ TopologyException: i2 })[0], s2;
        }
        return l(i2, t2), s(i2, [{ key: "getCoordinate", value: function() {
          return this.pt;
        } }]);
      }(D2), vt = function() {
        return s(function t2() {
          n(this, t2), this.array = [];
        }, [{ key: "addLast", value: function(t2) {
          this.array.push(t2);
        } }, { key: "removeFirst", value: function() {
          return this.array.shift();
        } }, { key: "isEmpty", value: function() {
          return 0 === this.array.length;
        } }]);
      }(), yt = function(t2) {
        function i2(t3) {
          var r2;
          return n(this, i2), (r2 = e(this, i2)).array = [], t3 instanceof Z && r2.addAll(t3), r2;
        }
        return l(i2, t2), s(i2, [{ key: "interfaces_", get: function() {
          return [nt, Z];
        } }, { key: "ensureCapacity", value: function() {
        } }, { key: "add", value: function(t3) {
          return 1 === arguments.length ? this.array.push(t3) : this.array.splice(arguments[0], 0, arguments[1]), true;
        } }, { key: "clear", value: function() {
          this.array = [];
        } }, { key: "addAll", value: function(t3) {
          var e2, n2 = a(t3);
          try {
            for (n2.s(); !(e2 = n2.n()).done; ) {
              var i3 = e2.value;
              this.array.push(i3);
            }
          } catch (t4) {
            n2.e(t4);
          } finally {
            n2.f();
          }
        } }, { key: "set", value: function(t3, e2) {
          var n2 = this.array[t3];
          return this.array[t3] = e2, n2;
        } }, { key: "iterator", value: function() {
          return new dt(this);
        } }, { key: "get", value: function(t3) {
          if (t3 < 0 || t3 >= this.size()) throw new et();
          return this.array[t3];
        } }, { key: "isEmpty", value: function() {
          return 0 === this.array.length;
        } }, { key: "sort", value: function(t3) {
          t3 ? this.array.sort(function(e2, n2) {
            return t3.compare(e2, n2);
          }) : this.array.sort();
        } }, { key: "size", value: function() {
          return this.array.length;
        } }, { key: "toArray", value: function() {
          return this.array.slice();
        } }, { key: "remove", value: function(t3) {
          for (var e2 = 0, n2 = this.array.length; e2 < n2; e2++) if (this.array[e2] === t3) return !!this.array.splice(e2, 1);
          return false;
        } }, { key: Symbol.iterator, value: function() {
          return this.array.values();
        } }]);
      }(nt), dt = function() {
        return s(function t2(e2) {
          n(this, t2), this.arrayList = e2, this.position = 0;
        }, [{ key: "next", value: function() {
          if (this.position === this.arrayList.size()) throw new j();
          return this.arrayList.get(this.position++);
        } }, { key: "hasNext", value: function() {
          return this.position < this.arrayList.size();
        } }, { key: "set", value: function(t2) {
          return this.arrayList.set(this.position - 1, t2);
        } }, { key: "remove", value: function() {
          this.arrayList.remove(this.arrayList.get(this.position));
        } }]);
      }(), _t = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "clearVisitedEdges", value: function() {
          for (var t2 = this._dirEdgeList.iterator(); t2.hasNext(); ) {
            t2.next().setVisited(false);
          }
        } }, { key: "getRightmostCoordinate", value: function() {
          return this._rightMostCoord;
        } }, { key: "computeNodeDepth", value: function(t2) {
          for (var e2 = null, n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (i2.isVisited() || i2.getSym().isVisited()) {
              e2 = i2;
              break;
            }
          }
          if (null === e2) throw new gt("unable to find edge to compute depths at " + t2.getCoordinate());
          t2.getEdges().computeDepths(e2);
          for (var r2 = t2.getEdges().iterator(); r2.hasNext(); ) {
            var s2 = r2.next();
            s2.setVisited(true), this.copySymDepths(s2);
          }
        } }, { key: "computeDepth", value: function(t2) {
          this.clearVisitedEdges();
          var e2 = this._finder.getEdge();
          e2.getNode(), e2.getLabel(), e2.setEdgeDepths($.RIGHT, t2), this.copySymDepths(e2), this.computeDepths(e2);
        } }, { key: "create", value: function(t2) {
          this.addReachable(t2), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
        } }, { key: "findResultEdges", value: function() {
          for (var t2 = this._dirEdgeList.iterator(); t2.hasNext(); ) {
            var e2 = t2.next();
            e2.getDepth($.RIGHT) >= 1 && e2.getDepth($.LEFT) <= 0 && !e2.isInteriorAreaEdge() && e2.setInResult(true);
          }
        } }, { key: "computeDepths", value: function(t2) {
          var e2 = new J(), n2 = new vt(), i2 = t2.getNode();
          for (n2.addLast(i2), e2.add(i2), t2.setVisited(true); !n2.isEmpty(); ) {
            var r2 = n2.removeFirst();
            e2.add(r2), this.computeNodeDepth(r2);
            for (var s2 = r2.getEdges().iterator(); s2.hasNext(); ) {
              var a2 = s2.next().getSym();
              if (!a2.isVisited()) {
                var o2 = a2.getNode();
                e2.contains(o2) || (n2.addLast(o2), e2.add(o2));
              }
            }
          }
        } }, { key: "compareTo", value: function(t2) {
          var e2 = t2;
          return this._rightMostCoord.x < e2._rightMostCoord.x ? -1 : this._rightMostCoord.x > e2._rightMostCoord.x ? 1 : 0;
        } }, { key: "getEnvelope", value: function() {
          if (null === this._env) {
            for (var t2 = new U(), e2 = this._dirEdgeList.iterator(); e2.hasNext(); ) for (var n2 = e2.next().getEdge().getCoordinates(), i2 = 0; i2 < n2.length - 1; i2++) t2.expandToInclude(n2[i2]);
            this._env = t2;
          }
          return this._env;
        } }, { key: "addReachable", value: function(t2) {
          var e2 = new it();
          for (e2.add(t2); !e2.empty(); ) {
            var n2 = e2.pop();
            this.add(n2, e2);
          }
        } }, { key: "copySymDepths", value: function(t2) {
          var e2 = t2.getSym();
          e2.setDepth($.LEFT, t2.getDepth($.RIGHT)), e2.setDepth($.RIGHT, t2.getDepth($.LEFT));
        } }, { key: "add", value: function(t2, e2) {
          t2.setVisited(true), this._nodes.add(t2);
          for (var n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            this._dirEdgeList.add(i2);
            var r2 = i2.getSym().getNode();
            r2.isVisited() || e2.push(r2);
          }
        } }, { key: "getNodes", value: function() {
          return this._nodes;
        } }, { key: "getDirectedEdges", value: function() {
          return this._dirEdgeList;
        } }, { key: "interfaces_", get: function() {
          return [x];
        } }], [{ key: "constructor_", value: function() {
          this._finder = null, this._dirEdgeList = new yt(), this._nodes = new yt(), this._rightMostCoord = null, this._env = null, this._finder = new ft();
        } }]);
      }(), pt = function() {
        return s(function t2() {
          n(this, t2);
        }, null, [{ key: "intersection", value: function(t2, e2, n2, i2) {
          var r2 = t2.x < e2.x ? t2.x : e2.x, s2 = t2.y < e2.y ? t2.y : e2.y, a2 = t2.x > e2.x ? t2.x : e2.x, o2 = t2.y > e2.y ? t2.y : e2.y, u3 = n2.x < i2.x ? n2.x : i2.x, l2 = n2.y < i2.y ? n2.y : i2.y, h2 = n2.x > i2.x ? n2.x : i2.x, c2 = n2.y > i2.y ? n2.y : i2.y, f2 = ((r2 > u3 ? r2 : u3) + (a2 < h2 ? a2 : h2)) / 2, g2 = ((s2 > l2 ? s2 : l2) + (o2 < c2 ? o2 : c2)) / 2, v2 = t2.x - f2, y2 = t2.y - g2, d2 = e2.x - f2, _2 = e2.y - g2, p2 = n2.x - f2, m2 = n2.y - g2, k2 = i2.x - f2, x2 = i2.y - g2, I2 = y2 - _2, E2 = d2 - v2, N2 = v2 * _2 - d2 * y2, T2 = m2 - x2, S2 = k2 - p2, L3 = p2 * x2 - k2 * m2, C3 = I2 * S2 - T2 * E2, R2 = (E2 * L3 - S2 * N2) / C3, w2 = (T2 * N2 - I2 * L3) / C3;
          return A.isNaN(R2) || A.isInfinite(R2) || A.isNaN(w2) || A.isInfinite(w2) ? null : new X(R2 + f2, w2 + g2);
        } }]);
      }(), mt = function() {
        return s(function t2() {
          n(this, t2);
        }, null, [{ key: "arraycopy", value: function(t2, e2, n2, i2, r2) {
          for (var s2 = 0, a2 = e2; a2 < e2 + r2; a2++) n2[i2 + s2] = t2[a2], s2++;
        } }, { key: "getProperty", value: function(t2) {
          return { "line.separator": "\n" }[t2];
        } }]);
      }(), kt = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "log10", value: function(e2) {
          var n2 = Math.log(e2);
          return A.isInfinite(n2) || A.isNaN(n2) ? n2 : n2 / t2.LOG_10;
        } }, { key: "min", value: function(t3, e2, n2, i2) {
          var r2 = t3;
          return e2 < r2 && (r2 = e2), n2 < r2 && (r2 = n2), i2 < r2 && (r2 = i2), r2;
        } }, { key: "clamp", value: function() {
          if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t3 = arguments[0], e2 = arguments[1], n2 = arguments[2];
            return t3 < e2 ? e2 : t3 > n2 ? n2 : t3;
          }
          if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var i2 = arguments[0], r2 = arguments[1], s2 = arguments[2];
            return i2 < r2 ? r2 : i2 > s2 ? s2 : i2;
          }
        } }, { key: "wrap", value: function(t3, e2) {
          return t3 < 0 ? e2 - -t3 % e2 : t3 % e2;
        } }, { key: "max", value: function() {
          if (3 === arguments.length) {
            var t3 = arguments[1], e2 = arguments[2], n2 = arguments[0];
            return t3 > n2 && (n2 = t3), e2 > n2 && (n2 = e2), n2;
          }
          if (4 === arguments.length) {
            var i2 = arguments[1], r2 = arguments[2], s2 = arguments[3], a2 = arguments[0];
            return i2 > a2 && (a2 = i2), r2 > a2 && (a2 = r2), s2 > a2 && (a2 = s2), a2;
          }
        } }, { key: "average", value: function(t3, e2) {
          return (t3 + e2) / 2;
        } }]);
      }();
      kt.LOG_10 = Math.log(10);
      var xt = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "segmentToSegment", value: function(e2, n2, i2, r2) {
          if (e2.equals(n2)) return t2.pointToSegment(e2, i2, r2);
          if (i2.equals(r2)) return t2.pointToSegment(r2, e2, n2);
          var s2 = false;
          if (U.intersects(e2, n2, i2, r2)) {
            var a2 = (n2.x - e2.x) * (r2.y - i2.y) - (n2.y - e2.y) * (r2.x - i2.x);
            if (0 === a2) s2 = true;
            else {
              var o2 = (e2.y - i2.y) * (r2.x - i2.x) - (e2.x - i2.x) * (r2.y - i2.y), u3 = ((e2.y - i2.y) * (n2.x - e2.x) - (e2.x - i2.x) * (n2.y - e2.y)) / a2, l2 = o2 / a2;
              (l2 < 0 || l2 > 1 || u3 < 0 || u3 > 1) && (s2 = true);
            }
          } else s2 = true;
          return s2 ? kt.min(t2.pointToSegment(e2, i2, r2), t2.pointToSegment(n2, i2, r2), t2.pointToSegment(i2, e2, n2), t2.pointToSegment(r2, e2, n2)) : 0;
        } }, { key: "pointToSegment", value: function(t3, e2, n2) {
          if (e2.x === n2.x && e2.y === n2.y) return t3.distance(e2);
          var i2 = (n2.x - e2.x) * (n2.x - e2.x) + (n2.y - e2.y) * (n2.y - e2.y), r2 = ((t3.x - e2.x) * (n2.x - e2.x) + (t3.y - e2.y) * (n2.y - e2.y)) / i2;
          if (r2 <= 0) return t3.distance(e2);
          if (r2 >= 1) return t3.distance(n2);
          var s2 = ((e2.y - t3.y) * (n2.x - e2.x) - (e2.x - t3.x) * (n2.y - e2.y)) / i2;
          return Math.abs(s2) * Math.sqrt(i2);
        } }, { key: "pointToLinePerpendicular", value: function(t3, e2, n2) {
          var i2 = (n2.x - e2.x) * (n2.x - e2.x) + (n2.y - e2.y) * (n2.y - e2.y), r2 = ((e2.y - t3.y) * (n2.x - e2.x) - (e2.x - t3.x) * (n2.y - e2.y)) / i2;
          return Math.abs(r2) * Math.sqrt(i2);
        } }, { key: "pointToSegmentString", value: function(e2, n2) {
          if (0 === n2.length) throw new m("Line array must contain at least one vertex");
          for (var i2 = e2.distance(n2[0]), r2 = 0; r2 < n2.length - 1; r2++) {
            var s2 = t2.pointToSegment(e2, n2[r2], n2[r2 + 1]);
            s2 < i2 && (i2 = s2);
          }
          return i2;
        } }]);
      }(), It = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "create", value: function() {
          if (1 === arguments.length) arguments[0] instanceof Array || rt(arguments[0], ht);
          else if (2 === arguments.length) ;
          else if (3 === arguments.length) {
            var t2 = arguments[0], e2 = arguments[1];
            return this.create(t2, e2);
          }
        } }]);
      }(), Et = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "filter", value: function(t2) {
        } }]);
      }(), Nt = function() {
        return s(function t2() {
          n(this, t2);
        }, null, [{ key: "ofLine", value: function(t2) {
          var e2 = t2.size();
          if (e2 <= 1) return 0;
          var n2 = 0, i2 = new X();
          t2.getCoordinate(0, i2);
          for (var r2 = i2.x, s2 = i2.y, a2 = 1; a2 < e2; a2++) {
            t2.getCoordinate(a2, i2);
            var o2 = i2.x, u3 = i2.y, l2 = o2 - r2, h2 = u3 - s2;
            n2 += Math.sqrt(l2 * l2 + h2 * h2), r2 = o2, s2 = u3;
          }
          return n2;
        } }]);
      }(), Tt = s(function t2() {
        n(this, t2);
      }), St = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "copyCoord", value: function(t3, e2, n2, i2) {
          for (var r2 = Math.min(t3.getDimension(), n2.getDimension()), s2 = 0; s2 < r2; s2++) n2.setOrdinate(i2, s2, t3.getOrdinate(e2, s2));
        } }, { key: "isRing", value: function(t3) {
          var e2 = t3.size();
          return 0 === e2 || !(e2 <= 3) && (t3.getOrdinate(0, ht.X) === t3.getOrdinate(e2 - 1, ht.X) && t3.getOrdinate(0, ht.Y) === t3.getOrdinate(e2 - 1, ht.Y));
        } }, { key: "scroll", value: function() {
          if (2 === arguments.length) {
            if (rt(arguments[0], ht) && Number.isInteger(arguments[1])) {
              var e2 = arguments[0], n2 = arguments[1];
              t2.scroll(e2, n2, t2.isRing(e2));
            } else if (rt(arguments[0], ht) && arguments[1] instanceof X) {
              var i2 = arguments[0], r2 = arguments[1], s2 = t2.indexOf(r2, i2);
              if (s2 <= 0) return null;
              t2.scroll(i2, s2);
            }
          } else if (3 === arguments.length) {
            var a2 = arguments[0], o2 = arguments[1], u3 = arguments[2];
            if (o2 <= 0) return null;
            for (var l2 = a2.copy(), h2 = u3 ? a2.size() - 1 : a2.size(), c2 = 0; c2 < h2; c2++) for (var f2 = 0; f2 < a2.getDimension(); f2++) a2.setOrdinate(c2, f2, l2.getOrdinate((o2 + c2) % h2, f2));
            if (u3) for (var g2 = 0; g2 < a2.getDimension(); g2++) a2.setOrdinate(h2, g2, a2.getOrdinate(0, g2));
          }
        } }, { key: "isEqual", value: function(t3, e2) {
          var n2 = t3.size();
          if (n2 !== e2.size()) return false;
          for (var i2 = Math.min(t3.getDimension(), e2.getDimension()), r2 = 0; r2 < n2; r2++) for (var s2 = 0; s2 < i2; s2++) {
            var a2 = t3.getOrdinate(r2, s2), o2 = e2.getOrdinate(r2, s2);
            if (t3.getOrdinate(r2, s2) !== e2.getOrdinate(r2, s2) && (!A.isNaN(a2) || !A.isNaN(o2))) return false;
          }
          return true;
        } }, { key: "minCoordinateIndex", value: function() {
          if (1 === arguments.length) {
            var e2 = arguments[0];
            return t2.minCoordinateIndex(e2, 0, e2.size() - 1);
          }
          if (3 === arguments.length) {
            for (var n2 = arguments[0], i2 = arguments[2], r2 = -1, s2 = null, a2 = arguments[1]; a2 <= i2; a2++) {
              var o2 = n2.getCoordinate(a2);
              (null === s2 || s2.compareTo(o2) > 0) && (s2 = o2, r2 = a2);
            }
            return r2;
          }
        } }, { key: "extend", value: function(e2, n2, i2) {
          var r2 = e2.create(i2, n2.getDimension()), s2 = n2.size();
          if (t2.copy(n2, 0, r2, 0, s2), s2 > 0) for (var a2 = s2; a2 < i2; a2++) t2.copy(n2, s2 - 1, r2, a2, 1);
          return r2;
        } }, { key: "reverse", value: function(e2) {
          for (var n2 = e2.size() - 1, i2 = Math.trunc(n2 / 2), r2 = 0; r2 <= i2; r2++) t2.swap(e2, r2, n2 - r2);
        } }, { key: "swap", value: function(t3, e2, n2) {
          if (e2 === n2) return null;
          for (var i2 = 0; i2 < t3.getDimension(); i2++) {
            var r2 = t3.getOrdinate(e2, i2);
            t3.setOrdinate(e2, i2, t3.getOrdinate(n2, i2)), t3.setOrdinate(n2, i2, r2);
          }
        } }, { key: "copy", value: function(e2, n2, i2, r2, s2) {
          for (var a2 = 0; a2 < s2; a2++) t2.copyCoord(e2, n2 + a2, i2, r2 + a2);
        } }, { key: "ensureValidRing", value: function(e2, n2) {
          var i2 = n2.size();
          return 0 === i2 ? n2 : i2 <= 3 ? t2.createClosedRing(e2, n2, 4) : n2.getOrdinate(0, ht.X) === n2.getOrdinate(i2 - 1, ht.X) && n2.getOrdinate(0, ht.Y) === n2.getOrdinate(i2 - 1, ht.Y) ? n2 : t2.createClosedRing(e2, n2, i2 + 1);
        } }, { key: "indexOf", value: function(t3, e2) {
          for (var n2 = 0; n2 < e2.size(); n2++) if (t3.x === e2.getOrdinate(n2, ht.X) && t3.y === e2.getOrdinate(n2, ht.Y)) return n2;
          return -1;
        } }, { key: "createClosedRing", value: function(e2, n2, i2) {
          var r2 = e2.create(i2, n2.getDimension()), s2 = n2.size();
          t2.copy(n2, 0, r2, 0, s2);
          for (var a2 = s2; a2 < i2; a2++) t2.copy(n2, 0, r2, a2, 1);
          return r2;
        } }, { key: "minCoordinate", value: function(t3) {
          for (var e2 = null, n2 = 0; n2 < t3.size(); n2++) {
            var i2 = t3.getCoordinate(n2);
            (null === e2 || e2.compareTo(i2) > 0) && (e2 = i2);
          }
          return e2;
        } }]);
      }(), Lt = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "toDimensionSymbol", value: function(e2) {
          switch (e2) {
            case t2.FALSE:
              return t2.SYM_FALSE;
            case t2.TRUE:
              return t2.SYM_TRUE;
            case t2.DONTCARE:
              return t2.SYM_DONTCARE;
            case t2.P:
              return t2.SYM_P;
            case t2.L:
              return t2.SYM_L;
            case t2.A:
              return t2.SYM_A;
          }
          throw new m("Unknown dimension value: " + e2);
        } }, { key: "toDimensionValue", value: function(e2) {
          switch (ot.toUpperCase(e2)) {
            case t2.SYM_FALSE:
              return t2.FALSE;
            case t2.SYM_TRUE:
              return t2.TRUE;
            case t2.SYM_DONTCARE:
              return t2.DONTCARE;
            case t2.SYM_P:
              return t2.P;
            case t2.SYM_L:
              return t2.L;
            case t2.SYM_A:
              return t2.A;
          }
          throw new m("Unknown dimension symbol: " + e2);
        } }]);
      }();
      Lt.P = 0, Lt.L = 1, Lt.A = 2, Lt.FALSE = -1, Lt.TRUE = -2, Lt.DONTCARE = -3, Lt.SYM_FALSE = "F", Lt.SYM_TRUE = "T", Lt.SYM_DONTCARE = "*", Lt.SYM_P = "0", Lt.SYM_L = "1", Lt.SYM_A = "2";
      var Ct = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "filter", value: function(t2) {
        } }]);
      }(), Rt = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "filter", value: function(t2, e2) {
        } }, { key: "isDone", value: function() {
        } }, { key: "isGeometryChanged", value: function() {
        } }]);
      }(), wt = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "computeEnvelopeInternal", value: function() {
          return this.isEmpty() ? new U() : this._points.expandEnvelope(new U());
        } }, { key: "isRing", value: function() {
          return this.isClosed() && this.isSimple();
        } }, { key: "getCoordinates", value: function() {
          return this._points.toCoordinateArray();
        } }, { key: "copyInternal", value: function() {
          return new i2(this._points.copy(), this._factory);
        } }, { key: "equalsExact", value: function() {
          if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
            var t3 = arguments[0], e2 = arguments[1];
            if (!this.isEquivalentClass(t3)) return false;
            var n2 = t3;
            if (this._points.size() !== n2._points.size()) return false;
            for (var r2 = 0; r2 < this._points.size(); r2++) if (!this.equal(this._points.getCoordinate(r2), n2._points.getCoordinate(r2), e2)) return false;
            return true;
          }
          return f(i2, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
          for (var t3 = 0; t3 < Math.trunc(this._points.size() / 2); t3++) {
            var e2 = this._points.size() - 1 - t3;
            if (!this._points.getCoordinate(t3).equals(this._points.getCoordinate(e2))) {
              if (this._points.getCoordinate(t3).compareTo(this._points.getCoordinate(e2)) > 0) {
                var n2 = this._points.copy();
                St.reverse(n2), this._points = n2;
              }
              return null;
            }
          }
        } }, { key: "getCoordinate", value: function() {
          return this.isEmpty() ? null : this._points.getCoordinate(0);
        } }, { key: "getBoundaryDimension", value: function() {
          return this.isClosed() ? Lt.FALSE : 0;
        } }, { key: "isClosed", value: function() {
          return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
        } }, { key: "reverseInternal", value: function() {
          var t3 = this._points.copy();
          return St.reverse(t3), this.getFactory().createLineString(t3);
        } }, { key: "getEndPoint", value: function() {
          return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
        } }, { key: "getTypeCode", value: function() {
          return V.TYPECODE_LINESTRING;
        } }, { key: "getDimension", value: function() {
          return 1;
        } }, { key: "getLength", value: function() {
          return Nt.ofLine(this._points);
        } }, { key: "getNumPoints", value: function() {
          return this._points.size();
        } }, { key: "compareToSameClass", value: function() {
          if (1 === arguments.length) {
            for (var t3 = arguments[0], e2 = 0, n2 = 0; e2 < this._points.size() && n2 < t3._points.size(); ) {
              var i3 = this._points.getCoordinate(e2).compareTo(t3._points.getCoordinate(n2));
              if (0 !== i3) return i3;
              e2++, n2++;
            }
            return e2 < this._points.size() ? 1 : n2 < t3._points.size() ? -1 : 0;
          }
          if (2 === arguments.length) {
            var r2 = arguments[0];
            return arguments[1].compare(this._points, r2._points);
          }
        } }, { key: "apply", value: function() {
          if (rt(arguments[0], Et)) for (var t3 = arguments[0], e2 = 0; e2 < this._points.size(); e2++) t3.filter(this._points.getCoordinate(e2));
          else if (rt(arguments[0], Rt)) {
            var n2 = arguments[0];
            if (0 === this._points.size()) return null;
            for (var i3 = 0; i3 < this._points.size() && (n2.filter(this._points, i3), !n2.isDone()); i3++) ;
            n2.isGeometryChanged() && this.geometryChanged();
          } else if (rt(arguments[0], Ct)) {
            arguments[0].filter(this);
          } else if (rt(arguments[0], k)) {
            arguments[0].filter(this);
          }
        } }, { key: "getBoundary", value: function() {
          throw new W();
        } }, { key: "isEquivalentClass", value: function(t3) {
          return t3 instanceof i2;
        } }, { key: "getCoordinateN", value: function(t3) {
          return this._points.getCoordinate(t3);
        } }, { key: "getGeometryType", value: function() {
          return V.TYPENAME_LINESTRING;
        } }, { key: "getCoordinateSequence", value: function() {
          return this._points;
        } }, { key: "isEmpty", value: function() {
          return 0 === this._points.size();
        } }, { key: "init", value: function(t3) {
          if (null === t3 && (t3 = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t3.size()) throw new m("Invalid number of points in LineString (found " + t3.size() + " - must be 0 or >= 2)");
          this._points = t3;
        } }, { key: "isCoordinate", value: function(t3) {
          for (var e2 = 0; e2 < this._points.size(); e2++) if (this._points.getCoordinate(e2).equals(t3)) return true;
          return false;
        } }, { key: "getStartPoint", value: function() {
          return this.isEmpty() ? null : this.getPointN(0);
        } }, { key: "getPointN", value: function(t3) {
          return this.getFactory().createPoint(this._points.getCoordinate(t3));
        } }, { key: "interfaces_", get: function() {
          return [Tt];
        } }], [{ key: "constructor_", value: function() {
          if (this._points = null, 0 === arguments.length) ;
          else if (2 === arguments.length) {
            var t3 = arguments[0], e2 = arguments[1];
            V.constructor_.call(this, e2), this.init(t3);
          }
        } }]);
      }(V), Ot = s(function t2() {
        n(this, t2);
      }), bt = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "computeEnvelopeInternal", value: function() {
          if (this.isEmpty()) return new U();
          var t3 = new U();
          return t3.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t3;
        } }, { key: "getCoordinates", value: function() {
          return this.isEmpty() ? [] : [this.getCoordinate()];
        } }, { key: "copyInternal", value: function() {
          return new i2(this._coordinates.copy(), this._factory);
        } }, { key: "equalsExact", value: function() {
          if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
            var t3 = arguments[0], e2 = arguments[1];
            return !!this.isEquivalentClass(t3) && (!(!this.isEmpty() || !t3.isEmpty()) || this.isEmpty() === t3.isEmpty() && this.equal(t3.getCoordinate(), this.getCoordinate(), e2));
          }
          return f(i2, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
        } }, { key: "getCoordinate", value: function() {
          return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null;
        } }, { key: "getBoundaryDimension", value: function() {
          return Lt.FALSE;
        } }, { key: "reverseInternal", value: function() {
          return this.getFactory().createPoint(this._coordinates.copy());
        } }, { key: "getTypeCode", value: function() {
          return V.TYPECODE_POINT;
        } }, { key: "getDimension", value: function() {
          return 0;
        } }, { key: "getNumPoints", value: function() {
          return this.isEmpty() ? 0 : 1;
        } }, { key: "getX", value: function() {
          if (null === this.getCoordinate()) throw new IllegalStateException("getX called on empty Point");
          return this.getCoordinate().x;
        } }, { key: "compareToSameClass", value: function() {
          if (1 === arguments.length) {
            var t3 = arguments[0];
            return this.getCoordinate().compareTo(t3.getCoordinate());
          }
          if (2 === arguments.length) {
            var e2 = arguments[0];
            return arguments[1].compare(this._coordinates, e2._coordinates);
          }
        } }, { key: "apply", value: function() {
          if (rt(arguments[0], Et)) {
            var t3 = arguments[0];
            if (this.isEmpty()) return null;
            t3.filter(this.getCoordinate());
          } else if (rt(arguments[0], Rt)) {
            var e2 = arguments[0];
            if (this.isEmpty()) return null;
            e2.filter(this._coordinates, 0), e2.isGeometryChanged() && this.geometryChanged();
          } else if (rt(arguments[0], Ct)) {
            arguments[0].filter(this);
          } else if (rt(arguments[0], k)) {
            arguments[0].filter(this);
          }
        } }, { key: "getBoundary", value: function() {
          return this.getFactory().createGeometryCollection();
        } }, { key: "getGeometryType", value: function() {
          return V.TYPENAME_POINT;
        } }, { key: "getCoordinateSequence", value: function() {
          return this._coordinates;
        } }, { key: "getY", value: function() {
          if (null === this.getCoordinate()) throw new IllegalStateException("getY called on empty Point");
          return this.getCoordinate().y;
        } }, { key: "isEmpty", value: function() {
          return 0 === this._coordinates.size();
        } }, { key: "init", value: function(t3) {
          null === t3 && (t3 = this.getFactory().getCoordinateSequenceFactory().create([])), G.isTrue(t3.size() <= 1), this._coordinates = t3;
        } }, { key: "isSimple", value: function() {
          return true;
        } }, { key: "interfaces_", get: function() {
          return [Ot];
        } }], [{ key: "constructor_", value: function() {
          this._coordinates = null;
          var t3 = arguments[0], e2 = arguments[1];
          V.constructor_.call(this, e2), this.init(t3);
        } }]);
      }(V), Mt = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "ofRing", value: function() {
          if (arguments[0] instanceof Array) {
            var e2 = arguments[0];
            return Math.abs(t2.ofRingSigned(e2));
          }
          if (rt(arguments[0], ht)) {
            var n2 = arguments[0];
            return Math.abs(t2.ofRingSigned(n2));
          }
        } }, { key: "ofRingSigned", value: function() {
          if (arguments[0] instanceof Array) {
            var t3 = arguments[0];
            if (t3.length < 3) return 0;
            for (var e2 = 0, n2 = t3[0].x, i2 = 1; i2 < t3.length - 1; i2++) {
              var r2 = t3[i2].x - n2, s2 = t3[i2 + 1].y;
              e2 += r2 * (t3[i2 - 1].y - s2);
            }
            return e2 / 2;
          }
          if (rt(arguments[0], ht)) {
            var a2 = arguments[0], o2 = a2.size();
            if (o2 < 3) return 0;
            var u3 = new X(), l2 = new X(), h2 = new X();
            a2.getCoordinate(0, l2), a2.getCoordinate(1, h2);
            var c2 = l2.x;
            h2.x -= c2;
            for (var f2 = 0, g2 = 1; g2 < o2 - 1; g2++) u3.y = l2.y, l2.x = h2.x, l2.y = h2.y, a2.getCoordinate(g2 + 1, h2), h2.x -= c2, f2 += l2.x * (u3.y - h2.y);
            return f2 / 2;
          }
        } }]);
      }(), At = function() {
        return s(function t2() {
          n(this, t2);
        }, null, [{ key: "sort", value: function() {
          var t2 = arguments, e2 = arguments[0];
          if (1 === arguments.length) e2.sort(function(t3, e3) {
            return t3.compareTo(e3);
          });
          else if (2 === arguments.length) e2.sort(function(e3, n3) {
            return t2[1].compare(e3, n3);
          });
          else if (3 === arguments.length) {
            var n2 = e2.slice(arguments[1], arguments[2]);
            n2.sort();
            var i2 = e2.slice(0, arguments[1]).concat(n2, e2.slice(arguments[2], e2.length));
            e2.splice(0, e2.length);
            var r2, s2 = a(i2);
            try {
              for (s2.s(); !(r2 = s2.n()).done; ) {
                var o2 = r2.value;
                e2.push(o2);
              }
            } catch (t3) {
              s2.e(t3);
            } finally {
              s2.f();
            }
          } else if (4 === arguments.length) {
            var u3 = e2.slice(arguments[1], arguments[2]);
            u3.sort(function(e3, n3) {
              return t2[3].compare(e3, n3);
            });
            var l2 = e2.slice(0, arguments[1]).concat(u3, e2.slice(arguments[2], e2.length));
            e2.splice(0, e2.length);
            var h2, c2 = a(l2);
            try {
              for (c2.s(); !(h2 = c2.n()).done; ) {
                var f2 = h2.value;
                e2.push(f2);
              }
            } catch (t3) {
              c2.e(t3);
            } finally {
              c2.f();
            }
          }
        } }, { key: "asList", value: function(t2) {
          var e2, n2 = new yt(), i2 = a(t2);
          try {
            for (i2.s(); !(e2 = i2.n()).done; ) {
              var r2 = e2.value;
              n2.add(r2);
            }
          } catch (t3) {
            i2.e(t3);
          } finally {
            i2.f();
          }
          return n2;
        } }, { key: "copyOf", value: function(t2, e2) {
          return t2.slice(0, e2);
        } }]);
      }(), Pt = s(function t2() {
        n(this, t2);
      }), Dt = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "computeEnvelopeInternal", value: function() {
          return this._shell.getEnvelopeInternal();
        } }, { key: "getCoordinates", value: function() {
          if (this.isEmpty()) return [];
          for (var t3 = new Array(this.getNumPoints()).fill(null), e2 = -1, n2 = this._shell.getCoordinates(), i3 = 0; i3 < n2.length; i3++) t3[++e2] = n2[i3];
          for (var r2 = 0; r2 < this._holes.length; r2++) for (var s2 = this._holes[r2].getCoordinates(), a2 = 0; a2 < s2.length; a2++) t3[++e2] = s2[a2];
          return t3;
        } }, { key: "getArea", value: function() {
          var t3 = 0;
          t3 += Mt.ofRing(this._shell.getCoordinateSequence());
          for (var e2 = 0; e2 < this._holes.length; e2++) t3 -= Mt.ofRing(this._holes[e2].getCoordinateSequence());
          return t3;
        } }, { key: "copyInternal", value: function() {
          for (var t3 = this._shell.copy(), e2 = new Array(this._holes.length).fill(null), n2 = 0; n2 < this._holes.length; n2++) e2[n2] = this._holes[n2].copy();
          return new i2(t3, e2, this._factory);
        } }, { key: "isRectangle", value: function() {
          if (0 !== this.getNumInteriorRing()) return false;
          if (null === this._shell) return false;
          if (5 !== this._shell.getNumPoints()) return false;
          for (var t3 = this._shell.getCoordinateSequence(), e2 = this.getEnvelopeInternal(), n2 = 0; n2 < 5; n2++) {
            var i3 = t3.getX(n2);
            if (i3 !== e2.getMinX() && i3 !== e2.getMaxX()) return false;
            var r2 = t3.getY(n2);
            if (r2 !== e2.getMinY() && r2 !== e2.getMaxY()) return false;
          }
          for (var s2 = t3.getX(0), a2 = t3.getY(0), o2 = 1; o2 <= 4; o2++) {
            var u3 = t3.getX(o2), l2 = t3.getY(o2);
            if (u3 !== s2 === (l2 !== a2)) return false;
            s2 = u3, a2 = l2;
          }
          return true;
        } }, { key: "equalsExact", value: function() {
          if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
            var t3 = arguments[0], e2 = arguments[1];
            if (!this.isEquivalentClass(t3)) return false;
            var n2 = t3, r2 = this._shell, s2 = n2._shell;
            if (!r2.equalsExact(s2, e2)) return false;
            if (this._holes.length !== n2._holes.length) return false;
            for (var a2 = 0; a2 < this._holes.length; a2++) if (!this._holes[a2].equalsExact(n2._holes[a2], e2)) return false;
            return true;
          }
          return f(i2, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
          if (0 === arguments.length) {
            this._shell = this.normalized(this._shell, true);
            for (var t3 = 0; t3 < this._holes.length; t3++) this._holes[t3] = this.normalized(this._holes[t3], false);
            At.sort(this._holes);
          } else if (2 === arguments.length) {
            var e2 = arguments[0], n2 = arguments[1];
            if (e2.isEmpty()) return null;
            var i3 = e2.getCoordinateSequence(), r2 = St.minCoordinateIndex(i3, 0, i3.size() - 2);
            St.scroll(i3, r2, true), ct.isCCW(i3) === n2 && St.reverse(i3);
          }
        } }, { key: "getCoordinate", value: function() {
          return this._shell.getCoordinate();
        } }, { key: "getNumInteriorRing", value: function() {
          return this._holes.length;
        } }, { key: "getBoundaryDimension", value: function() {
          return 1;
        } }, { key: "reverseInternal", value: function() {
          for (var t3 = this.getExteriorRing().reverse(), e2 = new Array(this.getNumInteriorRing()).fill(null), n2 = 0; n2 < e2.length; n2++) e2[n2] = this.getInteriorRingN(n2).reverse();
          return this.getFactory().createPolygon(t3, e2);
        } }, { key: "getTypeCode", value: function() {
          return V.TYPECODE_POLYGON;
        } }, { key: "getDimension", value: function() {
          return 2;
        } }, { key: "getLength", value: function() {
          var t3 = 0;
          t3 += this._shell.getLength();
          for (var e2 = 0; e2 < this._holes.length; e2++) t3 += this._holes[e2].getLength();
          return t3;
        } }, { key: "getNumPoints", value: function() {
          for (var t3 = this._shell.getNumPoints(), e2 = 0; e2 < this._holes.length; e2++) t3 += this._holes[e2].getNumPoints();
          return t3;
        } }, { key: "convexHull", value: function() {
          return this.getExteriorRing().convexHull();
        } }, { key: "normalized", value: function(t3, e2) {
          var n2 = t3.copy();
          return this.normalize(n2, e2), n2;
        } }, { key: "compareToSameClass", value: function() {
          if (1 === arguments.length) {
            var t3 = arguments[0], e2 = this._shell, n2 = t3._shell;
            return e2.compareToSameClass(n2);
          }
          if (2 === arguments.length) {
            var i3 = arguments[1], r2 = arguments[0], s2 = this._shell, a2 = r2._shell, o2 = s2.compareToSameClass(a2, i3);
            if (0 !== o2) return o2;
            for (var u3 = this.getNumInteriorRing(), l2 = r2.getNumInteriorRing(), h2 = 0; h2 < u3 && h2 < l2; ) {
              var c2 = this.getInteriorRingN(h2), f2 = r2.getInteriorRingN(h2), g2 = c2.compareToSameClass(f2, i3);
              if (0 !== g2) return g2;
              h2++;
            }
            return h2 < u3 ? 1 : h2 < l2 ? -1 : 0;
          }
        } }, { key: "apply", value: function() {
          if (rt(arguments[0], Et)) {
            var t3 = arguments[0];
            this._shell.apply(t3);
            for (var e2 = 0; e2 < this._holes.length; e2++) this._holes[e2].apply(t3);
          } else if (rt(arguments[0], Rt)) {
            var n2 = arguments[0];
            if (this._shell.apply(n2), !n2.isDone()) for (var i3 = 0; i3 < this._holes.length && (this._holes[i3].apply(n2), !n2.isDone()); i3++) ;
            n2.isGeometryChanged() && this.geometryChanged();
          } else if (rt(arguments[0], Ct)) {
            arguments[0].filter(this);
          } else if (rt(arguments[0], k)) {
            var r2 = arguments[0];
            r2.filter(this), this._shell.apply(r2);
            for (var s2 = 0; s2 < this._holes.length; s2++) this._holes[s2].apply(r2);
          }
        } }, { key: "getBoundary", value: function() {
          if (this.isEmpty()) return this.getFactory().createMultiLineString();
          var t3 = new Array(this._holes.length + 1).fill(null);
          t3[0] = this._shell;
          for (var e2 = 0; e2 < this._holes.length; e2++) t3[e2 + 1] = this._holes[e2];
          return t3.length <= 1 ? this.getFactory().createLinearRing(t3[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t3);
        } }, { key: "getGeometryType", value: function() {
          return V.TYPENAME_POLYGON;
        } }, { key: "getExteriorRing", value: function() {
          return this._shell;
        } }, { key: "isEmpty", value: function() {
          return this._shell.isEmpty();
        } }, { key: "getInteriorRingN", value: function(t3) {
          return this._holes[t3];
        } }, { key: "interfaces_", get: function() {
          return [Pt];
        } }], [{ key: "constructor_", value: function() {
          this._shell = null, this._holes = null;
          var t3 = arguments[0], e2 = arguments[1], n2 = arguments[2];
          if (V.constructor_.call(this, n2), null === t3 && (t3 = this.getFactory().createLinearRing()), null === e2 && (e2 = []), V.hasNullElements(e2)) throw new m("holes must not contain null elements");
          if (t3.isEmpty() && V.hasNonEmptyElements(e2)) throw new m("shell is empty but holes are not");
          this._shell = t3, this._holes = e2;
        } }]);
      }(V), Ft = function(t2) {
        function i2() {
          return n(this, i2), e(this, i2, arguments);
        }
        return l(i2, t2), s(i2);
      }(K), Gt = function(t2) {
        function i2(t3) {
          var r2;
          return n(this, i2), (r2 = e(this, i2)).array = [], t3 instanceof Z && r2.addAll(t3), r2;
        }
        return l(i2, t2), s(i2, [{ key: "contains", value: function(t3) {
          var e2, n2 = a(this.array);
          try {
            for (n2.s(); !(e2 = n2.n()).done; ) {
              if (0 === e2.value.compareTo(t3)) return true;
            }
          } catch (t4) {
            n2.e(t4);
          } finally {
            n2.f();
          }
          return false;
        } }, { key: "add", value: function(t3) {
          if (this.contains(t3)) return false;
          for (var e2 = 0, n2 = this.array.length; e2 < n2; e2++) {
            if (1 === this.array[e2].compareTo(t3)) return !!this.array.splice(e2, 0, t3);
          }
          return this.array.push(t3), true;
        } }, { key: "addAll", value: function(t3) {
          var e2, n2 = a(t3);
          try {
            for (n2.s(); !(e2 = n2.n()).done; ) {
              var i3 = e2.value;
              this.add(i3);
            }
          } catch (t4) {
            n2.e(t4);
          } finally {
            n2.f();
          }
          return true;
        } }, { key: "remove", value: function() {
          throw new W();
        } }, { key: "size", value: function() {
          return this.array.length;
        } }, { key: "isEmpty", value: function() {
          return 0 === this.array.length;
        } }, { key: "toArray", value: function() {
          return this.array.slice();
        } }, { key: "iterator", value: function() {
          return new qt(this.array);
        } }]);
      }(Ft), qt = function() {
        return s(function t2(e2) {
          n(this, t2), this.array = e2, this.position = 0;
        }, [{ key: "next", value: function() {
          if (this.position === this.array.length) throw new j();
          return this.array[this.position++];
        } }, { key: "hasNext", value: function() {
          return this.position < this.array.length;
        } }, { key: "remove", value: function() {
          throw new W();
        } }]);
      }(), Yt = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "computeEnvelopeInternal", value: function() {
          for (var t3 = new U(), e2 = 0; e2 < this._geometries.length; e2++) t3.expandToInclude(this._geometries[e2].getEnvelopeInternal());
          return t3;
        } }, { key: "getGeometryN", value: function(t3) {
          return this._geometries[t3];
        } }, { key: "getCoordinates", value: function() {
          for (var t3 = new Array(this.getNumPoints()).fill(null), e2 = -1, n2 = 0; n2 < this._geometries.length; n2++) for (var i3 = this._geometries[n2].getCoordinates(), r2 = 0; r2 < i3.length; r2++) t3[++e2] = i3[r2];
          return t3;
        } }, { key: "getArea", value: function() {
          for (var t3 = 0, e2 = 0; e2 < this._geometries.length; e2++) t3 += this._geometries[e2].getArea();
          return t3;
        } }, { key: "copyInternal", value: function() {
          for (var t3 = new Array(this._geometries.length).fill(null), e2 = 0; e2 < t3.length; e2++) t3[e2] = this._geometries[e2].copy();
          return new i2(t3, this._factory);
        } }, { key: "equalsExact", value: function() {
          if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
            var t3 = arguments[0], e2 = arguments[1];
            if (!this.isEquivalentClass(t3)) return false;
            var n2 = t3;
            if (this._geometries.length !== n2._geometries.length) return false;
            for (var r2 = 0; r2 < this._geometries.length; r2++) if (!this._geometries[r2].equalsExact(n2._geometries[r2], e2)) return false;
            return true;
          }
          return f(i2, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
          for (var t3 = 0; t3 < this._geometries.length; t3++) this._geometries[t3].normalize();
          At.sort(this._geometries);
        } }, { key: "getCoordinate", value: function() {
          return this.isEmpty() ? null : this._geometries[0].getCoordinate();
        } }, { key: "getBoundaryDimension", value: function() {
          for (var t3 = Lt.FALSE, e2 = 0; e2 < this._geometries.length; e2++) t3 = Math.max(t3, this._geometries[e2].getBoundaryDimension());
          return t3;
        } }, { key: "reverseInternal", value: function() {
          for (var t3 = this._geometries.length, e2 = new yt(t3), n2 = 0; n2 < t3; n2++) e2.add(this._geometries[n2].reverse());
          return this.getFactory().buildGeometry(e2);
        } }, { key: "getTypeCode", value: function() {
          return V.TYPECODE_GEOMETRYCOLLECTION;
        } }, { key: "getDimension", value: function() {
          for (var t3 = Lt.FALSE, e2 = 0; e2 < this._geometries.length; e2++) t3 = Math.max(t3, this._geometries[e2].getDimension());
          return t3;
        } }, { key: "getLength", value: function() {
          for (var t3 = 0, e2 = 0; e2 < this._geometries.length; e2++) t3 += this._geometries[e2].getLength();
          return t3;
        } }, { key: "getNumPoints", value: function() {
          for (var t3 = 0, e2 = 0; e2 < this._geometries.length; e2++) t3 += this._geometries[e2].getNumPoints();
          return t3;
        } }, { key: "getNumGeometries", value: function() {
          return this._geometries.length;
        } }, { key: "compareToSameClass", value: function() {
          if (1 === arguments.length) {
            var t3 = arguments[0], e2 = new Gt(At.asList(this._geometries)), n2 = new Gt(At.asList(t3._geometries));
            return this.compare(e2, n2);
          }
          if (2 === arguments.length) {
            for (var i3 = arguments[1], r2 = arguments[0], s2 = this.getNumGeometries(), a2 = r2.getNumGeometries(), o2 = 0; o2 < s2 && o2 < a2; ) {
              var u3 = this.getGeometryN(o2), l2 = r2.getGeometryN(o2), h2 = u3.compareToSameClass(l2, i3);
              if (0 !== h2) return h2;
              o2++;
            }
            return o2 < s2 ? 1 : o2 < a2 ? -1 : 0;
          }
        } }, { key: "apply", value: function() {
          if (rt(arguments[0], Et)) for (var t3 = arguments[0], e2 = 0; e2 < this._geometries.length; e2++) this._geometries[e2].apply(t3);
          else if (rt(arguments[0], Rt)) {
            var n2 = arguments[0];
            if (0 === this._geometries.length) return null;
            for (var i3 = 0; i3 < this._geometries.length && (this._geometries[i3].apply(n2), !n2.isDone()); i3++) ;
            n2.isGeometryChanged() && this.geometryChanged();
          } else if (rt(arguments[0], Ct)) {
            var r2 = arguments[0];
            r2.filter(this);
            for (var s2 = 0; s2 < this._geometries.length; s2++) this._geometries[s2].apply(r2);
          } else if (rt(arguments[0], k)) {
            var a2 = arguments[0];
            a2.filter(this);
            for (var o2 = 0; o2 < this._geometries.length; o2++) this._geometries[o2].apply(a2);
          }
        } }, { key: "getBoundary", value: function() {
          return V.checkNotGeometryCollection(this), G.shouldNeverReachHere(), null;
        } }, { key: "getGeometryType", value: function() {
          return V.TYPENAME_GEOMETRYCOLLECTION;
        } }, { key: "isEmpty", value: function() {
          for (var t3 = 0; t3 < this._geometries.length; t3++) if (!this._geometries[t3].isEmpty()) return false;
          return true;
        } }], [{ key: "constructor_", value: function() {
          if (this._geometries = null, 0 === arguments.length) ;
          else if (2 === arguments.length) {
            var t3 = arguments[0], e2 = arguments[1];
            if (V.constructor_.call(this, e2), null === t3 && (t3 = []), V.hasNullElements(t3)) throw new m("geometries must not contain null elements");
            this._geometries = t3;
          }
        } }]);
      }(V), zt = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "copyInternal", value: function() {
          for (var t3 = new Array(this._geometries.length).fill(null), e2 = 0; e2 < t3.length; e2++) t3[e2] = this._geometries[e2].copy();
          return new i2(t3, this._factory);
        } }, { key: "isValid", value: function() {
          return true;
        } }, { key: "equalsExact", value: function() {
          if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
            var t3 = arguments[0], e2 = arguments[1];
            return !!this.isEquivalentClass(t3) && f(i2, "equalsExact", this, 1).call(this, t3, e2);
          }
          return f(i2, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "getCoordinate", value: function() {
          if (1 === arguments.length && Number.isInteger(arguments[0])) {
            var t3 = arguments[0];
            return this._geometries[t3].getCoordinate();
          }
          return f(i2, "getCoordinate", this, 1).apply(this, arguments);
        } }, { key: "getBoundaryDimension", value: function() {
          return Lt.FALSE;
        } }, { key: "getTypeCode", value: function() {
          return V.TYPECODE_MULTIPOINT;
        } }, { key: "getDimension", value: function() {
          return 0;
        } }, { key: "getBoundary", value: function() {
          return this.getFactory().createGeometryCollection();
        } }, { key: "getGeometryType", value: function() {
          return V.TYPENAME_MULTIPOINT;
        } }, { key: "interfaces_", get: function() {
          return [Ot];
        } }], [{ key: "constructor_", value: function() {
          var t3 = arguments[0], e2 = arguments[1];
          Yt.constructor_.call(this, t3, e2);
        } }]);
      }(Yt), Xt = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "copyInternal", value: function() {
          return new i2(this._points.copy(), this._factory);
        } }, { key: "getBoundaryDimension", value: function() {
          return Lt.FALSE;
        } }, { key: "isClosed", value: function() {
          return !!this.isEmpty() || f(i2, "isClosed", this, 1).call(this);
        } }, { key: "reverseInternal", value: function() {
          var t3 = this._points.copy();
          return St.reverse(t3), this.getFactory().createLinearRing(t3);
        } }, { key: "getTypeCode", value: function() {
          return V.TYPECODE_LINEARRING;
        } }, { key: "validateConstruction", value: function() {
          if (!this.isEmpty() && !f(i2, "isClosed", this, 1).call(this)) throw new m("Points of LinearRing do not form a closed linestring");
          if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < i2.MINIMUM_VALID_SIZE) throw new m("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
        } }, { key: "getGeometryType", value: function() {
          return V.TYPENAME_LINEARRING;
        } }], [{ key: "constructor_", value: function() {
          var t3 = arguments[0], e2 = arguments[1];
          wt.constructor_.call(this, t3, e2), this.validateConstruction();
        } }]);
      }(wt);
      Xt.MINIMUM_VALID_SIZE = 4;
      var Bt = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "setOrdinate", value: function(t3, e2) {
          switch (t3) {
            case i2.X:
              this.x = e2;
              break;
            case i2.Y:
              this.y = e2;
              break;
            default:
              throw new m("Invalid ordinate index: " + t3);
          }
        } }, { key: "getZ", value: function() {
          return X.NULL_ORDINATE;
        } }, { key: "getOrdinate", value: function(t3) {
          switch (t3) {
            case i2.X:
              return this.x;
            case i2.Y:
              return this.y;
          }
          throw new m("Invalid ordinate index: " + t3);
        } }, { key: "setZ", value: function(t3) {
          throw new m("CoordinateXY dimension 2 does not support z-ordinate");
        } }, { key: "copy", value: function() {
          return new i2(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + ")";
        } }, { key: "setCoordinate", value: function(t3) {
          this.x = t3.x, this.y = t3.y, this.z = t3.getZ();
        } }], [{ key: "constructor_", value: function() {
          if (0 === arguments.length) X.constructor_.call(this);
          else if (1 === arguments.length) {
            if (arguments[0] instanceof i2) {
              var t3 = arguments[0];
              X.constructor_.call(this, t3.x, t3.y);
            } else if (arguments[0] instanceof X) {
              var e2 = arguments[0];
              X.constructor_.call(this, e2.x, e2.y);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], r2 = arguments[1];
            X.constructor_.call(this, n2, r2, X.NULL_ORDINATE);
          }
        } }]);
      }(X);
      Bt.X = 0, Bt.Y = 1, Bt.Z = -1, Bt.M = -1;
      var Ut = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "getM", value: function() {
          return this._m;
        } }, { key: "setOrdinate", value: function(t3, e2) {
          switch (t3) {
            case i2.X:
              this.x = e2;
              break;
            case i2.Y:
              this.y = e2;
              break;
            case i2.M:
              this._m = e2;
              break;
            default:
              throw new m("Invalid ordinate index: " + t3);
          }
        } }, { key: "setM", value: function(t3) {
          this._m = t3;
        } }, { key: "getZ", value: function() {
          return X.NULL_ORDINATE;
        } }, { key: "getOrdinate", value: function(t3) {
          switch (t3) {
            case i2.X:
              return this.x;
            case i2.Y:
              return this.y;
            case i2.M:
              return this._m;
          }
          throw new m("Invalid ordinate index: " + t3);
        } }, { key: "setZ", value: function(t3) {
          throw new m("CoordinateXY dimension 2 does not support z-ordinate");
        } }, { key: "copy", value: function() {
          return new i2(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + " m=" + this.getM() + ")";
        } }, { key: "setCoordinate", value: function(t3) {
          this.x = t3.x, this.y = t3.y, this.z = t3.getZ(), this._m = t3.getM();
        } }], [{ key: "constructor_", value: function() {
          if (this._m = null, 0 === arguments.length) X.constructor_.call(this), this._m = 0;
          else if (1 === arguments.length) {
            if (arguments[0] instanceof i2) {
              var t3 = arguments[0];
              X.constructor_.call(this, t3.x, t3.y), this._m = t3._m;
            } else if (arguments[0] instanceof X) {
              var e2 = arguments[0];
              X.constructor_.call(this, e2.x, e2.y), this._m = this.getM();
            }
          } else if (3 === arguments.length) {
            var n2 = arguments[0], r2 = arguments[1], s2 = arguments[2];
            X.constructor_.call(this, n2, r2, X.NULL_ORDINATE), this._m = s2;
          }
        } }]);
      }(X);
      Ut.X = 0, Ut.Y = 1, Ut.Z = -1, Ut.M = 2;
      var Vt = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "getM", value: function() {
          return this._m;
        } }, { key: "setOrdinate", value: function(t3, e2) {
          switch (t3) {
            case X.X:
              this.x = e2;
              break;
            case X.Y:
              this.y = e2;
              break;
            case X.Z:
              this.z = e2;
              break;
            case X.M:
              this._m = e2;
              break;
            default:
              throw new m("Invalid ordinate index: " + t3);
          }
        } }, { key: "setM", value: function(t3) {
          this._m = t3;
        } }, { key: "getOrdinate", value: function(t3) {
          switch (t3) {
            case X.X:
              return this.x;
            case X.Y:
              return this.y;
            case X.Z:
              return this.getZ();
            case X.M:
              return this.getM();
          }
          throw new m("Invalid ordinate index: " + t3);
        } }, { key: "copy", value: function() {
          return new i2(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + ", " + this.getZ() + " m=" + this.getM() + ")";
        } }, { key: "setCoordinate", value: function(t3) {
          this.x = t3.x, this.y = t3.y, this.z = t3.getZ(), this._m = t3.getM();
        } }], [{ key: "constructor_", value: function() {
          if (this._m = null, 0 === arguments.length) X.constructor_.call(this), this._m = 0;
          else if (1 === arguments.length) {
            if (arguments[0] instanceof i2) {
              var t3 = arguments[0];
              X.constructor_.call(this, t3), this._m = t3._m;
            } else if (arguments[0] instanceof X) {
              var e2 = arguments[0];
              X.constructor_.call(this, e2), this._m = this.getM();
            }
          } else if (4 === arguments.length) {
            var n2 = arguments[0], r2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
            X.constructor_.call(this, n2, r2, s2), this._m = a2;
          }
        } }]);
      }(X), Ht = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "measures", value: function(t3) {
          return t3 instanceof Bt ? 0 : t3 instanceof Ut || t3 instanceof Vt ? 1 : 0;
        } }, { key: "dimension", value: function(t3) {
          return t3 instanceof Bt ? 2 : t3 instanceof Ut ? 3 : t3 instanceof Vt ? 4 : 3;
        } }, { key: "create", value: function() {
          if (1 === arguments.length) {
            var e2 = arguments[0];
            return t2.create(e2, 0);
          }
          if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return 2 === n2 ? new Bt() : 3 === n2 && 0 === i2 ? new X() : 3 === n2 && 1 === i2 ? new Ut() : 4 === n2 && 1 === i2 ? new Vt() : new X();
          }
        } }]);
      }(), Zt = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "getCoordinate", value: function(t3) {
          return this.get(t3);
        } }, { key: "addAll", value: function() {
          if (2 === arguments.length && "boolean" == typeof arguments[1] && rt(arguments[0], Z)) {
            for (var t3 = arguments[1], e2 = false, n2 = arguments[0].iterator(); n2.hasNext(); ) this.add(n2.next(), t3), e2 = true;
            return e2;
          }
          return f(i2, "addAll", this, 1).apply(this, arguments);
        } }, { key: "clone", value: function() {
          for (var t3 = f(i2, "clone", this, 1).call(this), e2 = 0; e2 < this.size(); e2++) t3.add(e2, this.get(e2).clone());
          return t3;
        } }, { key: "toCoordinateArray", value: function() {
          if (0 === arguments.length) return this.toArray(i2.coordArrayType);
          if (1 === arguments.length) {
            if (arguments[0]) return this.toArray(i2.coordArrayType);
            for (var t3 = this.size(), e2 = new Array(t3).fill(null), n2 = 0; n2 < t3; n2++) e2[n2] = this.get(t3 - n2 - 1);
            return e2;
          }
        } }, { key: "add", value: function() {
          if (1 === arguments.length) {
            var t3 = arguments[0];
            return f(i2, "add", this, 1).call(this, t3);
          }
          if (2 === arguments.length) {
            if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
              var e2 = arguments[0], n2 = arguments[1];
              return this.add(e2, n2, true), true;
            }
            if (arguments[0] instanceof X && "boolean" == typeof arguments[1]) {
              var r2 = arguments[0];
              if (!arguments[1] && this.size() >= 1) {
                if (this.get(this.size() - 1).equals2D(r2)) return null;
              }
              f(i2, "add", this, 1).call(this, r2);
            } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) {
              var s2 = arguments[0], a2 = arguments[1];
              return this.add(s2, a2), true;
            }
          } else if (3 === arguments.length) {
            if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
              var o2 = arguments[0], u3 = arguments[1];
              if (arguments[2]) for (var l2 = 0; l2 < o2.length; l2++) this.add(o2[l2], u3);
              else for (var h2 = o2.length - 1; h2 >= 0; h2--) this.add(o2[h2], u3);
              return true;
            }
            if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof X) {
              var c2 = arguments[0], g2 = arguments[1];
              if (!arguments[2]) {
                var v2 = this.size();
                if (v2 > 0) {
                  if (c2 > 0) {
                    if (this.get(c2 - 1).equals2D(g2)) return null;
                  }
                  if (c2 < v2) {
                    if (this.get(c2).equals2D(g2)) return null;
                  }
                }
              }
              f(i2, "add", this, 1).call(this, c2, g2);
            }
          } else if (4 === arguments.length) {
            var y2 = arguments[0], d2 = arguments[1], _2 = arguments[2], p2 = arguments[3], m2 = 1;
            _2 > p2 && (m2 = -1);
            for (var k2 = _2; k2 !== p2; k2 += m2) this.add(y2[k2], d2);
            return true;
          }
        } }, { key: "closeRing", value: function() {
          if (this.size() > 0) {
            var t3 = this.get(0).copy();
            this.add(t3, false);
          }
        } }], [{ key: "constructor_", value: function() {
          if (0 === arguments.length) ;
          else if (1 === arguments.length) {
            var t3 = arguments[0];
            this.ensureCapacity(t3.length), this.add(t3, true);
          } else if (2 === arguments.length) {
            var e2 = arguments[0], n2 = arguments[1];
            this.ensureCapacity(e2.length), this.add(e2, n2);
          }
        } }]);
      }(yt);
      Zt.coordArrayType = new Array(0).fill(null);
      var jt = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "isRing", value: function(t3) {
          return !(t3.length < 4) && !!t3[0].equals2D(t3[t3.length - 1]);
        } }, { key: "ptNotInList", value: function(e2, n2) {
          for (var i2 = 0; i2 < e2.length; i2++) {
            var r2 = e2[i2];
            if (t2.indexOf(r2, n2) < 0) return r2;
          }
          return null;
        } }, { key: "scroll", value: function(e2, n2) {
          var i2 = t2.indexOf(n2, e2);
          if (i2 < 0) return null;
          var r2 = new Array(e2.length).fill(null);
          mt.arraycopy(e2, i2, r2, 0, e2.length - i2), mt.arraycopy(e2, 0, r2, e2.length - i2, i2), mt.arraycopy(r2, 0, e2, 0, e2.length);
        } }, { key: "equals", value: function() {
          if (2 === arguments.length) {
            var t3 = arguments[0], e2 = arguments[1];
            if (t3 === e2) return true;
            if (null === t3 || null === e2) return false;
            if (t3.length !== e2.length) return false;
            for (var n2 = 0; n2 < t3.length; n2++) if (!t3[n2].equals(e2[n2])) return false;
            return true;
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], s2 = arguments[2];
            if (i2 === r2) return true;
            if (null === i2 || null === r2) return false;
            if (i2.length !== r2.length) return false;
            for (var a2 = 0; a2 < i2.length; a2++) if (0 !== s2.compare(i2[a2], r2[a2])) return false;
            return true;
          }
        } }, { key: "intersection", value: function(t3, e2) {
          for (var n2 = new Zt(), i2 = 0; i2 < t3.length; i2++) e2.intersects(t3[i2]) && n2.add(t3[i2], true);
          return n2.toCoordinateArray();
        } }, { key: "measures", value: function(t3) {
          if (null === t3 || 0 === t3.length) return 0;
          var e2, n2 = 0, i2 = a(t3);
          try {
            for (i2.s(); !(e2 = i2.n()).done; ) {
              var r2 = e2.value;
              n2 = Math.max(n2, Ht.measures(r2));
            }
          } catch (t4) {
            i2.e(t4);
          } finally {
            i2.f();
          }
          return n2;
        } }, { key: "hasRepeatedPoints", value: function(t3) {
          for (var e2 = 1; e2 < t3.length; e2++) if (t3[e2 - 1].equals(t3[e2])) return true;
          return false;
        } }, { key: "removeRepeatedPoints", value: function(e2) {
          return t2.hasRepeatedPoints(e2) ? new Zt(e2, false).toCoordinateArray() : e2;
        } }, { key: "reverse", value: function(t3) {
          for (var e2 = t3.length - 1, n2 = Math.trunc(e2 / 2), i2 = 0; i2 <= n2; i2++) {
            var r2 = t3[i2];
            t3[i2] = t3[e2 - i2], t3[e2 - i2] = r2;
          }
        } }, { key: "removeNull", value: function(t3) {
          for (var e2 = 0, n2 = 0; n2 < t3.length; n2++) null !== t3[n2] && e2++;
          var i2 = new Array(e2).fill(null);
          if (0 === e2) return i2;
          for (var r2 = 0, s2 = 0; s2 < t3.length; s2++) null !== t3[s2] && (i2[r2++] = t3[s2]);
          return i2;
        } }, { key: "copyDeep", value: function() {
          if (1 === arguments.length) {
            for (var t3 = arguments[0], e2 = new Array(t3.length).fill(null), n2 = 0; n2 < t3.length; n2++) e2[n2] = t3[n2].copy();
            return e2;
          }
          if (5 === arguments.length) for (var i2 = arguments[0], r2 = arguments[1], s2 = arguments[2], a2 = arguments[3], o2 = arguments[4], u3 = 0; u3 < o2; u3++) s2[a2 + u3] = i2[r2 + u3].copy();
        } }, { key: "isEqualReversed", value: function(t3, e2) {
          for (var n2 = 0; n2 < t3.length; n2++) {
            var i2 = t3[n2], r2 = e2[t3.length - n2 - 1];
            if (0 !== i2.compareTo(r2)) return false;
          }
          return true;
        } }, { key: "envelope", value: function(t3) {
          for (var e2 = new U(), n2 = 0; n2 < t3.length; n2++) e2.expandToInclude(t3[n2]);
          return e2;
        } }, { key: "toCoordinateArray", value: function(e2) {
          return e2.toArray(t2.coordArrayType);
        } }, { key: "dimension", value: function(t3) {
          if (null === t3 || 0 === t3.length) return 3;
          var e2, n2 = 0, i2 = a(t3);
          try {
            for (i2.s(); !(e2 = i2.n()).done; ) {
              var r2 = e2.value;
              n2 = Math.max(n2, Ht.dimension(r2));
            }
          } catch (t4) {
            i2.e(t4);
          } finally {
            i2.f();
          }
          return n2;
        } }, { key: "atLeastNCoordinatesOrNothing", value: function(t3, e2) {
          return e2.length >= t3 ? e2 : [];
        } }, { key: "indexOf", value: function(t3, e2) {
          for (var n2 = 0; n2 < e2.length; n2++) if (t3.equals(e2[n2])) return n2;
          return -1;
        } }, { key: "increasingDirection", value: function(t3) {
          for (var e2 = 0; e2 < Math.trunc(t3.length / 2); e2++) {
            var n2 = t3.length - 1 - e2, i2 = t3[e2].compareTo(t3[n2]);
            if (0 !== i2) return i2;
          }
          return 1;
        } }, { key: "compare", value: function(t3, e2) {
          for (var n2 = 0; n2 < t3.length && n2 < e2.length; ) {
            var i2 = t3[n2].compareTo(e2[n2]);
            if (0 !== i2) return i2;
            n2++;
          }
          return n2 < e2.length ? -1 : n2 < t3.length ? 1 : 0;
        } }, { key: "minCoordinate", value: function(t3) {
          for (var e2 = null, n2 = 0; n2 < t3.length; n2++) (null === e2 || e2.compareTo(t3[n2]) > 0) && (e2 = t3[n2]);
          return e2;
        } }, { key: "extract", value: function(t3, e2, n2) {
          e2 = kt.clamp(e2, 0, t3.length);
          var i2 = (n2 = kt.clamp(n2, -1, t3.length)) - e2 + 1;
          n2 < 0 && (i2 = 0), e2 >= t3.length && (i2 = 0), n2 < e2 && (i2 = 0);
          var r2 = new Array(i2).fill(null);
          if (0 === i2) return r2;
          for (var s2 = 0, a2 = e2; a2 <= n2; a2++) r2[s2++] = t3[a2];
          return r2;
        } }]);
      }(), Wt = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "compare", value: function(t2, e2) {
          var n2 = t2, i2 = e2;
          return jt.compare(n2, i2);
        } }, { key: "interfaces_", get: function() {
          return [P];
        } }]);
      }(), Kt = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "compare", value: function(t2, e2) {
          var n2 = t2, i2 = e2;
          if (n2.length < i2.length) return -1;
          if (n2.length > i2.length) return 1;
          if (0 === n2.length) return 0;
          var r2 = jt.compare(n2, i2);
          return jt.isEqualReversed(n2, i2) ? 0 : r2;
        } }, { key: "OLDcompare", value: function(t2, e2) {
          var n2 = t2, i2 = e2;
          if (n2.length < i2.length) return -1;
          if (n2.length > i2.length) return 1;
          if (0 === n2.length) return 0;
          for (var r2 = jt.increasingDirection(n2), s2 = jt.increasingDirection(i2), a2 = r2 > 0 ? 0 : n2.length - 1, o2 = s2 > 0 ? 0 : n2.length - 1, u3 = 0; u3 < n2.length; u3++) {
            var l2 = n2[a2].compareTo(i2[o2]);
            if (0 !== l2) return l2;
            a2 += r2, o2 += s2;
          }
          return 0;
        } }, { key: "interfaces_", get: function() {
          return [P];
        } }]);
      }();
      jt.ForwardComparator = Wt, jt.BidirectionalComparator = Kt, jt.coordArrayType = new Array(0).fill(null);
      var Jt = function() {
        return s(function t2(e2) {
          n(this, t2), this.str = e2;
        }, [{ key: "append", value: function(t2) {
          this.str += t2;
        } }, { key: "setCharAt", value: function(t2, e2) {
          this.str = this.str.substr(0, t2) + e2 + this.str.substr(t2 + 1);
        } }, { key: "toString", value: function() {
          return this.str;
        } }]);
      }(), Qt = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "getM", value: function(t3) {
          return this.hasM() ? this._coordinates[t3].getM() : A.NaN;
        } }, { key: "setOrdinate", value: function(t3, e2, n2) {
          switch (e2) {
            case ht.X:
              this._coordinates[t3].x = n2;
              break;
            case ht.Y:
              this._coordinates[t3].y = n2;
              break;
            default:
              this._coordinates[t3].setOrdinate(e2, n2);
          }
        } }, { key: "getZ", value: function(t3) {
          return this.hasZ() ? this._coordinates[t3].getZ() : A.NaN;
        } }, { key: "size", value: function() {
          return this._coordinates.length;
        } }, { key: "getOrdinate", value: function(t3, e2) {
          switch (e2) {
            case ht.X:
              return this._coordinates[t3].x;
            case ht.Y:
              return this._coordinates[t3].y;
            default:
              return this._coordinates[t3].getOrdinate(e2);
          }
        } }, { key: "getCoordinate", value: function() {
          if (1 === arguments.length) {
            var t3 = arguments[0];
            return this._coordinates[t3];
          }
          if (2 === arguments.length) {
            var e2 = arguments[0];
            arguments[1].setCoordinate(this._coordinates[e2]);
          }
        } }, { key: "getCoordinateCopy", value: function(t3) {
          var e2 = this.createCoordinate();
          return e2.setCoordinate(this._coordinates[t3]), e2;
        } }, { key: "createCoordinate", value: function() {
          return Ht.create(this.getDimension(), this.getMeasures());
        } }, { key: "getDimension", value: function() {
          return this._dimension;
        } }, { key: "getX", value: function(t3) {
          return this._coordinates[t3].x;
        } }, { key: "getMeasures", value: function() {
          return this._measures;
        } }, { key: "expandEnvelope", value: function(t3) {
          for (var e2 = 0; e2 < this._coordinates.length; e2++) t3.expandToInclude(this._coordinates[e2]);
          return t3;
        } }, { key: "copy", value: function() {
          for (var e2 = new Array(this.size()).fill(null), n2 = 0; n2 < this._coordinates.length; n2++) {
            var i2 = this.createCoordinate();
            i2.setCoordinate(this._coordinates[n2]), e2[n2] = i2;
          }
          return new t2(e2, this._dimension, this._measures);
        } }, { key: "toString", value: function() {
          if (this._coordinates.length > 0) {
            var t3 = new Jt(17 * this._coordinates.length);
            t3.append("("), t3.append(this._coordinates[0]);
            for (var e2 = 1; e2 < this._coordinates.length; e2++) t3.append(", "), t3.append(this._coordinates[e2]);
            return t3.append(")"), t3.toString();
          }
          return "()";
        } }, { key: "getY", value: function(t3) {
          return this._coordinates[t3].y;
        } }, { key: "toCoordinateArray", value: function() {
          return this._coordinates;
        } }, { key: "interfaces_", get: function() {
          return [ht, E];
        } }], [{ key: "constructor_", value: function() {
          if (this._dimension = 3, this._measures = 0, this._coordinates = null, 1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var e2 = arguments[0];
              t2.constructor_.call(this, e2, jt.dimension(e2), jt.measures(e2));
            } else if (Number.isInteger(arguments[0])) {
              var n2 = arguments[0];
              this._coordinates = new Array(n2).fill(null);
              for (var i2 = 0; i2 < n2; i2++) this._coordinates[i2] = new X();
            } else if (rt(arguments[0], ht)) {
              var r2 = arguments[0];
              if (null === r2) return this._coordinates = new Array(0).fill(null), null;
              this._dimension = r2.getDimension(), this._measures = r2.getMeasures(), this._coordinates = new Array(r2.size()).fill(null);
              for (var s2 = 0; s2 < this._coordinates.length; s2++) this._coordinates[s2] = r2.getCoordinateCopy(s2);
            }
          } else if (2 === arguments.length) {
            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
              var a2 = arguments[0], o2 = arguments[1];
              t2.constructor_.call(this, a2, o2, jt.measures(a2));
            } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
              var u3 = arguments[0], l2 = arguments[1];
              this._coordinates = new Array(u3).fill(null), this._dimension = l2;
              for (var h2 = 0; h2 < u3; h2++) this._coordinates[h2] = Ht.create(l2);
            }
          } else if (3 === arguments.length) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
              var c2 = arguments[0], f2 = arguments[1], g2 = arguments[2];
              this._dimension = f2, this._measures = g2, this._coordinates = null === c2 ? new Array(0).fill(null) : c2;
            } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
              var v2 = arguments[0], y2 = arguments[1], d2 = arguments[2];
              this._coordinates = new Array(v2).fill(null), this._dimension = y2, this._measures = d2;
              for (var _2 = 0; _2 < v2; _2++) this._coordinates[_2] = this.createCoordinate();
            }
          }
        } }]);
      }(), $t = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, [{ key: "readResolve", value: function() {
          return t2.instance();
        } }, { key: "create", value: function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) return new Qt(arguments[0]);
            if (rt(arguments[0], ht)) return new Qt(arguments[0]);
          } else {
            if (2 === arguments.length) {
              var t3 = arguments[1];
              return t3 > 3 && (t3 = 3), t3 < 2 && (t3 = 2), new Qt(arguments[0], t3);
            }
            if (3 === arguments.length) {
              var e2 = arguments[2], n2 = arguments[1] - e2;
              return e2 > 1 && (e2 = 1), n2 > 3 && (n2 = 3), n2 < 2 && (n2 = 2), new Qt(arguments[0], n2 + e2, e2);
            }
          }
        } }, { key: "interfaces_", get: function() {
          return [It, E];
        } }], [{ key: "instance", value: function() {
          return t2.instanceObject;
        } }]);
      }();
      $t.instanceObject = new $t();
      var te = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "copyInternal", value: function() {
          for (var t3 = new Array(this._geometries.length).fill(null), e2 = 0; e2 < t3.length; e2++) t3[e2] = this._geometries[e2].copy();
          return new i2(t3, this._factory);
        } }, { key: "equalsExact", value: function() {
          if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
            var t3 = arguments[0], e2 = arguments[1];
            return !!this.isEquivalentClass(t3) && f(i2, "equalsExact", this, 1).call(this, t3, e2);
          }
          return f(i2, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "getBoundaryDimension", value: function() {
          return 1;
        } }, { key: "getTypeCode", value: function() {
          return V.TYPECODE_MULTIPOLYGON;
        } }, { key: "getDimension", value: function() {
          return 2;
        } }, { key: "getBoundary", value: function() {
          if (this.isEmpty()) return this.getFactory().createMultiLineString();
          for (var t3 = new yt(), e2 = 0; e2 < this._geometries.length; e2++) for (var n2 = this._geometries[e2].getBoundary(), i3 = 0; i3 < n2.getNumGeometries(); i3++) t3.add(n2.getGeometryN(i3));
          var r2 = new Array(t3.size()).fill(null);
          return this.getFactory().createMultiLineString(t3.toArray(r2));
        } }, { key: "getGeometryType", value: function() {
          return V.TYPENAME_MULTIPOLYGON;
        } }, { key: "interfaces_", get: function() {
          return [Pt];
        } }], [{ key: "constructor_", value: function() {
          var t3 = arguments[0], e2 = arguments[1];
          Yt.constructor_.call(this, t3, e2);
        } }]);
      }(Yt), ee = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "get", value: function() {
        } }, { key: "put", value: function() {
        } }, { key: "size", value: function() {
        } }, { key: "values", value: function() {
        } }, { key: "entrySet", value: function() {
        } }]);
      }(), ne = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), (t3 = e(this, i2)).map = /* @__PURE__ */ new Map(), t3;
        }
        return l(i2, t2), s(i2, [{ key: "get", value: function(t3) {
          return this.map.get(t3) || null;
        } }, { key: "put", value: function(t3, e2) {
          return this.map.set(t3, e2), e2;
        } }, { key: "values", value: function() {
          for (var t3 = new yt(), e2 = this.map.values(), n2 = e2.next(); !n2.done; ) t3.add(n2.value), n2 = e2.next();
          return t3;
        } }, { key: "entrySet", value: function() {
          var t3 = new J();
          return this.map.entries().forEach(function(e2) {
            return t3.add(e2);
          }), t3;
        } }, { key: "size", value: function() {
          return this.map.size();
        } }]);
      }(ee), ie = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "equals", value: function(e2) {
          if (!(e2 instanceof t2)) return false;
          var n2 = e2;
          return this._modelType === n2._modelType && this._scale === n2._scale;
        } }, { key: "compareTo", value: function(t3) {
          var e2 = t3, n2 = this.getMaximumSignificantDigits(), i2 = e2.getMaximumSignificantDigits();
          return at.compare(n2, i2);
        } }, { key: "getScale", value: function() {
          return this._scale;
        } }, { key: "isFloating", value: function() {
          return this._modelType === t2.FLOATING || this._modelType === t2.FLOATING_SINGLE;
        } }, { key: "getType", value: function() {
          return this._modelType;
        } }, { key: "toString", value: function() {
          var e2 = "UNKNOWN";
          return this._modelType === t2.FLOATING ? e2 = "Floating" : this._modelType === t2.FLOATING_SINGLE ? e2 = "Floating-Single" : this._modelType === t2.FIXED && (e2 = "Fixed (Scale=" + this.getScale() + ")"), e2;
        } }, { key: "makePrecise", value: function() {
          if ("number" == typeof arguments[0]) {
            var e2 = arguments[0];
            return A.isNaN(e2) || this._modelType === t2.FLOATING_SINGLE ? e2 : this._modelType === t2.FIXED ? Math.round(e2 * this._scale) / this._scale : e2;
          }
          if (arguments[0] instanceof X) {
            var n2 = arguments[0];
            if (this._modelType === t2.FLOATING) return null;
            n2.x = this.makePrecise(n2.x), n2.y = this.makePrecise(n2.y);
          }
        } }, { key: "getMaximumSignificantDigits", value: function() {
          var e2 = 16;
          return this._modelType === t2.FLOATING ? e2 = 16 : this._modelType === t2.FLOATING_SINGLE ? e2 = 6 : this._modelType === t2.FIXED && (e2 = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), e2;
        } }, { key: "setScale", value: function(t3) {
          this._scale = Math.abs(t3);
        } }, { key: "interfaces_", get: function() {
          return [E, x];
        } }], [{ key: "constructor_", value: function() {
          if (this._modelType = null, this._scale = null, 0 === arguments.length) this._modelType = t2.FLOATING;
          else if (1 === arguments.length) {
            if (arguments[0] instanceof re) {
              var e2 = arguments[0];
              this._modelType = e2, e2 === t2.FIXED && this.setScale(1);
            } else if ("number" == typeof arguments[0]) {
              var n2 = arguments[0];
              this._modelType = t2.FIXED, this.setScale(n2);
            } else if (arguments[0] instanceof t2) {
              var i2 = arguments[0];
              this._modelType = i2._modelType, this._scale = i2._scale;
            }
          }
        } }, { key: "mostPrecise", value: function(t3, e2) {
          return t3.compareTo(e2) >= 0 ? t3 : e2;
        } }]);
      }(), re = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "readResolve", value: function() {
          return t2.nameToTypeMap.get(this._name);
        } }, { key: "toString", value: function() {
          return this._name;
        } }, { key: "interfaces_", get: function() {
          return [E];
        } }], [{ key: "constructor_", value: function() {
          this._name = null;
          var e2 = arguments[0];
          this._name = e2, t2.nameToTypeMap.put(e2, this);
        } }]);
      }();
      re.nameToTypeMap = new ne(), ie.Type = re, ie.FIXED = new re("FIXED"), ie.FLOATING = new re("FLOATING"), ie.FLOATING_SINGLE = new re("FLOATING SINGLE"), ie.maximumPreciseValue = 9007199254740992;
      var se = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "copyInternal", value: function() {
          for (var t3 = new Array(this._geometries.length).fill(null), e2 = 0; e2 < t3.length; e2++) t3[e2] = this._geometries[e2].copy();
          return new i2(t3, this._factory);
        } }, { key: "equalsExact", value: function() {
          if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof V) {
            var t3 = arguments[0], e2 = arguments[1];
            return !!this.isEquivalentClass(t3) && f(i2, "equalsExact", this, 1).call(this, t3, e2);
          }
          return f(i2, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "getBoundaryDimension", value: function() {
          return this.isClosed() ? Lt.FALSE : 0;
        } }, { key: "isClosed", value: function() {
          if (this.isEmpty()) return false;
          for (var t3 = 0; t3 < this._geometries.length; t3++) if (!this._geometries[t3].isClosed()) return false;
          return true;
        } }, { key: "getTypeCode", value: function() {
          return V.TYPECODE_MULTILINESTRING;
        } }, { key: "getDimension", value: function() {
          return 1;
        } }, { key: "getBoundary", value: function() {
          throw new W();
        } }, { key: "getGeometryType", value: function() {
          return V.TYPENAME_MULTILINESTRING;
        } }, { key: "interfaces_", get: function() {
          return [Tt];
        } }], [{ key: "constructor_", value: function() {
          var t3 = arguments[0], e2 = arguments[1];
          Yt.constructor_.call(this, t3, e2);
        } }]);
      }(Yt), ae = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "createEmpty", value: function(t3) {
          switch (t3) {
            case -1:
              return this.createGeometryCollection();
            case 0:
              return this.createPoint();
            case 1:
              return this.createLineString();
            case 2:
              return this.createPolygon();
            default:
              throw new m("Invalid dimension: " + t3);
          }
        } }, { key: "toGeometry", value: function(t3) {
          return t3.isNull() ? this.createPoint() : t3.getMinX() === t3.getMaxX() && t3.getMinY() === t3.getMaxY() ? this.createPoint(new X(t3.getMinX(), t3.getMinY())) : t3.getMinX() === t3.getMaxX() || t3.getMinY() === t3.getMaxY() ? this.createLineString([new X(t3.getMinX(), t3.getMinY()), new X(t3.getMaxX(), t3.getMaxY())]) : this.createPolygon(this.createLinearRing([new X(t3.getMinX(), t3.getMinY()), new X(t3.getMinX(), t3.getMaxY()), new X(t3.getMaxX(), t3.getMaxY()), new X(t3.getMaxX(), t3.getMinY()), new X(t3.getMinX(), t3.getMinY())]), null);
        } }, { key: "createLineString", value: function() {
          if (0 === arguments.length) return this.createLineString(this.getCoordinateSequenceFactory().create([]));
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t3 = arguments[0];
              return this.createLineString(null !== t3 ? this.getCoordinateSequenceFactory().create(t3) : null);
            }
            if (rt(arguments[0], ht)) return new wt(arguments[0], this);
          }
        } }, { key: "createMultiLineString", value: function() {
          return 0 === arguments.length ? new se(null, this) : 1 === arguments.length ? new se(arguments[0], this) : void 0;
        } }, { key: "buildGeometry", value: function(e2) {
          for (var n2 = null, i2 = false, r2 = false, s2 = e2.iterator(); s2.hasNext(); ) {
            var a2 = s2.next(), o2 = a2.getTypeCode();
            null === n2 && (n2 = o2), o2 !== n2 && (i2 = true), a2 instanceof Yt && (r2 = true);
          }
          if (null === n2) return this.createGeometryCollection();
          if (i2 || r2) return this.createGeometryCollection(t2.toGeometryArray(e2));
          var u3 = e2.iterator().next();
          if (e2.size() > 1) {
            if (u3 instanceof Dt) return this.createMultiPolygon(t2.toPolygonArray(e2));
            if (u3 instanceof wt) return this.createMultiLineString(t2.toLineStringArray(e2));
            if (u3 instanceof bt) return this.createMultiPoint(t2.toPointArray(e2));
            G.shouldNeverReachHere("Unhandled geometry type: " + u3.getGeometryType());
          }
          return u3;
        } }, { key: "createMultiPointFromCoords", value: function(t3) {
          return this.createMultiPoint(null !== t3 ? this.getCoordinateSequenceFactory().create(t3) : null);
        } }, { key: "createPoint", value: function() {
          if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([]));
          if (1 === arguments.length) {
            if (arguments[0] instanceof X) {
              var t3 = arguments[0];
              return this.createPoint(null !== t3 ? this.getCoordinateSequenceFactory().create([t3]) : null);
            }
            if (rt(arguments[0], ht)) return new bt(arguments[0], this);
          }
        } }, { key: "getCoordinateSequenceFactory", value: function() {
          return this._coordinateSequenceFactory;
        } }, { key: "createPolygon", value: function() {
          if (0 === arguments.length) return this.createPolygon(null, null);
          if (1 === arguments.length) {
            if (rt(arguments[0], ht)) {
              var t3 = arguments[0];
              return this.createPolygon(this.createLinearRing(t3));
            }
            if (arguments[0] instanceof Array) {
              var e2 = arguments[0];
              return this.createPolygon(this.createLinearRing(e2));
            }
            if (arguments[0] instanceof Xt) {
              var n2 = arguments[0];
              return this.createPolygon(n2, null);
            }
          } else if (2 === arguments.length) {
            return new Dt(arguments[0], arguments[1], this);
          }
        } }, { key: "getSRID", value: function() {
          return this._SRID;
        } }, { key: "createGeometryCollection", value: function() {
          return 0 === arguments.length ? new Yt(null, this) : 1 === arguments.length ? new Yt(arguments[0], this) : void 0;
        } }, { key: "getPrecisionModel", value: function() {
          return this._precisionModel;
        } }, { key: "createLinearRing", value: function() {
          if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t3 = arguments[0];
              return this.createLinearRing(null !== t3 ? this.getCoordinateSequenceFactory().create(t3) : null);
            }
            if (rt(arguments[0], ht)) return new Xt(arguments[0], this);
          }
        } }, { key: "createMultiPolygon", value: function() {
          return 0 === arguments.length ? new te(null, this) : 1 === arguments.length ? new te(arguments[0], this) : void 0;
        } }, { key: "createMultiPoint", value: function() {
          if (0 === arguments.length) return new zt(null, this);
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) return new zt(arguments[0], this);
            if (rt(arguments[0], ht)) {
              var t3 = arguments[0];
              if (null === t3) return this.createMultiPoint(new Array(0).fill(null));
              for (var e2 = new Array(t3.size()).fill(null), n2 = 0; n2 < t3.size(); n2++) {
                var i2 = this.getCoordinateSequenceFactory().create(1, t3.getDimension(), t3.getMeasures());
                St.copy(t3, n2, i2, 0, 1), e2[n2] = this.createPoint(i2);
              }
              return this.createMultiPoint(e2);
            }
          }
        } }, { key: "interfaces_", get: function() {
          return [E];
        } }], [{ key: "constructor_", value: function() {
          if (this._precisionModel = null, this._coordinateSequenceFactory = null, this._SRID = null, 0 === arguments.length) t2.constructor_.call(this, new ie(), 0);
          else if (1 === arguments.length) {
            if (rt(arguments[0], It)) {
              var e2 = arguments[0];
              t2.constructor_.call(this, new ie(), 0, e2);
            } else if (arguments[0] instanceof ie) {
              var n2 = arguments[0];
              t2.constructor_.call(this, n2, 0, t2.getDefaultCoordinateSequenceFactory());
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            t2.constructor_.call(this, i2, r2, t2.getDefaultCoordinateSequenceFactory());
          } else if (3 === arguments.length) {
            var s2 = arguments[0], a2 = arguments[1], o2 = arguments[2];
            this._precisionModel = s2, this._coordinateSequenceFactory = o2, this._SRID = a2;
          }
        } }, { key: "toMultiPolygonArray", value: function(t3) {
          var e2 = new Array(t3.size()).fill(null);
          return t3.toArray(e2);
        } }, { key: "toGeometryArray", value: function(t3) {
          if (null === t3) return null;
          var e2 = new Array(t3.size()).fill(null);
          return t3.toArray(e2);
        } }, { key: "getDefaultCoordinateSequenceFactory", value: function() {
          return $t.instance();
        } }, { key: "toMultiLineStringArray", value: function(t3) {
          var e2 = new Array(t3.size()).fill(null);
          return t3.toArray(e2);
        } }, { key: "toLineStringArray", value: function(t3) {
          var e2 = new Array(t3.size()).fill(null);
          return t3.toArray(e2);
        } }, { key: "toMultiPointArray", value: function(t3) {
          var e2 = new Array(t3.size()).fill(null);
          return t3.toArray(e2);
        } }, { key: "toLinearRingArray", value: function(t3) {
          var e2 = new Array(t3.size()).fill(null);
          return t3.toArray(e2);
        } }, { key: "toPointArray", value: function(t3) {
          var e2 = new Array(t3.size()).fill(null);
          return t3.toArray(e2);
        } }, { key: "toPolygonArray", value: function(t3) {
          var e2 = new Array(t3.size()).fill(null);
          return t3.toArray(e2);
        } }, { key: "createPointFromInternalCoord", value: function(t3, e2) {
          return e2.getPrecisionModel().makePrecise(t3), e2.getFactory().createPoint(t3);
        } }]);
      }(), oe = "XY", ue = "XYZ", le = "XYM", he = "XYZM", ce = { POINT: "Point", LINE_STRING: "LineString", LINEAR_RING: "LinearRing", POLYGON: "Polygon", MULTI_POINT: "MultiPoint", MULTI_LINE_STRING: "MultiLineString", MULTI_POLYGON: "MultiPolygon", GEOMETRY_COLLECTION: "GeometryCollection", CIRCLE: "Circle" }, fe = "EMPTY", ge = 1, ve = 2, ye = 3, de = 4, _e = 5, pe = 6;
      for (var me in ce) ce[me].toUpperCase();
      var ke = function() {
        return s(function t2(e2) {
          n(this, t2), this.wkt = e2, this.index_ = -1;
        }, [{ key: "isAlpha_", value: function(t2) {
          return t2 >= "a" && t2 <= "z" || t2 >= "A" && t2 <= "Z";
        } }, { key: "isNumeric_", value: function(t2, e2) {
          return t2 >= "0" && t2 <= "9" || "." == t2 && !(void 0 !== e2 && e2);
        } }, { key: "isWhiteSpace_", value: function(t2) {
          return " " == t2 || "	" == t2 || "\r" == t2 || "\n" == t2;
        } }, { key: "nextChar_", value: function() {
          return this.wkt.charAt(++this.index_);
        } }, { key: "nextToken", value: function() {
          var t2, e2 = this.nextChar_(), n2 = this.index_, i2 = e2;
          if ("(" == e2) t2 = ve;
          else if ("," == e2) t2 = _e;
          else if (")" == e2) t2 = ye;
          else if (this.isNumeric_(e2) || "-" == e2) t2 = de, i2 = this.readNumber_();
          else if (this.isAlpha_(e2)) t2 = ge, i2 = this.readText_();
          else {
            if (this.isWhiteSpace_(e2)) return this.nextToken();
            if ("" !== e2) throw new Error("Unexpected character: " + e2);
            t2 = pe;
          }
          return { position: n2, value: i2, type: t2 };
        } }, { key: "readNumber_", value: function() {
          var t2, e2 = this.index_, n2 = false, i2 = false;
          do {
            "." == t2 ? n2 = true : "e" != t2 && "E" != t2 || (i2 = true), t2 = this.nextChar_();
          } while (this.isNumeric_(t2, n2) || !i2 && ("e" == t2 || "E" == t2) || i2 && ("-" == t2 || "+" == t2));
          return parseFloat(this.wkt.substring(e2, this.index_--));
        } }, { key: "readText_", value: function() {
          var t2, e2 = this.index_;
          do {
            t2 = this.nextChar_();
          } while (this.isAlpha_(t2));
          return this.wkt.substring(e2, this.index_--).toUpperCase();
        } }]);
      }(), xe = function() {
        return s(function t2(e2, i2) {
          n(this, t2), this.lexer_ = e2, this.token_, this.layout_ = oe, this.factory = i2;
        }, [{ key: "consume_", value: function() {
          this.token_ = this.lexer_.nextToken();
        } }, { key: "isTokenType", value: function(t2) {
          return this.token_.type == t2;
        } }, { key: "match", value: function(t2) {
          var e2 = this.isTokenType(t2);
          return e2 && this.consume_(), e2;
        } }, { key: "parse", value: function() {
          return this.consume_(), this.parseGeometry_();
        } }, { key: "parseGeometryLayout_", value: function() {
          var t2 = oe, e2 = this.token_;
          if (this.isTokenType(ge)) {
            var n2 = e2.value;
            "Z" === n2 ? t2 = ue : "M" === n2 ? t2 = le : "ZM" === n2 && (t2 = he), t2 !== oe && this.consume_();
          }
          return t2;
        } }, { key: "parseGeometryCollectionText_", value: function() {
          if (this.match(ve)) {
            var t2 = [];
            do {
              t2.push(this.parseGeometry_());
            } while (this.match(_e));
            if (this.match(ye)) return t2;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePointText_", value: function() {
          if (this.match(ve)) {
            var t2 = this.parsePoint_();
            if (this.match(ye)) return t2;
          } else if (this.isEmptyGeometry_()) return null;
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseLineStringText_", value: function() {
          if (this.match(ve)) {
            var t2 = this.parsePointList_();
            if (this.match(ye)) return t2;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePolygonText_", value: function() {
          if (this.match(ve)) {
            var t2 = this.parseLineStringTextList_();
            if (this.match(ye)) return t2;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseMultiPointText_", value: function() {
          var t2;
          if (this.match(ve)) {
            if (t2 = this.token_.type == ve ? this.parsePointTextList_() : this.parsePointList_(), this.match(ye)) return t2;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseMultiLineStringText_", value: function() {
          if (this.match(ve)) {
            var t2 = this.parseLineStringTextList_();
            if (this.match(ye)) return t2;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseMultiPolygonText_", value: function() {
          if (this.match(ve)) {
            var t2 = this.parsePolygonTextList_();
            if (this.match(ye)) return t2;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePoint_", value: function() {
          for (var t2 = [], e2 = this.layout_.length, n2 = 0; n2 < e2; ++n2) {
            var i2 = this.token_;
            if (!this.match(de)) break;
            t2.push(i2.value);
          }
          if (t2.length == e2) return t2;
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePointList_", value: function() {
          for (var t2 = [this.parsePoint_()]; this.match(_e); ) t2.push(this.parsePoint_());
          return t2;
        } }, { key: "parsePointTextList_", value: function() {
          for (var t2 = [this.parsePointText_()]; this.match(_e); ) t2.push(this.parsePointText_());
          return t2;
        } }, { key: "parseLineStringTextList_", value: function() {
          for (var t2 = [this.parseLineStringText_()]; this.match(_e); ) t2.push(this.parseLineStringText_());
          return t2;
        } }, { key: "parsePolygonTextList_", value: function() {
          for (var t2 = [this.parsePolygonText_()]; this.match(_e); ) t2.push(this.parsePolygonText_());
          return t2;
        } }, { key: "isEmptyGeometry_", value: function() {
          var t2 = this.isTokenType(ge) && this.token_.value == fe;
          return t2 && this.consume_(), t2;
        } }, { key: "formatErrorMessage_", value: function() {
          return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
        } }, { key: "parseGeometry_", value: function() {
          var t2 = this.factory, e2 = function(t3) {
            return i(X, g(t3));
          }, n2 = function(n3) {
            var i2 = n3.map(function(n4) {
              return t2.createLinearRing(n4.map(e2));
            });
            return i2.length > 1 ? t2.createPolygon(i2[0], i2.slice(1)) : t2.createPolygon(i2[0]);
          }, r2 = this.token_;
          if (this.match(ge)) {
            var s2 = r2.value;
            if (this.layout_ = this.parseGeometryLayout_(), "GEOMETRYCOLLECTION" == s2) {
              var a2 = this.parseGeometryCollectionText_();
              return t2.createGeometryCollection(a2);
            }
            switch (s2) {
              case "POINT":
                var o2 = this.parsePointText_();
                return o2 ? t2.createPoint(i(X, g(o2))) : t2.createPoint();
              case "LINESTRING":
                var u3 = this.parseLineStringText_().map(e2);
                return t2.createLineString(u3);
              case "LINEARRING":
                var l2 = this.parseLineStringText_().map(e2);
                return t2.createLinearRing(l2);
              case "POLYGON":
                var h2 = this.parsePolygonText_();
                return h2 && 0 !== h2.length ? n2(h2) : t2.createPolygon();
              case "MULTIPOINT":
                var c2 = this.parseMultiPointText_();
                if (!c2 || 0 === c2.length) return t2.createMultiPoint();
                var f2 = c2.map(e2).map(function(e3) {
                  return t2.createPoint(e3);
                });
                return t2.createMultiPoint(f2);
              case "MULTILINESTRING":
                var v2 = this.parseMultiLineStringText_().map(function(n3) {
                  return t2.createLineString(n3.map(e2));
                });
                return t2.createMultiLineString(v2);
              case "MULTIPOLYGON":
                var y2 = this.parseMultiPolygonText_();
                if (!y2 || 0 === y2.length) return t2.createMultiPolygon();
                var d2 = y2.map(n2);
                return t2.createMultiPolygon(d2);
              default:
                throw new Error("Invalid geometry type: " + s2);
            }
          }
          throw new Error(this.formatErrorMessage_());
        } }]);
      }();
      function Ie(t2) {
        if (t2.isEmpty()) return "";
        var e2 = t2.getCoordinate(), n2 = [e2.x, e2.y];
        return void 0 === e2.z || Number.isNaN(e2.z) || n2.push(e2.z), void 0 === e2.m || Number.isNaN(e2.m) || n2.push(e2.m), n2.join(" ");
      }
      function Ee(t2) {
        for (var e2 = t2.getCoordinates().map(function(t3) {
          var e3 = [t3.x, t3.y];
          return void 0 === t3.z || Number.isNaN(t3.z) || e3.push(t3.z), void 0 === t3.m || Number.isNaN(t3.m) || e3.push(t3.m), e3;
        }), n2 = [], i2 = 0, r2 = e2.length; i2 < r2; ++i2) n2.push(e2[i2].join(" "));
        return n2.join(", ");
      }
      function Ne(t2) {
        var e2 = [];
        e2.push("(" + Ee(t2.getExteriorRing()) + ")");
        for (var n2 = 0, i2 = t2.getNumInteriorRing(); n2 < i2; ++n2) e2.push("(" + Ee(t2.getInteriorRingN(n2)) + ")");
        return e2.join(", ");
      }
      var Te = { Point: Ie, LineString: Ee, LinearRing: Ee, Polygon: Ne, MultiPoint: function(t2) {
        for (var e2 = [], n2 = 0, i2 = t2.getNumGeometries(); n2 < i2; ++n2) e2.push("(" + Ie(t2.getGeometryN(n2)) + ")");
        return e2.join(", ");
      }, MultiLineString: function(t2) {
        for (var e2 = [], n2 = 0, i2 = t2.getNumGeometries(); n2 < i2; ++n2) e2.push("(" + Ee(t2.getGeometryN(n2)) + ")");
        return e2.join(", ");
      }, MultiPolygon: function(t2) {
        for (var e2 = [], n2 = 0, i2 = t2.getNumGeometries(); n2 < i2; ++n2) e2.push("(" + Ne(t2.getGeometryN(n2)) + ")");
        return e2.join(", ");
      }, GeometryCollection: function(t2) {
        for (var e2 = [], n2 = 0, i2 = t2.getNumGeometries(); n2 < i2; ++n2) e2.push(Se(t2.getGeometryN(n2)));
        return e2.join(", ");
      } };
      function Se(t2) {
        var e2 = t2.getGeometryType(), n2 = Te[e2];
        e2 = e2.toUpperCase();
        var i2 = function(t3) {
          var e3 = "";
          if (t3.isEmpty()) return e3;
          var n3 = t3.getCoordinate();
          return void 0 === n3.z || Number.isNaN(n3.z) || (e3 += "Z"), void 0 === n3.m || Number.isNaN(n3.m) || (e3 += "M"), e3;
        }(t2);
        return i2.length > 0 && (e2 += " " + i2), t2.isEmpty() ? e2 + " " + fe : e2 + " (" + n2(t2) + ")";
      }
      var Le = function() {
        return s(function t2(e2) {
          n(this, t2), this.geometryFactory = e2 || new ae(), this.precisionModel = this.geometryFactory.getPrecisionModel();
        }, [{ key: "read", value: function(t2) {
          var e2 = new ke(t2);
          return new xe(e2, this.geometryFactory).parse();
        } }, { key: "write", value: function(t2) {
          return Se(t2);
        } }]);
      }(), Ce = function() {
        return s(function t2(e2) {
          n(this, t2), this.parser = new Le(e2);
        }, [{ key: "write", value: function(t2) {
          return this.parser.write(t2);
        } }], [{ key: "toLineString", value: function(t2, e2) {
          if (2 !== arguments.length) throw new Error("Not implemented");
          return "LINESTRING ( " + t2.x + " " + t2.y + ", " + e2.x + " " + e2.y + " )";
        } }]);
      }(), Re = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "getIndexAlongSegment", value: function(t3, e2) {
          return this.computeIntLineIndex(), this._intLineIndex[t3][e2];
        } }, { key: "getTopologySummary", value: function() {
          var t3 = new Jt();
          return this.isEndPoint() && t3.append(" endpoint"), this._isProper && t3.append(" proper"), this.isCollinear() && t3.append(" collinear"), t3.toString();
        } }, { key: "computeIntersection", value: function(t3, e2, n2, i2) {
          this._inputLines[0][0] = t3, this._inputLines[0][1] = e2, this._inputLines[1][0] = n2, this._inputLines[1][1] = i2, this._result = this.computeIntersect(t3, e2, n2, i2);
        } }, { key: "getIntersectionNum", value: function() {
          return this._result;
        } }, { key: "computeIntLineIndex", value: function() {
          if (0 === arguments.length) null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map(function() {
            return Array(2);
          }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
          else if (1 === arguments.length) {
            var t3 = arguments[0];
            this.getEdgeDistance(t3, 0) > this.getEdgeDistance(t3, 1) ? (this._intLineIndex[t3][0] = 0, this._intLineIndex[t3][1] = 1) : (this._intLineIndex[t3][0] = 1, this._intLineIndex[t3][1] = 0);
          }
        } }, { key: "isProper", value: function() {
          return this.hasIntersection() && this._isProper;
        } }, { key: "setPrecisionModel", value: function(t3) {
          this._precisionModel = t3;
        } }, { key: "isInteriorIntersection", value: function() {
          if (0 === arguments.length) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
          if (1 === arguments.length) {
            for (var t3 = arguments[0], e2 = 0; e2 < this._result; e2++) if (!this._intPt[e2].equals2D(this._inputLines[t3][0]) && !this._intPt[e2].equals2D(this._inputLines[t3][1])) return true;
            return false;
          }
        } }, { key: "getIntersection", value: function(t3) {
          return this._intPt[t3];
        } }, { key: "isEndPoint", value: function() {
          return this.hasIntersection() && !this._isProper;
        } }, { key: "hasIntersection", value: function() {
          return this._result !== t2.NO_INTERSECTION;
        } }, { key: "getEdgeDistance", value: function(e2, n2) {
          return t2.computeEdgeDistance(this._intPt[n2], this._inputLines[e2][0], this._inputLines[e2][1]);
        } }, { key: "isCollinear", value: function() {
          return this._result === t2.COLLINEAR_INTERSECTION;
        } }, { key: "toString", value: function() {
          return Ce.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Ce.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
        } }, { key: "getEndpoint", value: function(t3, e2) {
          return this._inputLines[t3][e2];
        } }, { key: "isIntersection", value: function(t3) {
          for (var e2 = 0; e2 < this._result; e2++) if (this._intPt[e2].equals2D(t3)) return true;
          return false;
        } }, { key: "getIntersectionAlongSegment", value: function(t3, e2) {
          return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t3][e2]];
        } }], [{ key: "constructor_", value: function() {
          this._result = null, this._inputLines = Array(2).fill().map(function() {
            return Array(2);
          }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new X(), this._intPt[1] = new X(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
        } }, { key: "computeEdgeDistance", value: function(t3, e2, n2) {
          var i2 = Math.abs(n2.x - e2.x), r2 = Math.abs(n2.y - e2.y), s2 = -1;
          if (t3.equals(e2)) s2 = 0;
          else if (t3.equals(n2)) s2 = i2 > r2 ? i2 : r2;
          else {
            var a2 = Math.abs(t3.x - e2.x), o2 = Math.abs(t3.y - e2.y);
            0 !== (s2 = i2 > r2 ? a2 : o2) || t3.equals(e2) || (s2 = Math.max(a2, o2));
          }
          return G.isTrue(!(0 === s2 && !t3.equals(e2)), "Bad distance calculation"), s2;
        } }, { key: "nonRobustComputeEdgeDistance", value: function(t3, e2, n2) {
          var i2 = t3.x - e2.x, r2 = t3.y - e2.y, s2 = Math.sqrt(i2 * i2 + r2 * r2);
          return G.isTrue(!(0 === s2 && !t3.equals(e2)), "Invalid distance calculation"), s2;
        } }]);
      }();
      Re.DONT_INTERSECT = 0, Re.DO_INTERSECT = 1, Re.COLLINEAR = 2, Re.NO_INTERSECTION = 0, Re.POINT_INTERSECTION = 1, Re.COLLINEAR_INTERSECTION = 2;
      var we = function(t2) {
        function i2() {
          return n(this, i2), e(this, i2);
        }
        return l(i2, t2), s(i2, [{ key: "isInSegmentEnvelopes", value: function(t3) {
          var e2 = new U(this._inputLines[0][0], this._inputLines[0][1]), n2 = new U(this._inputLines[1][0], this._inputLines[1][1]);
          return e2.contains(t3) && n2.contains(t3);
        } }, { key: "computeIntersection", value: function() {
          if (3 !== arguments.length) return f(i2, "computeIntersection", this, 1).apply(this, arguments);
          var t3 = arguments[0], e2 = arguments[1], n2 = arguments[2];
          if (this._isProper = false, U.intersects(e2, n2, t3) && 0 === ct.index(e2, n2, t3) && 0 === ct.index(n2, e2, t3)) return this._isProper = true, (t3.equals(e2) || t3.equals(n2)) && (this._isProper = false), this._result = Re.POINT_INTERSECTION, null;
          this._result = Re.NO_INTERSECTION;
        } }, { key: "intersection", value: function(t3, e2, n2, r2) {
          var s2 = this.intersectionSafe(t3, e2, n2, r2);
          return this.isInSegmentEnvelopes(s2) || (s2 = new X(i2.nearestEndpoint(t3, e2, n2, r2))), null !== this._precisionModel && this._precisionModel.makePrecise(s2), s2;
        } }, { key: "checkDD", value: function(t3, e2, n2, i3, r2) {
          var s2 = lt.intersection(t3, e2, n2, i3), a2 = this.isInSegmentEnvelopes(s2);
          mt.out.println("DD in env = " + a2 + "  --------------------- " + s2), r2.distance(s2) > 1e-4 && mt.out.println("Distance = " + r2.distance(s2));
        } }, { key: "intersectionSafe", value: function(t3, e2, n2, r2) {
          var s2 = pt.intersection(t3, e2, n2, r2);
          return null === s2 && (s2 = i2.nearestEndpoint(t3, e2, n2, r2)), s2;
        } }, { key: "computeCollinearIntersection", value: function(t3, e2, n2, i3) {
          var r2 = U.intersects(t3, e2, n2), s2 = U.intersects(t3, e2, i3), a2 = U.intersects(n2, i3, t3), o2 = U.intersects(n2, i3, e2);
          return r2 && s2 ? (this._intPt[0] = n2, this._intPt[1] = i3, Re.COLLINEAR_INTERSECTION) : a2 && o2 ? (this._intPt[0] = t3, this._intPt[1] = e2, Re.COLLINEAR_INTERSECTION) : r2 && a2 ? (this._intPt[0] = n2, this._intPt[1] = t3, !n2.equals(t3) || s2 || o2 ? Re.COLLINEAR_INTERSECTION : Re.POINT_INTERSECTION) : r2 && o2 ? (this._intPt[0] = n2, this._intPt[1] = e2, !n2.equals(e2) || s2 || a2 ? Re.COLLINEAR_INTERSECTION : Re.POINT_INTERSECTION) : s2 && a2 ? (this._intPt[0] = i3, this._intPt[1] = t3, !i3.equals(t3) || r2 || o2 ? Re.COLLINEAR_INTERSECTION : Re.POINT_INTERSECTION) : s2 && o2 ? (this._intPt[0] = i3, this._intPt[1] = e2, !i3.equals(e2) || r2 || a2 ? Re.COLLINEAR_INTERSECTION : Re.POINT_INTERSECTION) : Re.NO_INTERSECTION;
        } }, { key: "computeIntersect", value: function(t3, e2, n2, i3) {
          if (this._isProper = false, !U.intersects(t3, e2, n2, i3)) return Re.NO_INTERSECTION;
          var r2 = ct.index(t3, e2, n2), s2 = ct.index(t3, e2, i3);
          if (r2 > 0 && s2 > 0 || r2 < 0 && s2 < 0) return Re.NO_INTERSECTION;
          var a2 = ct.index(n2, i3, t3), o2 = ct.index(n2, i3, e2);
          return a2 > 0 && o2 > 0 || a2 < 0 && o2 < 0 ? Re.NO_INTERSECTION : 0 === r2 && 0 === s2 && 0 === a2 && 0 === o2 ? this.computeCollinearIntersection(t3, e2, n2, i3) : (0 === r2 || 0 === s2 || 0 === a2 || 0 === o2 ? (this._isProper = false, t3.equals2D(n2) || t3.equals2D(i3) ? this._intPt[0] = t3 : e2.equals2D(n2) || e2.equals2D(i3) ? this._intPt[0] = e2 : 0 === r2 ? this._intPt[0] = new X(n2) : 0 === s2 ? this._intPt[0] = new X(i3) : 0 === a2 ? this._intPt[0] = new X(t3) : 0 === o2 && (this._intPt[0] = new X(e2))) : (this._isProper = true, this._intPt[0] = this.intersection(t3, e2, n2, i3)), Re.POINT_INTERSECTION);
        } }], [{ key: "nearestEndpoint", value: function(t3, e2, n2, i3) {
          var r2 = t3, s2 = xt.pointToSegment(t3, n2, i3), a2 = xt.pointToSegment(e2, n2, i3);
          return a2 < s2 && (s2 = a2, r2 = e2), (a2 = xt.pointToSegment(n2, t3, e2)) < s2 && (s2 = a2, r2 = n2), (a2 = xt.pointToSegment(i3, t3, e2)) < s2 && (s2 = a2, r2 = i3), r2;
        } }]);
      }(Re), Oe = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "countSegment", value: function(t3, e2) {
          if (t3.x < this._p.x && e2.x < this._p.x) return null;
          if (this._p.x === e2.x && this._p.y === e2.y) return this._isPointOnSegment = true, null;
          if (t3.y === this._p.y && e2.y === this._p.y) {
            var n2 = t3.x, i2 = e2.x;
            return n2 > i2 && (n2 = e2.x, i2 = t3.x), this._p.x >= n2 && this._p.x <= i2 && (this._isPointOnSegment = true), null;
          }
          if (t3.y > this._p.y && e2.y <= this._p.y || e2.y > this._p.y && t3.y <= this._p.y) {
            var r2 = ct.index(t3, e2, this._p);
            if (r2 === ct.COLLINEAR) return this._isPointOnSegment = true, null;
            e2.y < t3.y && (r2 = -r2), r2 === ct.LEFT && this._crossingCount++;
          }
        } }, { key: "isPointInPolygon", value: function() {
          return this.getLocation() !== H.EXTERIOR;
        } }, { key: "getLocation", value: function() {
          return this._isPointOnSegment ? H.BOUNDARY : this._crossingCount % 2 == 1 ? H.INTERIOR : H.EXTERIOR;
        } }, { key: "isOnSegment", value: function() {
          return this._isPointOnSegment;
        } }], [{ key: "constructor_", value: function() {
          this._p = null, this._crossingCount = 0, this._isPointOnSegment = false;
          var t3 = arguments[0];
          this._p = t3;
        } }, { key: "locatePointInRing", value: function() {
          if (arguments[0] instanceof X && rt(arguments[1], ht)) {
            for (var e2 = arguments[1], n2 = new t2(arguments[0]), i2 = new X(), r2 = new X(), s2 = 1; s2 < e2.size(); s2++) if (e2.getCoordinate(s2, i2), e2.getCoordinate(s2 - 1, r2), n2.countSegment(i2, r2), n2.isOnSegment()) return n2.getLocation();
            return n2.getLocation();
          }
          if (arguments[0] instanceof X && arguments[1] instanceof Array) {
            for (var a2 = arguments[1], o2 = new t2(arguments[0]), u3 = 1; u3 < a2.length; u3++) {
              var l2 = a2[u3], h2 = a2[u3 - 1];
              if (o2.countSegment(l2, h2), o2.isOnSegment()) return o2.getLocation();
            }
            return o2.getLocation();
          }
        } }]);
      }(), be = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "isOnLine", value: function() {
          if (arguments[0] instanceof X && rt(arguments[1], ht)) {
            for (var t3 = arguments[0], e2 = arguments[1], n2 = new we(), i2 = new X(), r2 = new X(), s2 = e2.size(), a2 = 1; a2 < s2; a2++) if (e2.getCoordinate(a2 - 1, i2), e2.getCoordinate(a2, r2), n2.computeIntersection(t3, i2, r2), n2.hasIntersection()) return true;
            return false;
          }
          if (arguments[0] instanceof X && arguments[1] instanceof Array) {
            for (var o2 = arguments[0], u3 = arguments[1], l2 = new we(), h2 = 1; h2 < u3.length; h2++) {
              var c2 = u3[h2 - 1], f2 = u3[h2];
              if (l2.computeIntersection(o2, c2, f2), l2.hasIntersection()) return true;
            }
            return false;
          }
        } }, { key: "locateInRing", value: function(t3, e2) {
          return Oe.locatePointInRing(t3, e2);
        } }, { key: "isInRing", value: function(e2, n2) {
          return t2.locateInRing(e2, n2) !== H.EXTERIOR;
        } }]);
      }(), Me = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "setAllLocations", value: function(t3) {
          for (var e2 = 0; e2 < this.location.length; e2++) this.location[e2] = t3;
        } }, { key: "isNull", value: function() {
          for (var t3 = 0; t3 < this.location.length; t3++) if (this.location[t3] !== H.NONE) return false;
          return true;
        } }, { key: "setAllLocationsIfNull", value: function(t3) {
          for (var e2 = 0; e2 < this.location.length; e2++) this.location[e2] === H.NONE && (this.location[e2] = t3);
        } }, { key: "isLine", value: function() {
          return 1 === this.location.length;
        } }, { key: "merge", value: function(t3) {
          if (t3.location.length > this.location.length) {
            var e2 = new Array(3).fill(null);
            e2[$.ON] = this.location[$.ON], e2[$.LEFT] = H.NONE, e2[$.RIGHT] = H.NONE, this.location = e2;
          }
          for (var n2 = 0; n2 < this.location.length; n2++) this.location[n2] === H.NONE && n2 < t3.location.length && (this.location[n2] = t3.location[n2]);
        } }, { key: "getLocations", value: function() {
          return this.location;
        } }, { key: "flip", value: function() {
          if (this.location.length <= 1) return null;
          var t3 = this.location[$.LEFT];
          this.location[$.LEFT] = this.location[$.RIGHT], this.location[$.RIGHT] = t3;
        } }, { key: "toString", value: function() {
          var t3 = new st();
          return this.location.length > 1 && t3.append(H.toLocationSymbol(this.location[$.LEFT])), t3.append(H.toLocationSymbol(this.location[$.ON])), this.location.length > 1 && t3.append(H.toLocationSymbol(this.location[$.RIGHT])), t3.toString();
        } }, { key: "setLocations", value: function(t3, e2, n2) {
          this.location[$.ON] = t3, this.location[$.LEFT] = e2, this.location[$.RIGHT] = n2;
        } }, { key: "get", value: function(t3) {
          return t3 < this.location.length ? this.location[t3] : H.NONE;
        } }, { key: "isArea", value: function() {
          return this.location.length > 1;
        } }, { key: "isAnyNull", value: function() {
          for (var t3 = 0; t3 < this.location.length; t3++) if (this.location[t3] === H.NONE) return true;
          return false;
        } }, { key: "setLocation", value: function() {
          if (1 === arguments.length) {
            var t3 = arguments[0];
            this.setLocation($.ON, t3);
          } else if (2 === arguments.length) {
            var e2 = arguments[0], n2 = arguments[1];
            this.location[e2] = n2;
          }
        } }, { key: "init", value: function(t3) {
          this.location = new Array(t3).fill(null), this.setAllLocations(H.NONE);
        } }, { key: "isEqualOnSide", value: function(t3, e2) {
          return this.location[e2] === t3.location[e2];
        } }, { key: "allPositionsEqual", value: function(t3) {
          for (var e2 = 0; e2 < this.location.length; e2++) if (this.location[e2] !== t3) return false;
          return true;
        } }], [{ key: "constructor_", value: function() {
          if (this.location = null, 1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var e2 = arguments[0];
              this.init(e2.length);
            } else if (Number.isInteger(arguments[0])) {
              var n2 = arguments[0];
              this.init(1), this.location[$.ON] = n2;
            } else if (arguments[0] instanceof t2) {
              var i2 = arguments[0];
              if (this.init(i2.location.length), null !== i2) for (var r2 = 0; r2 < this.location.length; r2++) this.location[r2] = i2.location[r2];
            }
          } else if (3 === arguments.length) {
            var s2 = arguments[0], a2 = arguments[1], o2 = arguments[2];
            this.init(3), this.location[$.ON] = s2, this.location[$.LEFT] = a2, this.location[$.RIGHT] = o2;
          }
        } }]);
      }(), Ae = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "getGeometryCount", value: function() {
          var t3 = 0;
          return this.elt[0].isNull() || t3++, this.elt[1].isNull() || t3++, t3;
        } }, { key: "setAllLocations", value: function(t3, e2) {
          this.elt[t3].setAllLocations(e2);
        } }, { key: "isNull", value: function(t3) {
          return this.elt[t3].isNull();
        } }, { key: "setAllLocationsIfNull", value: function() {
          if (1 === arguments.length) {
            var t3 = arguments[0];
            this.setAllLocationsIfNull(0, t3), this.setAllLocationsIfNull(1, t3);
          } else if (2 === arguments.length) {
            var e2 = arguments[0], n2 = arguments[1];
            this.elt[e2].setAllLocationsIfNull(n2);
          }
        } }, { key: "isLine", value: function(t3) {
          return this.elt[t3].isLine();
        } }, { key: "merge", value: function(t3) {
          for (var e2 = 0; e2 < 2; e2++) null === this.elt[e2] && null !== t3.elt[e2] ? this.elt[e2] = new Me(t3.elt[e2]) : this.elt[e2].merge(t3.elt[e2]);
        } }, { key: "flip", value: function() {
          this.elt[0].flip(), this.elt[1].flip();
        } }, { key: "getLocation", value: function() {
          if (1 === arguments.length) {
            var t3 = arguments[0];
            return this.elt[t3].get($.ON);
          }
          if (2 === arguments.length) {
            var e2 = arguments[0], n2 = arguments[1];
            return this.elt[e2].get(n2);
          }
        } }, { key: "toString", value: function() {
          var t3 = new st();
          return null !== this.elt[0] && (t3.append("A:"), t3.append(this.elt[0].toString())), null !== this.elt[1] && (t3.append(" B:"), t3.append(this.elt[1].toString())), t3.toString();
        } }, { key: "isArea", value: function() {
          if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea();
          if (1 === arguments.length) {
            var t3 = arguments[0];
            return this.elt[t3].isArea();
          }
        } }, { key: "isAnyNull", value: function(t3) {
          return this.elt[t3].isAnyNull();
        } }, { key: "setLocation", value: function() {
          if (2 === arguments.length) {
            var t3 = arguments[0], e2 = arguments[1];
            this.elt[t3].setLocation($.ON, e2);
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this.elt[n2].setLocation(i2, r2);
          }
        } }, { key: "isEqualOnSide", value: function(t3, e2) {
          return this.elt[0].isEqualOnSide(t3.elt[0], e2) && this.elt[1].isEqualOnSide(t3.elt[1], e2);
        } }, { key: "allPositionsEqual", value: function(t3, e2) {
          return this.elt[t3].allPositionsEqual(e2);
        } }, { key: "toLine", value: function(t3) {
          this.elt[t3].isArea() && (this.elt[t3] = new Me(this.elt[t3].location[0]));
        } }], [{ key: "constructor_", value: function() {
          if (this.elt = new Array(2).fill(null), 1 === arguments.length) {
            if (Number.isInteger(arguments[0])) {
              var e2 = arguments[0];
              this.elt[0] = new Me(e2), this.elt[1] = new Me(e2);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this.elt[0] = new Me(n2.elt[0]), this.elt[1] = new Me(n2.elt[1]);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this.elt[0] = new Me(H.NONE), this.elt[1] = new Me(H.NONE), this.elt[i2].setLocation(r2);
          } else if (3 === arguments.length) {
            var s2 = arguments[0], a2 = arguments[1], o2 = arguments[2];
            this.elt[0] = new Me(s2, a2, o2), this.elt[1] = new Me(s2, a2, o2);
          } else if (4 === arguments.length) {
            var u3 = arguments[0], l2 = arguments[1], h2 = arguments[2], c2 = arguments[3];
            this.elt[0] = new Me(H.NONE, H.NONE, H.NONE), this.elt[1] = new Me(H.NONE, H.NONE, H.NONE), this.elt[u3].setLocations(l2, h2, c2);
          }
        } }, { key: "toLineLabel", value: function(e2) {
          for (var n2 = new t2(H.NONE), i2 = 0; i2 < 2; i2++) n2.setLocation(i2, e2.getLocation(i2));
          return n2;
        } }]);
      }(), Pe = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "computeRing", value: function() {
          if (null !== this._ring) return null;
          for (var t2 = new Array(this._pts.size()).fill(null), e2 = 0; e2 < this._pts.size(); e2++) t2[e2] = this._pts.get(e2);
          this._ring = this._geometryFactory.createLinearRing(t2), this._isHole = ct.isCCW(this._ring.getCoordinates());
        } }, { key: "isIsolated", value: function() {
          return 1 === this._label.getGeometryCount();
        } }, { key: "computePoints", value: function(t2) {
          this._startDe = t2;
          var e2 = t2, n2 = true;
          do {
            if (null === e2) throw new gt("Found null DirectedEdge");
            if (e2.getEdgeRing() === this) throw new gt("Directed Edge visited twice during ring-building at " + e2.getCoordinate());
            this._edges.add(e2);
            var i2 = e2.getLabel();
            G.isTrue(i2.isArea()), this.mergeLabel(i2), this.addPoints(e2.getEdge(), e2.isForward(), n2), n2 = false, this.setEdgeRing(e2, this), e2 = this.getNext(e2);
          } while (e2 !== this._startDe);
        } }, { key: "getLinearRing", value: function() {
          return this._ring;
        } }, { key: "getCoordinate", value: function(t2) {
          return this._pts.get(t2);
        } }, { key: "computeMaxNodeDegree", value: function() {
          this._maxNodeDegree = 0;
          var t2 = this._startDe;
          do {
            var e2 = t2.getNode().getEdges().getOutgoingDegree(this);
            e2 > this._maxNodeDegree && (this._maxNodeDegree = e2), t2 = this.getNext(t2);
          } while (t2 !== this._startDe);
          this._maxNodeDegree *= 2;
        } }, { key: "addPoints", value: function(t2, e2, n2) {
          var i2 = t2.getCoordinates();
          if (e2) {
            var r2 = 1;
            n2 && (r2 = 0);
            for (var s2 = r2; s2 < i2.length; s2++) this._pts.add(i2[s2]);
          } else {
            var a2 = i2.length - 2;
            n2 && (a2 = i2.length - 1);
            for (var o2 = a2; o2 >= 0; o2--) this._pts.add(i2[o2]);
          }
        } }, { key: "isHole", value: function() {
          return this._isHole;
        } }, { key: "setInResult", value: function() {
          var t2 = this._startDe;
          do {
            t2.getEdge().setInResult(true), t2 = t2.getNext();
          } while (t2 !== this._startDe);
        } }, { key: "containsPoint", value: function(t2) {
          var e2 = this.getLinearRing();
          if (!e2.getEnvelopeInternal().contains(t2)) return false;
          if (!be.isInRing(t2, e2.getCoordinates())) return false;
          for (var n2 = this._holes.iterator(); n2.hasNext(); ) {
            if (n2.next().containsPoint(t2)) return false;
          }
          return true;
        } }, { key: "addHole", value: function(t2) {
          this._holes.add(t2);
        } }, { key: "isShell", value: function() {
          return null === this._shell;
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "getEdges", value: function() {
          return this._edges;
        } }, { key: "getMaxNodeDegree", value: function() {
          return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
        } }, { key: "getShell", value: function() {
          return this._shell;
        } }, { key: "mergeLabel", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.mergeLabel(t2, 0), this.mergeLabel(t2, 1);
          } else if (2 === arguments.length) {
            var e2 = arguments[1], n2 = arguments[0].getLocation(e2, $.RIGHT);
            if (n2 === H.NONE) return null;
            if (this._label.getLocation(e2) === H.NONE) return this._label.setLocation(e2, n2), null;
          }
        } }, { key: "setShell", value: function(t2) {
          this._shell = t2, null !== t2 && t2.addHole(this);
        } }, { key: "toPolygon", value: function(t2) {
          for (var e2 = new Array(this._holes.size()).fill(null), n2 = 0; n2 < this._holes.size(); n2++) e2[n2] = this._holes.get(n2).getLinearRing();
          return t2.createPolygon(this.getLinearRing(), e2);
        } }], [{ key: "constructor_", value: function() {
          if (this._startDe = null, this._maxNodeDegree = -1, this._edges = new yt(), this._pts = new yt(), this._label = new Ae(H.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new yt(), this._geometryFactory = null, 0 === arguments.length) ;
          else if (2 === arguments.length) {
            var t2 = arguments[0], e2 = arguments[1];
            this._geometryFactory = e2, this.computePoints(t2), this.computeRing();
          }
        } }]);
      }(), De = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "setEdgeRing", value: function(t3, e2) {
          t3.setMinEdgeRing(e2);
        } }, { key: "getNext", value: function(t3) {
          return t3.getNextMin();
        } }], [{ key: "constructor_", value: function() {
          var t3 = arguments[0], e2 = arguments[1];
          Pe.constructor_.call(this, t3, e2);
        } }]);
      }(Pe), Fe = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "buildMinimalRings", value: function() {
          var t3 = new yt(), e2 = this._startDe;
          do {
            if (null === e2.getMinEdgeRing()) {
              var n2 = new De(e2, this._geometryFactory);
              t3.add(n2);
            }
            e2 = e2.getNext();
          } while (e2 !== this._startDe);
          return t3;
        } }, { key: "setEdgeRing", value: function(t3, e2) {
          t3.setEdgeRing(e2);
        } }, { key: "linkDirectedEdgesForMinimalEdgeRings", value: function() {
          var t3 = this._startDe;
          do {
            t3.getNode().getEdges().linkMinimalDirectedEdges(this), t3 = t3.getNext();
          } while (t3 !== this._startDe);
        } }, { key: "getNext", value: function(t3) {
          return t3.getNext();
        } }], [{ key: "constructor_", value: function() {
          var t3 = arguments[0], e2 = arguments[1];
          Pe.constructor_.call(this, t3, e2);
        } }]);
      }(Pe), Ge = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "setVisited", value: function(t2) {
          this._isVisited = t2;
        } }, { key: "setInResult", value: function(t2) {
          this._isInResult = t2;
        } }, { key: "isCovered", value: function() {
          return this._isCovered;
        } }, { key: "isCoveredSet", value: function() {
          return this._isCoveredSet;
        } }, { key: "setLabel", value: function(t2) {
          this._label = t2;
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "setCovered", value: function(t2) {
          this._isCovered = t2, this._isCoveredSet = true;
        } }, { key: "updateIM", value: function(t2) {
          G.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t2);
        } }, { key: "isInResult", value: function() {
          return this._isInResult;
        } }, { key: "isVisited", value: function() {
          return this._isVisited;
        } }], [{ key: "constructor_", value: function() {
          if (this._label = null, this._isInResult = false, this._isCovered = false, this._isCoveredSet = false, this._isVisited = false, 0 === arguments.length) ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._label = t2;
          }
        } }]);
      }(), qe = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "isIncidentEdgeInResult", value: function() {
          for (var t3 = this.getEdges().getEdges().iterator(); t3.hasNext(); ) {
            if (t3.next().getEdge().isInResult()) return true;
          }
          return false;
        } }, { key: "isIsolated", value: function() {
          return 1 === this._label.getGeometryCount();
        } }, { key: "getCoordinate", value: function() {
          return this._coord;
        } }, { key: "print", value: function(t3) {
          t3.println("node " + this._coord + " lbl: " + this._label);
        } }, { key: "computeIM", value: function(t3) {
        } }, { key: "computeMergedLocation", value: function(t3, e2) {
          var n2 = H.NONE;
          if (n2 = this._label.getLocation(e2), !t3.isNull(e2)) {
            var i3 = t3.getLocation(e2);
            n2 !== H.BOUNDARY && (n2 = i3);
          }
          return n2;
        } }, { key: "setLabel", value: function() {
          if (2 !== arguments.length || !Number.isInteger(arguments[1]) || !Number.isInteger(arguments[0])) return f(i2, "setLabel", this, 1).apply(this, arguments);
          var t3 = arguments[0], e2 = arguments[1];
          null === this._label ? this._label = new Ae(t3, e2) : this._label.setLocation(t3, e2);
        } }, { key: "getEdges", value: function() {
          return this._edges;
        } }, { key: "mergeLabel", value: function() {
          if (arguments[0] instanceof i2) {
            var t3 = arguments[0];
            this.mergeLabel(t3._label);
          } else if (arguments[0] instanceof Ae) for (var e2 = arguments[0], n2 = 0; n2 < 2; n2++) {
            var r2 = this.computeMergedLocation(e2, n2);
            this._label.getLocation(n2) === H.NONE && this._label.setLocation(n2, r2);
          }
        } }, { key: "add", value: function(t3) {
          this._edges.insert(t3), t3.setNode(this);
        } }, { key: "setLabelBoundary", value: function(t3) {
          if (null === this._label) return null;
          var e2 = H.NONE;
          null !== this._label && (e2 = this._label.getLocation(t3));
          var n2 = null;
          switch (e2) {
            case H.BOUNDARY:
              n2 = H.INTERIOR;
              break;
            case H.INTERIOR:
            default:
              n2 = H.BOUNDARY;
          }
          this._label.setLocation(t3, n2);
        } }], [{ key: "constructor_", value: function() {
          this._coord = null, this._edges = null;
          var t3 = arguments[0], e2 = arguments[1];
          this._coord = t3, this._edges = e2, this._label = new Ae(0, H.NONE);
        } }]);
      }(Ge), Ye = function(t2) {
        function i2() {
          return n(this, i2), e(this, i2, arguments);
        }
        return l(i2, t2), s(i2);
      }(ee);
      function ze(t2) {
        return null == t2 ? 0 : t2.color;
      }
      function Xe(t2) {
        return null == t2 ? null : t2.parent;
      }
      function Be(t2, e2) {
        null !== t2 && (t2.color = e2);
      }
      function Ue(t2) {
        return null == t2 ? null : t2.left;
      }
      function Ve(t2) {
        return null == t2 ? null : t2.right;
      }
      var He = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), (t3 = e(this, i2)).root_ = null, t3.size_ = 0, t3;
        }
        return l(i2, t2), s(i2, [{ key: "get", value: function(t3) {
          for (var e2 = this.root_; null !== e2; ) {
            var n2 = t3.compareTo(e2.key);
            if (n2 < 0) e2 = e2.left;
            else {
              if (!(n2 > 0)) return e2.value;
              e2 = e2.right;
            }
          }
          return null;
        } }, { key: "put", value: function(t3, e2) {
          if (null === this.root_) return this.root_ = { key: t3, value: e2, left: null, right: null, parent: null, color: 0, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } }, this.size_ = 1, null;
          var n2, i3, r2 = this.root_;
          do {
            if (n2 = r2, (i3 = t3.compareTo(r2.key)) < 0) r2 = r2.left;
            else {
              if (!(i3 > 0)) {
                var s2 = r2.value;
                return r2.value = e2, s2;
              }
              r2 = r2.right;
            }
          } while (null !== r2);
          var a2 = { key: t3, left: null, right: null, value: e2, parent: n2, color: 0, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } };
          return i3 < 0 ? n2.left = a2 : n2.right = a2, this.fixAfterInsertion(a2), this.size_++, null;
        } }, { key: "fixAfterInsertion", value: function(t3) {
          var e2;
          for (t3.color = 1; null != t3 && t3 !== this.root_ && 1 === t3.parent.color; ) Xe(t3) === Ue(Xe(Xe(t3))) ? 1 === ze(e2 = Ve(Xe(Xe(t3)))) ? (Be(Xe(t3), 0), Be(e2, 0), Be(Xe(Xe(t3)), 1), t3 = Xe(Xe(t3))) : (t3 === Ve(Xe(t3)) && (t3 = Xe(t3), this.rotateLeft(t3)), Be(Xe(t3), 0), Be(Xe(Xe(t3)), 1), this.rotateRight(Xe(Xe(t3)))) : 1 === ze(e2 = Ue(Xe(Xe(t3)))) ? (Be(Xe(t3), 0), Be(e2, 0), Be(Xe(Xe(t3)), 1), t3 = Xe(Xe(t3))) : (t3 === Ue(Xe(t3)) && (t3 = Xe(t3), this.rotateRight(t3)), Be(Xe(t3), 0), Be(Xe(Xe(t3)), 1), this.rotateLeft(Xe(Xe(t3))));
          this.root_.color = 0;
        } }, { key: "values", value: function() {
          var t3 = new yt(), e2 = this.getFirstEntry();
          if (null !== e2) for (t3.add(e2.value); null !== (e2 = i2.successor(e2)); ) t3.add(e2.value);
          return t3;
        } }, { key: "entrySet", value: function() {
          var t3 = new J(), e2 = this.getFirstEntry();
          if (null !== e2) for (t3.add(e2); null !== (e2 = i2.successor(e2)); ) t3.add(e2);
          return t3;
        } }, { key: "rotateLeft", value: function(t3) {
          if (null != t3) {
            var e2 = t3.right;
            t3.right = e2.left, null != e2.left && (e2.left.parent = t3), e2.parent = t3.parent, null == t3.parent ? this.root_ = e2 : t3.parent.left === t3 ? t3.parent.left = e2 : t3.parent.right = e2, e2.left = t3, t3.parent = e2;
          }
        } }, { key: "rotateRight", value: function(t3) {
          if (null != t3) {
            var e2 = t3.left;
            t3.left = e2.right, null != e2.right && (e2.right.parent = t3), e2.parent = t3.parent, null == t3.parent ? this.root_ = e2 : t3.parent.right === t3 ? t3.parent.right = e2 : t3.parent.left = e2, e2.right = t3, t3.parent = e2;
          }
        } }, { key: "getFirstEntry", value: function() {
          var t3 = this.root_;
          if (null != t3) for (; null != t3.left; ) t3 = t3.left;
          return t3;
        } }, { key: "size", value: function() {
          return this.size_;
        } }, { key: "containsKey", value: function(t3) {
          for (var e2 = this.root_; null !== e2; ) {
            var n2 = t3.compareTo(e2.key);
            if (n2 < 0) e2 = e2.left;
            else {
              if (!(n2 > 0)) return true;
              e2 = e2.right;
            }
          }
          return false;
        } }], [{ key: "successor", value: function(t3) {
          var e2;
          if (null === t3) return null;
          if (null !== t3.right) {
            for (e2 = t3.right; null !== e2.left; ) e2 = e2.left;
            return e2;
          }
          e2 = t3.parent;
          for (var n2 = t3; null !== e2 && n2 === e2.right; ) n2 = e2, e2 = e2.parent;
          return e2;
        } }]);
      }(Ye), Ze = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "find", value: function(t2) {
          return this.nodeMap.get(t2);
        } }, { key: "addNode", value: function() {
          if (arguments[0] instanceof X) {
            var t2 = arguments[0], e2 = this.nodeMap.get(t2);
            return null === e2 && (e2 = this.nodeFact.createNode(t2), this.nodeMap.put(t2, e2)), e2;
          }
          if (arguments[0] instanceof qe) {
            var n2 = arguments[0], i2 = this.nodeMap.get(n2.getCoordinate());
            return null === i2 ? (this.nodeMap.put(n2.getCoordinate(), n2), n2) : (i2.mergeLabel(n2), i2);
          }
        } }, { key: "print", value: function(t2) {
          for (var e2 = this.iterator(); e2.hasNext(); ) {
            e2.next().print(t2);
          }
        } }, { key: "iterator", value: function() {
          return this.nodeMap.values().iterator();
        } }, { key: "values", value: function() {
          return this.nodeMap.values();
        } }, { key: "getBoundaryNodes", value: function(t2) {
          for (var e2 = new yt(), n2 = this.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            i2.getLabel().getLocation(t2) === H.BOUNDARY && e2.add(i2);
          }
          return e2;
        } }, { key: "add", value: function(t2) {
          var e2 = t2.getCoordinate();
          this.addNode(e2).add(t2);
        } }], [{ key: "constructor_", value: function() {
          this.nodeMap = new He(), this.nodeFact = null;
          var t2 = arguments[0];
          this.nodeFact = t2;
        } }]);
      }(), je = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "isNorthern", value: function(e2) {
          return e2 === t2.NE || e2 === t2.NW;
        } }, { key: "isOpposite", value: function(t3, e2) {
          return t3 !== e2 && 2 === (t3 - e2 + 4) % 4;
        } }, { key: "commonHalfPlane", value: function(t3, e2) {
          if (t3 === e2) return t3;
          if (2 === (t3 - e2 + 4) % 4) return -1;
          var n2 = t3 < e2 ? t3 : e2;
          return 0 === n2 && 3 === (t3 > e2 ? t3 : e2) ? 3 : n2;
        } }, { key: "isInHalfPlane", value: function(e2, n2) {
          return n2 === t2.SE ? e2 === t2.SE || e2 === t2.SW : e2 === n2 || e2 === n2 + 1;
        } }, { key: "quadrant", value: function() {
          if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var e2 = arguments[0], n2 = arguments[1];
            if (0 === e2 && 0 === n2) throw new m("Cannot compute the quadrant for point ( " + e2 + ", " + n2 + " )");
            return e2 >= 0 ? n2 >= 0 ? t2.NE : t2.SE : n2 >= 0 ? t2.NW : t2.SW;
          }
          if (arguments[0] instanceof X && arguments[1] instanceof X) {
            var i2 = arguments[0], r2 = arguments[1];
            if (r2.x === i2.x && r2.y === i2.y) throw new m("Cannot compute the quadrant for two identical points " + i2);
            return r2.x >= i2.x ? r2.y >= i2.y ? t2.NE : t2.SE : r2.y >= i2.y ? t2.NW : t2.SW;
          }
        } }]);
      }();
      je.NE = 0, je.NW = 1, je.SW = 2, je.SE = 3;
      var We = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "compareDirection", value: function(t3) {
          return this._dx === t3._dx && this._dy === t3._dy ? 0 : this._quadrant > t3._quadrant ? 1 : this._quadrant < t3._quadrant ? -1 : ct.index(t3._p0, t3._p1, this._p1);
        } }, { key: "getDy", value: function() {
          return this._dy;
        } }, { key: "getCoordinate", value: function() {
          return this._p0;
        } }, { key: "setNode", value: function(t3) {
          this._node = t3;
        } }, { key: "print", value: function(t3) {
          var e2 = Math.atan2(this._dy, this._dx), n2 = this.getClass().getName(), i2 = n2.lastIndexOf("."), r2 = n2.substring(i2 + 1);
          t3.print("  " + r2 + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e2 + "   " + this._label);
        } }, { key: "compareTo", value: function(t3) {
          var e2 = t3;
          return this.compareDirection(e2);
        } }, { key: "getDirectedCoordinate", value: function() {
          return this._p1;
        } }, { key: "getDx", value: function() {
          return this._dx;
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "getEdge", value: function() {
          return this._edge;
        } }, { key: "getQuadrant", value: function() {
          return this._quadrant;
        } }, { key: "getNode", value: function() {
          return this._node;
        } }, { key: "toString", value: function() {
          var t3 = Math.atan2(this._dy, this._dx), e2 = this.getClass().getName(), n2 = e2.lastIndexOf(".");
          return "  " + e2.substring(n2 + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t3 + "   " + this._label;
        } }, { key: "computeLabel", value: function(t3) {
        } }, { key: "init", value: function(t3, e2) {
          this._p0 = t3, this._p1 = e2, this._dx = e2.x - t3.x, this._dy = e2.y - t3.y, this._quadrant = je.quadrant(this._dx, this._dy), G.isTrue(!(0 === this._dx && 0 === this._dy), "EdgeEnd with identical endpoints found");
        } }, { key: "interfaces_", get: function() {
          return [x];
        } }], [{ key: "constructor_", value: function() {
          if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) {
            var e2 = arguments[0];
            this._edge = e2;
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            t2.constructor_.call(this, n2, i2, r2, null);
          } else if (4 === arguments.length) {
            var s2 = arguments[0], a2 = arguments[1], o2 = arguments[2], u3 = arguments[3];
            t2.constructor_.call(this, s2), this.init(a2, o2), this._label = u3;
          }
        } }]);
      }(), Ke = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "getNextMin", value: function() {
          return this._nextMin;
        } }, { key: "getDepth", value: function(t3) {
          return this._depth[t3];
        } }, { key: "setVisited", value: function(t3) {
          this._isVisited = t3;
        } }, { key: "computeDirectedLabel", value: function() {
          this._label = new Ae(this._edge.getLabel()), this._isForward || this._label.flip();
        } }, { key: "getNext", value: function() {
          return this._next;
        } }, { key: "setDepth", value: function(t3, e2) {
          if (-999 !== this._depth[t3] && this._depth[t3] !== e2) throw new gt("assigned depths do not match", this.getCoordinate());
          this._depth[t3] = e2;
        } }, { key: "isInteriorAreaEdge", value: function() {
          for (var t3 = true, e2 = 0; e2 < 2; e2++) this._label.isArea(e2) && this._label.getLocation(e2, $.LEFT) === H.INTERIOR && this._label.getLocation(e2, $.RIGHT) === H.INTERIOR || (t3 = false);
          return t3;
        } }, { key: "setNextMin", value: function(t3) {
          this._nextMin = t3;
        } }, { key: "print", value: function(t3) {
          f(i2, "print", this, 1).call(this, t3), t3.print(" " + this._depth[$.LEFT] + "/" + this._depth[$.RIGHT]), t3.print(" (" + this.getDepthDelta() + ")"), this._isInResult && t3.print(" inResult");
        } }, { key: "setMinEdgeRing", value: function(t3) {
          this._minEdgeRing = t3;
        } }, { key: "isLineEdge", value: function() {
          var t3 = this._label.isLine(0) || this._label.isLine(1), e2 = !this._label.isArea(0) || this._label.allPositionsEqual(0, H.EXTERIOR), n2 = !this._label.isArea(1) || this._label.allPositionsEqual(1, H.EXTERIOR);
          return t3 && e2 && n2;
        } }, { key: "setEdgeRing", value: function(t3) {
          this._edgeRing = t3;
        } }, { key: "getMinEdgeRing", value: function() {
          return this._minEdgeRing;
        } }, { key: "getDepthDelta", value: function() {
          var t3 = this._edge.getDepthDelta();
          return this._isForward || (t3 = -t3), t3;
        } }, { key: "setInResult", value: function(t3) {
          this._isInResult = t3;
        } }, { key: "getSym", value: function() {
          return this._sym;
        } }, { key: "isForward", value: function() {
          return this._isForward;
        } }, { key: "getEdge", value: function() {
          return this._edge;
        } }, { key: "printEdge", value: function(t3) {
          this.print(t3), t3.print(" "), this._isForward ? this._edge.print(t3) : this._edge.printReverse(t3);
        } }, { key: "setSym", value: function(t3) {
          this._sym = t3;
        } }, { key: "setVisitedEdge", value: function(t3) {
          this.setVisited(t3), this._sym.setVisited(t3);
        } }, { key: "setEdgeDepths", value: function(t3, e2) {
          var n2 = this.getEdge().getDepthDelta();
          this._isForward || (n2 = -n2);
          var i3 = 1;
          t3 === $.LEFT && (i3 = -1);
          var r2 = $.opposite(t3), s2 = e2 + n2 * i3;
          this.setDepth(t3, e2), this.setDepth(r2, s2);
        } }, { key: "getEdgeRing", value: function() {
          return this._edgeRing;
        } }, { key: "isInResult", value: function() {
          return this._isInResult;
        } }, { key: "setNext", value: function(t3) {
          this._next = t3;
        } }, { key: "isVisited", value: function() {
          return this._isVisited;
        } }], [{ key: "constructor_", value: function() {
          this._isForward = null, this._isInResult = false, this._isVisited = false, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999];
          var t3 = arguments[0], e2 = arguments[1];
          if (We.constructor_.call(this, t3), this._isForward = e2, e2) this.init(t3.getCoordinate(0), t3.getCoordinate(1));
          else {
            var n2 = t3.getNumPoints() - 1;
            this.init(t3.getCoordinate(n2), t3.getCoordinate(n2 - 1));
          }
          this.computeDirectedLabel();
        } }, { key: "depthFactor", value: function(t3, e2) {
          return t3 === H.EXTERIOR && e2 === H.INTERIOR ? 1 : t3 === H.INTERIOR && e2 === H.EXTERIOR ? -1 : 0;
        } }]);
      }(We), Je = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "createNode", value: function(t2) {
          return new qe(t2, null);
        } }]);
      }(), Qe = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "printEdges", value: function(t2) {
          t2.println("Edges:");
          for (var e2 = 0; e2 < this._edges.size(); e2++) {
            t2.println("edge " + e2 + ":");
            var n2 = this._edges.get(e2);
            n2.print(t2), n2.eiList.print(t2);
          }
        } }, { key: "find", value: function(t2) {
          return this._nodes.find(t2);
        } }, { key: "addNode", value: function() {
          if (arguments[0] instanceof qe) {
            var t2 = arguments[0];
            return this._nodes.addNode(t2);
          }
          if (arguments[0] instanceof X) {
            var e2 = arguments[0];
            return this._nodes.addNode(e2);
          }
        } }, { key: "getNodeIterator", value: function() {
          return this._nodes.iterator();
        } }, { key: "linkResultDirectedEdges", value: function() {
          for (var t2 = this._nodes.iterator(); t2.hasNext(); ) {
            t2.next().getEdges().linkResultDirectedEdges();
          }
        } }, { key: "debugPrintln", value: function(t2) {
          mt.out.println(t2);
        } }, { key: "isBoundaryNode", value: function(t2, e2) {
          var n2 = this._nodes.find(e2);
          if (null === n2) return false;
          var i2 = n2.getLabel();
          return null !== i2 && i2.getLocation(t2) === H.BOUNDARY;
        } }, { key: "linkAllDirectedEdges", value: function() {
          for (var t2 = this._nodes.iterator(); t2.hasNext(); ) {
            t2.next().getEdges().linkAllDirectedEdges();
          }
        } }, { key: "matchInSameDirection", value: function(t2, e2, n2, i2) {
          return !!t2.equals(n2) && (ct.index(t2, e2, i2) === ct.COLLINEAR && je.quadrant(t2, e2) === je.quadrant(n2, i2));
        } }, { key: "getEdgeEnds", value: function() {
          return this._edgeEndList;
        } }, { key: "debugPrint", value: function(t2) {
          mt.out.print(t2);
        } }, { key: "getEdgeIterator", value: function() {
          return this._edges.iterator();
        } }, { key: "findEdgeInSameDirection", value: function(t2, e2) {
          for (var n2 = 0; n2 < this._edges.size(); n2++) {
            var i2 = this._edges.get(n2), r2 = i2.getCoordinates();
            if (this.matchInSameDirection(t2, e2, r2[0], r2[1])) return i2;
            if (this.matchInSameDirection(t2, e2, r2[r2.length - 1], r2[r2.length - 2])) return i2;
          }
          return null;
        } }, { key: "insertEdge", value: function(t2) {
          this._edges.add(t2);
        } }, { key: "findEdgeEnd", value: function(t2) {
          for (var e2 = this.getEdgeEnds().iterator(); e2.hasNext(); ) {
            var n2 = e2.next();
            if (n2.getEdge() === t2) return n2;
          }
          return null;
        } }, { key: "addEdges", value: function(t2) {
          for (var e2 = t2.iterator(); e2.hasNext(); ) {
            var n2 = e2.next();
            this._edges.add(n2);
            var i2 = new Ke(n2, true), r2 = new Ke(n2, false);
            i2.setSym(r2), r2.setSym(i2), this.add(i2), this.add(r2);
          }
        } }, { key: "add", value: function(t2) {
          this._nodes.add(t2), this._edgeEndList.add(t2);
        } }, { key: "getNodes", value: function() {
          return this._nodes.values();
        } }, { key: "findEdge", value: function(t2, e2) {
          for (var n2 = 0; n2 < this._edges.size(); n2++) {
            var i2 = this._edges.get(n2), r2 = i2.getCoordinates();
            if (t2.equals(r2[0]) && e2.equals(r2[1])) return i2;
          }
          return null;
        } }], [{ key: "constructor_", value: function() {
          if (this._edges = new yt(), this._nodes = null, this._edgeEndList = new yt(), 0 === arguments.length) this._nodes = new Ze(new Je());
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._nodes = new Ze(t2);
          }
        } }, { key: "linkResultDirectedEdges", value: function(t2) {
          for (var e2 = t2.iterator(); e2.hasNext(); ) {
            e2.next().getEdges().linkResultDirectedEdges();
          }
        } }]);
      }(), $e = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "sortShellsAndHoles", value: function(t3, e2, n2) {
          for (var i2 = t3.iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2.isHole() ? n2.add(r2) : e2.add(r2);
          }
        } }, { key: "computePolygons", value: function(t3) {
          for (var e2 = new yt(), n2 = t3.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().toPolygon(this._geometryFactory);
            e2.add(i2);
          }
          return e2;
        } }, { key: "placeFreeHoles", value: function(e2, n2) {
          for (var i2 = n2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            if (null === r2.getShell()) {
              var s2 = t2.findEdgeRingContaining(r2, e2);
              if (null === s2) throw new gt("unable to assign hole to a shell", r2.getCoordinate(0));
              r2.setShell(s2);
            }
          }
        } }, { key: "buildMinimalEdgeRings", value: function(t3, e2, n2) {
          for (var i2 = new yt(), r2 = t3.iterator(); r2.hasNext(); ) {
            var s2 = r2.next();
            if (s2.getMaxNodeDegree() > 2) {
              s2.linkDirectedEdgesForMinimalEdgeRings();
              var a2 = s2.buildMinimalRings(), o2 = this.findShell(a2);
              null !== o2 ? (this.placePolygonHoles(o2, a2), e2.add(o2)) : n2.addAll(a2);
            } else i2.add(s2);
          }
          return i2;
        } }, { key: "buildMaximalEdgeRings", value: function(t3) {
          for (var e2 = new yt(), n2 = t3.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (i2.isInResult() && i2.getLabel().isArea() && null === i2.getEdgeRing()) {
              var r2 = new Fe(i2, this._geometryFactory);
              e2.add(r2), r2.setInResult();
            }
          }
          return e2;
        } }, { key: "placePolygonHoles", value: function(t3, e2) {
          for (var n2 = e2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            i2.isHole() && i2.setShell(t3);
          }
        } }, { key: "getPolygons", value: function() {
          return this.computePolygons(this._shellList);
        } }, { key: "findShell", value: function(t3) {
          for (var e2 = 0, n2 = null, i2 = t3.iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2.isHole() || (n2 = r2, e2++);
          }
          return G.isTrue(e2 <= 1, "found two shells in MinimalEdgeRing list"), n2;
        } }, { key: "add", value: function() {
          if (1 === arguments.length) {
            var t3 = arguments[0];
            this.add(t3.getEdgeEnds(), t3.getNodes());
          } else if (2 === arguments.length) {
            var e2 = arguments[0], n2 = arguments[1];
            Qe.linkResultDirectedEdges(n2);
            var i2 = this.buildMaximalEdgeRings(e2), r2 = new yt(), s2 = this.buildMinimalEdgeRings(i2, this._shellList, r2);
            this.sortShellsAndHoles(s2, this._shellList, r2), this.placeFreeHoles(this._shellList, r2);
          }
        } }], [{ key: "constructor_", value: function() {
          this._geometryFactory = null, this._shellList = new yt();
          var t3 = arguments[0];
          this._geometryFactory = t3;
        } }, { key: "findEdgeRingContaining", value: function(t3, e2) {
          for (var n2 = t3.getLinearRing(), i2 = n2.getEnvelopeInternal(), r2 = n2.getCoordinateN(0), s2 = null, a2 = null, o2 = e2.iterator(); o2.hasNext(); ) {
            var u3 = o2.next(), l2 = u3.getLinearRing(), h2 = l2.getEnvelopeInternal();
            if (!h2.equals(i2) && h2.contains(i2)) {
              r2 = jt.ptNotInList(n2.getCoordinates(), l2.getCoordinates());
              var c2 = false;
              be.isInRing(r2, l2.getCoordinates()) && (c2 = true), c2 && (null === s2 || a2.contains(h2)) && (a2 = (s2 = u3).getLinearRing().getEnvelopeInternal());
            }
          }
          return s2;
        } }]);
      }(), tn = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "getBounds", value: function() {
        } }]);
      }(), en = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "getItem", value: function() {
          return this._item;
        } }, { key: "getBounds", value: function() {
          return this._bounds;
        } }, { key: "interfaces_", get: function() {
          return [tn, E];
        } }], [{ key: "constructor_", value: function() {
          this._bounds = null, this._item = null;
          var t2 = arguments[0], e2 = arguments[1];
          this._bounds = t2, this._item = e2;
        } }]);
      }(), nn = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "poll", value: function() {
          if (this.isEmpty()) return null;
          var t2 = this._items.get(1);
          return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t2;
        } }, { key: "size", value: function() {
          return this._size;
        } }, { key: "reorder", value: function(t2) {
          for (var e2 = null, n2 = this._items.get(t2); 2 * t2 <= this._size && ((e2 = 2 * t2) !== this._size && this._items.get(e2 + 1).compareTo(this._items.get(e2)) < 0 && e2++, this._items.get(e2).compareTo(n2) < 0); t2 = e2) this._items.set(t2, this._items.get(e2));
          this._items.set(t2, n2);
        } }, { key: "clear", value: function() {
          this._size = 0, this._items.clear();
        } }, { key: "peek", value: function() {
          return this.isEmpty() ? null : this._items.get(1);
        } }, { key: "isEmpty", value: function() {
          return 0 === this._size;
        } }, { key: "add", value: function(t2) {
          this._items.add(null), this._size += 1;
          var e2 = this._size;
          for (this._items.set(0, t2); t2.compareTo(this._items.get(Math.trunc(e2 / 2))) < 0; e2 /= 2) this._items.set(e2, this._items.get(Math.trunc(e2 / 2)));
          this._items.set(e2, t2);
        } }], [{ key: "constructor_", value: function() {
          this._size = null, this._items = null, this._size = 0, this._items = new yt(), this._items.add(null);
        } }]);
      }(), rn = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "insert", value: function(t2, e2) {
        } }, { key: "remove", value: function(t2, e2) {
        } }, { key: "query", value: function() {
        } }]);
      }(), sn = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "getLevel", value: function() {
          return this._level;
        } }, { key: "size", value: function() {
          return this._childBoundables.size();
        } }, { key: "getChildBoundables", value: function() {
          return this._childBoundables;
        } }, { key: "addChildBoundable", value: function(t2) {
          G.isTrue(null === this._bounds), this._childBoundables.add(t2);
        } }, { key: "isEmpty", value: function() {
          return this._childBoundables.isEmpty();
        } }, { key: "getBounds", value: function() {
          return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds;
        } }, { key: "interfaces_", get: function() {
          return [tn, E];
        } }], [{ key: "constructor_", value: function() {
          if (this._childBoundables = new yt(), this._bounds = null, this._level = null, 0 === arguments.length) ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._level = t2;
          }
        } }]);
      }(), an = { reverseOrder: function() {
        return { compare: function(t2, e2) {
          return e2.compareTo(t2);
        } };
      }, min: function(t2) {
        return an.sort(t2), t2.get(0);
      }, sort: function(t2, e2) {
        var n2 = t2.toArray();
        e2 ? At.sort(n2, e2) : At.sort(n2);
        for (var i2 = t2.iterator(), r2 = 0, s2 = n2.length; r2 < s2; r2++) i2.next(), i2.set(n2[r2]);
      }, singletonList: function(t2) {
        var e2 = new yt();
        return e2.add(t2), e2;
      } }, on = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "maxDistance", value: function(e2, n2, i2, r2, s2, a2, o2, u3) {
          var l2 = t2.distance(e2, n2, s2, a2);
          return l2 = Math.max(l2, t2.distance(e2, n2, o2, u3)), l2 = Math.max(l2, t2.distance(i2, r2, s2, a2)), l2 = Math.max(l2, t2.distance(i2, r2, o2, u3));
        } }, { key: "distance", value: function(t3, e2, n2, i2) {
          var r2 = n2 - t3, s2 = i2 - e2;
          return Math.sqrt(r2 * r2 + s2 * s2);
        } }, { key: "maximumDistance", value: function(e2, n2) {
          var i2 = Math.min(e2.getMinX(), n2.getMinX()), r2 = Math.min(e2.getMinY(), n2.getMinY()), s2 = Math.max(e2.getMaxX(), n2.getMaxX()), a2 = Math.max(e2.getMaxY(), n2.getMaxY());
          return t2.distance(i2, r2, s2, a2);
        } }, { key: "minMaxDistance", value: function(e2, n2) {
          var i2 = e2.getMinX(), r2 = e2.getMinY(), s2 = e2.getMaxX(), a2 = e2.getMaxY(), o2 = n2.getMinX(), u3 = n2.getMinY(), l2 = n2.getMaxX(), h2 = n2.getMaxY(), c2 = t2.maxDistance(i2, r2, i2, a2, o2, u3, o2, h2);
          return c2 = Math.min(c2, t2.maxDistance(i2, r2, i2, a2, o2, u3, l2, u3)), c2 = Math.min(c2, t2.maxDistance(i2, r2, i2, a2, l2, h2, o2, h2)), c2 = Math.min(c2, t2.maxDistance(i2, r2, i2, a2, l2, h2, l2, u3)), c2 = Math.min(c2, t2.maxDistance(i2, r2, s2, r2, o2, u3, o2, h2)), c2 = Math.min(c2, t2.maxDistance(i2, r2, s2, r2, o2, u3, l2, u3)), c2 = Math.min(c2, t2.maxDistance(i2, r2, s2, r2, l2, h2, o2, h2)), c2 = Math.min(c2, t2.maxDistance(i2, r2, s2, r2, l2, h2, l2, u3)), c2 = Math.min(c2, t2.maxDistance(s2, a2, i2, a2, o2, u3, o2, h2)), c2 = Math.min(c2, t2.maxDistance(s2, a2, i2, a2, o2, u3, l2, u3)), c2 = Math.min(c2, t2.maxDistance(s2, a2, i2, a2, l2, h2, o2, h2)), c2 = Math.min(c2, t2.maxDistance(s2, a2, i2, a2, l2, h2, l2, u3)), c2 = Math.min(c2, t2.maxDistance(s2, a2, s2, r2, o2, u3, o2, h2)), c2 = Math.min(c2, t2.maxDistance(s2, a2, s2, r2, o2, u3, l2, u3)), c2 = Math.min(c2, t2.maxDistance(s2, a2, s2, r2, l2, h2, o2, h2)), c2 = Math.min(c2, t2.maxDistance(s2, a2, s2, r2, l2, h2, l2, u3));
        } }]);
      }(), un = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "maximumDistance", value: function() {
          return on.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds());
        } }, { key: "expandToQueue", value: function(e2, n2) {
          var i2 = t2.isComposite(this._boundable1), r2 = t2.isComposite(this._boundable2);
          if (i2 && r2) return t2.area(this._boundable1) > t2.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, false, e2, n2), null) : (this.expand(this._boundable2, this._boundable1, true, e2, n2), null);
          if (i2) return this.expand(this._boundable1, this._boundable2, false, e2, n2), null;
          if (r2) return this.expand(this._boundable2, this._boundable1, true, e2, n2), null;
          throw new m("neither boundable is composite");
        } }, { key: "isLeaves", value: function() {
          return !(t2.isComposite(this._boundable1) || t2.isComposite(this._boundable2));
        } }, { key: "compareTo", value: function(t3) {
          var e2 = t3;
          return this._distance < e2._distance ? -1 : this._distance > e2._distance ? 1 : 0;
        } }, { key: "expand", value: function(e2, n2, i2, r2, s2) {
          for (var a2 = e2.getChildBoundables().iterator(); a2.hasNext(); ) {
            var o2 = a2.next(), u3 = null;
            (u3 = i2 ? new t2(n2, o2, this._itemDistance) : new t2(o2, n2, this._itemDistance)).getDistance() < s2 && r2.add(u3);
          }
        } }, { key: "getBoundable", value: function(t3) {
          return 0 === t3 ? this._boundable1 : this._boundable2;
        } }, { key: "getDistance", value: function() {
          return this._distance;
        } }, { key: "distance", value: function() {
          return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
        } }, { key: "interfaces_", get: function() {
          return [x];
        } }], [{ key: "constructor_", value: function() {
          this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
          var t3 = arguments[0], e2 = arguments[1], n2 = arguments[2];
          this._boundable1 = t3, this._boundable2 = e2, this._itemDistance = n2, this._distance = this.distance();
        } }, { key: "area", value: function(t3) {
          return t3.getBounds().getArea();
        } }, { key: "isComposite", value: function(t3) {
          return t3 instanceof sn;
        } }]);
      }(), ln = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "visitItem", value: function(t2) {
        } }]);
      }(), hn = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "queryInternal", value: function() {
          if (rt(arguments[2], ln) && arguments[0] instanceof Object && arguments[1] instanceof sn) for (var t3 = arguments[0], e2 = arguments[2], n2 = arguments[1].getChildBoundables(), i2 = 0; i2 < n2.size(); i2++) {
            var r2 = n2.get(i2);
            this.getIntersectsOp().intersects(r2.getBounds(), t3) && (r2 instanceof sn ? this.queryInternal(t3, r2, e2) : r2 instanceof en ? e2.visitItem(r2.getItem()) : G.shouldNeverReachHere());
          }
          else if (rt(arguments[2], nt) && arguments[0] instanceof Object && arguments[1] instanceof sn) for (var s2 = arguments[0], a2 = arguments[2], o2 = arguments[1].getChildBoundables(), u3 = 0; u3 < o2.size(); u3++) {
            var l2 = o2.get(u3);
            this.getIntersectsOp().intersects(l2.getBounds(), s2) && (l2 instanceof sn ? this.queryInternal(s2, l2, a2) : l2 instanceof en ? a2.add(l2.getItem()) : G.shouldNeverReachHere());
          }
        } }, { key: "getNodeCapacity", value: function() {
          return this._nodeCapacity;
        } }, { key: "lastNode", value: function(t3) {
          return t3.get(t3.size() - 1);
        } }, { key: "size", value: function() {
          if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
          if (1 === arguments.length) {
            for (var t3 = 0, e2 = arguments[0].getChildBoundables().iterator(); e2.hasNext(); ) {
              var n2 = e2.next();
              n2 instanceof sn ? t3 += this.size(n2) : n2 instanceof en && (t3 += 1);
            }
            return t3;
          }
        } }, { key: "removeItem", value: function(t3, e2) {
          for (var n2 = null, i2 = t3.getChildBoundables().iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2 instanceof en && r2.getItem() === e2 && (n2 = r2);
          }
          return null !== n2 && (t3.getChildBoundables().remove(n2), true);
        } }, { key: "itemsTree", value: function() {
          if (0 === arguments.length) {
            this.build();
            var t3 = this.itemsTree(this._root);
            return null === t3 ? new yt() : t3;
          }
          if (1 === arguments.length) {
            for (var e2 = arguments[0], n2 = new yt(), i2 = e2.getChildBoundables().iterator(); i2.hasNext(); ) {
              var r2 = i2.next();
              if (r2 instanceof sn) {
                var s2 = this.itemsTree(r2);
                null !== s2 && n2.add(s2);
              } else r2 instanceof en ? n2.add(r2.getItem()) : G.shouldNeverReachHere();
            }
            return n2.size() <= 0 ? null : n2;
          }
        } }, { key: "insert", value: function(t3, e2) {
          G.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new en(t3, e2));
        } }, { key: "boundablesAtLevel", value: function() {
          if (1 === arguments.length) {
            var t3 = arguments[0], e2 = new yt();
            return this.boundablesAtLevel(t3, this._root, e2), e2;
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            if (G.isTrue(n2 > -2), i2.getLevel() === n2) return r2.add(i2), null;
            for (var s2 = i2.getChildBoundables().iterator(); s2.hasNext(); ) {
              var a2 = s2.next();
              a2 instanceof sn ? this.boundablesAtLevel(n2, a2, r2) : (G.isTrue(a2 instanceof en), -1 === n2 && r2.add(a2));
            }
            return null;
          }
        } }, { key: "query", value: function() {
          if (1 === arguments.length) {
            var t3 = arguments[0];
            this.build();
            var e2 = new yt();
            return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), t3) && this.queryInternal(t3, this._root, e2), e2;
          }
          if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            if (this.build(), this.isEmpty()) return null;
            this.getIntersectsOp().intersects(this._root.getBounds(), n2) && this.queryInternal(n2, this._root, i2);
          }
        } }, { key: "build", value: function() {
          if (this._built) return null;
          this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = true;
        } }, { key: "getRoot", value: function() {
          return this.build(), this._root;
        } }, { key: "remove", value: function() {
          if (2 === arguments.length) {
            var t3 = arguments[0], e2 = arguments[1];
            return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), t3) && this.remove(t3, this._root, e2);
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], s2 = this.removeItem(i2, r2);
            if (s2) return true;
            for (var a2 = null, o2 = i2.getChildBoundables().iterator(); o2.hasNext(); ) {
              var u3 = o2.next();
              if (this.getIntersectsOp().intersects(u3.getBounds(), n2) && (u3 instanceof sn && (s2 = this.remove(n2, u3, r2)))) {
                a2 = u3;
                break;
              }
            }
            return null !== a2 && a2.getChildBoundables().isEmpty() && i2.getChildBoundables().remove(a2), s2;
          }
        } }, { key: "createHigherLevels", value: function(t3, e2) {
          G.isTrue(!t3.isEmpty());
          var n2 = this.createParentBoundables(t3, e2 + 1);
          return 1 === n2.size() ? n2.get(0) : this.createHigherLevels(n2, e2 + 1);
        } }, { key: "depth", value: function() {
          if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
          if (1 === arguments.length) {
            for (var t3 = 0, e2 = arguments[0].getChildBoundables().iterator(); e2.hasNext(); ) {
              var n2 = e2.next();
              if (n2 instanceof sn) {
                var i2 = this.depth(n2);
                i2 > t3 && (t3 = i2);
              }
            }
            return t3 + 1;
          }
        } }, { key: "createParentBoundables", value: function(t3, e2) {
          G.isTrue(!t3.isEmpty());
          var n2 = new yt();
          n2.add(this.createNode(e2));
          var i2 = new yt(t3);
          an.sort(i2, this.getComparator());
          for (var r2 = i2.iterator(); r2.hasNext(); ) {
            var s2 = r2.next();
            this.lastNode(n2).getChildBoundables().size() === this.getNodeCapacity() && n2.add(this.createNode(e2)), this.lastNode(n2).addChildBoundable(s2);
          }
          return n2;
        } }, { key: "isEmpty", value: function() {
          return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
        } }, { key: "interfaces_", get: function() {
          return [E];
        } }], [{ key: "constructor_", value: function() {
          if (this._root = null, this._built = false, this._itemBoundables = new yt(), this._nodeCapacity = null, 0 === arguments.length) t2.constructor_.call(this, t2.DEFAULT_NODE_CAPACITY);
          else if (1 === arguments.length) {
            var e2 = arguments[0];
            G.isTrue(e2 > 1, "Node capacity must be greater than 1"), this._nodeCapacity = e2;
          }
        } }, { key: "compareDoubles", value: function(t3, e2) {
          return t3 > e2 ? 1 : t3 < e2 ? -1 : 0;
        } }]);
      }();
      hn.IntersectsOp = function() {
      }, hn.DEFAULT_NODE_CAPACITY = 10;
      var cn = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "distance", value: function(t2, e2) {
        } }]);
      }(), fn = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "createParentBoundablesFromVerticalSlices", value: function(t3, e2) {
          G.isTrue(t3.length > 0);
          for (var n2 = new yt(), i3 = 0; i3 < t3.length; i3++) n2.addAll(this.createParentBoundablesFromVerticalSlice(t3[i3], e2));
          return n2;
        } }, { key: "nearestNeighbourK", value: function() {
          if (2 === arguments.length) {
            var t3 = arguments[0], e2 = arguments[1];
            return this.nearestNeighbourK(t3, A.POSITIVE_INFINITY, e2);
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], r2 = arguments[2], s2 = arguments[1], a2 = new nn();
            a2.add(n2);
            for (var o2 = new nn(); !a2.isEmpty() && s2 >= 0; ) {
              var u3 = a2.poll(), l2 = u3.getDistance();
              if (l2 >= s2) break;
              if (u3.isLeaves()) if (o2.size() < r2) o2.add(u3);
              else o2.peek().getDistance() > l2 && (o2.poll(), o2.add(u3)), s2 = o2.peek().getDistance();
              else u3.expandToQueue(a2, s2);
            }
            return i2.getItems(o2);
          }
        } }, { key: "createNode", value: function(t3) {
          return new gn(t3);
        } }, { key: "size", value: function() {
          return 0 === arguments.length ? f(i2, "size", this, 1).call(this) : f(i2, "size", this, 1).apply(this, arguments);
        } }, { key: "insert", value: function() {
          if (!(2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof U)) return f(i2, "insert", this, 1).apply(this, arguments);
          var t3 = arguments[0], e2 = arguments[1];
          if (t3.isNull()) return null;
          f(i2, "insert", this, 1).call(this, t3, e2);
        } }, { key: "getIntersectsOp", value: function() {
          return i2.intersectsOp;
        } }, { key: "verticalSlices", value: function(t3, e2) {
          for (var n2 = Math.trunc(Math.ceil(t3.size() / e2)), i3 = new Array(e2).fill(null), r2 = t3.iterator(), s2 = 0; s2 < e2; s2++) {
            i3[s2] = new yt();
            for (var a2 = 0; r2.hasNext() && a2 < n2; ) {
              var o2 = r2.next();
              i3[s2].add(o2), a2++;
            }
          }
          return i3;
        } }, { key: "query", value: function() {
          if (1 === arguments.length) {
            var t3 = arguments[0];
            return f(i2, "query", this, 1).call(this, t3);
          }
          if (2 === arguments.length) {
            var e2 = arguments[0], n2 = arguments[1];
            f(i2, "query", this, 1).call(this, e2, n2);
          }
        } }, { key: "getComparator", value: function() {
          return i2.yComparator;
        } }, { key: "createParentBoundablesFromVerticalSlice", value: function(t3, e2) {
          return f(i2, "createParentBoundables", this, 1).call(this, t3, e2);
        } }, { key: "remove", value: function() {
          if (2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof U) {
            var t3 = arguments[0], e2 = arguments[1];
            return f(i2, "remove", this, 1).call(this, t3, e2);
          }
          return f(i2, "remove", this, 1).apply(this, arguments);
        } }, { key: "depth", value: function() {
          return 0 === arguments.length ? f(i2, "depth", this, 1).call(this) : f(i2, "depth", this, 1).apply(this, arguments);
        } }, { key: "createParentBoundables", value: function(t3, e2) {
          G.isTrue(!t3.isEmpty());
          var n2 = Math.trunc(Math.ceil(t3.size() / this.getNodeCapacity())), r2 = new yt(t3);
          an.sort(r2, i2.xComparator);
          var s2 = this.verticalSlices(r2, Math.trunc(Math.ceil(Math.sqrt(n2))));
          return this.createParentBoundablesFromVerticalSlices(s2, e2);
        } }, { key: "nearestNeighbour", value: function() {
          if (1 === arguments.length) {
            if (rt(arguments[0], cn)) {
              var t3 = arguments[0];
              if (this.isEmpty()) return null;
              var e2 = new un(this.getRoot(), this.getRoot(), t3);
              return this.nearestNeighbour(e2);
            }
            if (arguments[0] instanceof un) {
              var n2 = arguments[0], i3 = A.POSITIVE_INFINITY, r2 = null, s2 = new nn();
              for (s2.add(n2); !s2.isEmpty() && i3 > 0; ) {
                var a2 = s2.poll(), o2 = a2.getDistance();
                if (o2 >= i3) break;
                a2.isLeaves() ? (i3 = o2, r2 = a2) : a2.expandToQueue(s2, i3);
              }
              return null === r2 ? null : [r2.getBoundable(0).getItem(), r2.getBoundable(1).getItem()];
            }
          } else {
            if (2 === arguments.length) {
              var u3 = arguments[0], l2 = arguments[1];
              if (this.isEmpty() || u3.isEmpty()) return null;
              var h2 = new un(this.getRoot(), u3.getRoot(), l2);
              return this.nearestNeighbour(h2);
            }
            if (3 === arguments.length) {
              var c2 = arguments[2], f2 = new en(arguments[0], arguments[1]), g2 = new un(this.getRoot(), f2, c2);
              return this.nearestNeighbour(g2)[0];
            }
            if (4 === arguments.length) {
              var v2 = arguments[2], y2 = arguments[3], d2 = new en(arguments[0], arguments[1]), _2 = new un(this.getRoot(), d2, v2);
              return this.nearestNeighbourK(_2, y2);
            }
          }
        } }, { key: "isWithinDistance", value: function() {
          if (2 === arguments.length) {
            var t3 = arguments[0], e2 = arguments[1], n2 = A.POSITIVE_INFINITY, i3 = new nn();
            for (i3.add(t3); !i3.isEmpty(); ) {
              var r2 = i3.poll(), s2 = r2.getDistance();
              if (s2 > e2) return false;
              if (r2.maximumDistance() <= e2) return true;
              if (r2.isLeaves()) {
                if ((n2 = s2) <= e2) return true;
              } else r2.expandToQueue(i3, n2);
            }
            return false;
          }
          if (3 === arguments.length) {
            var a2 = arguments[0], o2 = arguments[1], u3 = arguments[2], l2 = new un(this.getRoot(), a2.getRoot(), o2);
            return this.isWithinDistance(l2, u3);
          }
        } }, { key: "interfaces_", get: function() {
          return [rn, E];
        } }], [{ key: "constructor_", value: function() {
          if (0 === arguments.length) i2.constructor_.call(this, i2.DEFAULT_NODE_CAPACITY);
          else if (1 === arguments.length) {
            var t3 = arguments[0];
            hn.constructor_.call(this, t3);
          }
        } }, { key: "centreX", value: function(t3) {
          return i2.avg(t3.getMinX(), t3.getMaxX());
        } }, { key: "avg", value: function(t3, e2) {
          return (t3 + e2) / 2;
        } }, { key: "getItems", value: function(t3) {
          for (var e2 = new Array(t3.size()).fill(null), n2 = 0; !t3.isEmpty(); ) {
            var i3 = t3.poll();
            e2[n2] = i3.getBoundable(0).getItem(), n2++;
          }
          return e2;
        } }, { key: "centreY", value: function(t3) {
          return i2.avg(t3.getMinY(), t3.getMaxY());
        } }]);
      }(hn), gn = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "computeBounds", value: function() {
          for (var t3 = null, e2 = this.getChildBoundables().iterator(); e2.hasNext(); ) {
            var n2 = e2.next();
            null === t3 ? t3 = new U(n2.getBounds()) : t3.expandToInclude(n2.getBounds());
          }
          return t3;
        } }], [{ key: "constructor_", value: function() {
          var t3 = arguments[0];
          sn.constructor_.call(this, t3);
        } }]);
      }(sn);
      fn.STRtreeNode = gn, fn.xComparator = new (function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "interfaces_", get: function() {
          return [P];
        } }, { key: "compare", value: function(t2, e2) {
          return hn.compareDoubles(fn.centreX(t2.getBounds()), fn.centreX(e2.getBounds()));
        } }]);
      }())(), fn.yComparator = new (function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "interfaces_", get: function() {
          return [P];
        } }, { key: "compare", value: function(t2, e2) {
          return hn.compareDoubles(fn.centreY(t2.getBounds()), fn.centreY(e2.getBounds()));
        } }]);
      }())(), fn.intersectsOp = new (function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "interfaces_", get: function() {
          return [IntersectsOp];
        } }, { key: "intersects", value: function(t2, e2) {
          return t2.intersects(e2);
        } }]);
      }())(), fn.DEFAULT_NODE_CAPACITY = 10;
      var vn = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "relativeSign", value: function(t3, e2) {
          return t3 < e2 ? -1 : t3 > e2 ? 1 : 0;
        } }, { key: "compare", value: function(e2, n2, i2) {
          if (n2.equals2D(i2)) return 0;
          var r2 = t2.relativeSign(n2.x, i2.x), s2 = t2.relativeSign(n2.y, i2.y);
          switch (e2) {
            case 0:
              return t2.compareValue(r2, s2);
            case 1:
              return t2.compareValue(s2, r2);
            case 2:
              return t2.compareValue(s2, -r2);
            case 3:
              return t2.compareValue(-r2, s2);
            case 4:
              return t2.compareValue(-r2, -s2);
            case 5:
              return t2.compareValue(-s2, -r2);
            case 6:
              return t2.compareValue(-s2, r2);
            case 7:
              return t2.compareValue(r2, -s2);
          }
          return G.shouldNeverReachHere("invalid octant value"), 0;
        } }, { key: "compareValue", value: function(t3, e2) {
          return t3 < 0 ? -1 : t3 > 0 ? 1 : e2 < 0 ? -1 : e2 > 0 ? 1 : 0;
        } }]);
      }(), yn = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "getCoordinate", value: function() {
          return this.coord;
        } }, { key: "print", value: function(t2) {
          t2.print(this.coord), t2.print(" seg # = " + this.segmentIndex);
        } }, { key: "compareTo", value: function(t2) {
          var e2 = t2;
          return this.segmentIndex < e2.segmentIndex ? -1 : this.segmentIndex > e2.segmentIndex ? 1 : this.coord.equals2D(e2.coord) ? 0 : this._isInterior ? e2._isInterior ? vn.compare(this._segmentOctant, this.coord, e2.coord) : 1 : -1;
        } }, { key: "isEndPoint", value: function(t2) {
          return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t2;
        } }, { key: "toString", value: function() {
          return this.segmentIndex + ":" + this.coord.toString();
        } }, { key: "isInterior", value: function() {
          return this._isInterior;
        } }, { key: "interfaces_", get: function() {
          return [x];
        } }], [{ key: "constructor_", value: function() {
          this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
          var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i2 = arguments[3];
          this._segString = t2, this.coord = new X(e2), this.segmentIndex = n2, this._segmentOctant = i2, this._isInterior = !e2.equals2D(t2.getCoordinate(n2));
        } }]);
      }(), dn = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "hasNext", value: function() {
        } }, { key: "next", value: function() {
        } }, { key: "remove", value: function() {
        } }]);
      }(), _n = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "getSplitCoordinates", value: function() {
          var t2 = new Zt();
          this.addEndpoints();
          for (var e2 = this.iterator(), n2 = e2.next(); e2.hasNext(); ) {
            var i2 = e2.next();
            this.addEdgeCoordinates(n2, i2, t2), n2 = i2;
          }
          return t2.toCoordinateArray();
        } }, { key: "addCollapsedNodes", value: function() {
          var t2 = new yt();
          this.findCollapsesFromInsertedNodes(t2), this.findCollapsesFromExistingVertices(t2);
          for (var e2 = t2.iterator(); e2.hasNext(); ) {
            var n2 = e2.next().intValue();
            this.add(this._edge.getCoordinate(n2), n2);
          }
        } }, { key: "createSplitEdgePts", value: function(t2, e2) {
          var n2 = e2.segmentIndex - t2.segmentIndex + 2;
          if (2 === n2) return [new X(t2.coord), new X(e2.coord)];
          var i2 = this._edge.getCoordinate(e2.segmentIndex), r2 = e2.isInterior() || !e2.coord.equals2D(i2);
          r2 || n2--;
          var s2 = new Array(n2).fill(null), a2 = 0;
          s2[a2++] = new X(t2.coord);
          for (var o2 = t2.segmentIndex + 1; o2 <= e2.segmentIndex; o2++) s2[a2++] = this._edge.getCoordinate(o2);
          return r2 && (s2[a2] = new X(e2.coord)), s2;
        } }, { key: "print", value: function(t2) {
          t2.println("Intersections:");
          for (var e2 = this.iterator(); e2.hasNext(); ) {
            e2.next().print(t2);
          }
        } }, { key: "findCollapsesFromExistingVertices", value: function(t2) {
          for (var e2 = 0; e2 < this._edge.size() - 2; e2++) {
            var n2 = this._edge.getCoordinate(e2);
            this._edge.getCoordinate(e2 + 1);
            var i2 = this._edge.getCoordinate(e2 + 2);
            n2.equals2D(i2) && t2.add(at.valueOf(e2 + 1));
          }
        } }, { key: "addEdgeCoordinates", value: function(t2, e2, n2) {
          var i2 = this.createSplitEdgePts(t2, e2);
          n2.add(i2, false);
        } }, { key: "iterator", value: function() {
          return this._nodeMap.values().iterator();
        } }, { key: "addSplitEdges", value: function(t2) {
          this.addEndpoints(), this.addCollapsedNodes();
          for (var e2 = this.iterator(), n2 = e2.next(); e2.hasNext(); ) {
            var i2 = e2.next(), r2 = this.createSplitEdge(n2, i2);
            t2.add(r2), n2 = i2;
          }
        } }, { key: "findCollapseIndex", value: function(t2, e2, n2) {
          if (!t2.coord.equals2D(e2.coord)) return false;
          var i2 = e2.segmentIndex - t2.segmentIndex;
          return e2.isInterior() || i2--, 1 === i2 && (n2[0] = t2.segmentIndex + 1, true);
        } }, { key: "findCollapsesFromInsertedNodes", value: function(t2) {
          for (var e2 = new Array(1).fill(null), n2 = this.iterator(), i2 = n2.next(); n2.hasNext(); ) {
            var r2 = n2.next();
            this.findCollapseIndex(i2, r2, e2) && t2.add(at.valueOf(e2[0])), i2 = r2;
          }
        } }, { key: "getEdge", value: function() {
          return this._edge;
        } }, { key: "addEndpoints", value: function() {
          var t2 = this._edge.size() - 1;
          this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t2), t2);
        } }, { key: "createSplitEdge", value: function(t2, e2) {
          var n2 = this.createSplitEdgePts(t2, e2);
          return new xn(n2, this._edge.getData());
        } }, { key: "add", value: function(t2, e2) {
          var n2 = new yn(this._edge, t2, e2, this._edge.getSegmentOctant(e2)), i2 = this._nodeMap.get(n2);
          return null !== i2 ? (G.isTrue(i2.coord.equals2D(t2), "Found equal nodes with different coordinates"), i2) : (this._nodeMap.put(n2, n2), n2);
        } }, { key: "checkSplitEdgesCorrectness", value: function(t2) {
          var e2 = this._edge.getCoordinates(), n2 = t2.get(0).getCoordinate(0);
          if (!n2.equals2D(e2[0])) throw new D2("bad split edge start point at " + n2);
          var i2 = t2.get(t2.size() - 1).getCoordinates(), r2 = i2[i2.length - 1];
          if (!r2.equals2D(e2[e2.length - 1])) throw new D2("bad split edge end point at " + r2);
        } }], [{ key: "constructor_", value: function() {
          this._nodeMap = new He(), this._edge = null;
          var t2 = arguments[0];
          this._edge = t2;
        } }]);
      }(), pn = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "octant", value: function() {
          if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var e2 = arguments[0], n2 = arguments[1];
            if (0 === e2 && 0 === n2) throw new m("Cannot compute the octant for point ( " + e2 + ", " + n2 + " )");
            var i2 = Math.abs(e2), r2 = Math.abs(n2);
            return e2 >= 0 ? n2 >= 0 ? i2 >= r2 ? 0 : 1 : i2 >= r2 ? 7 : 6 : n2 >= 0 ? i2 >= r2 ? 3 : 2 : i2 >= r2 ? 4 : 5;
          }
          if (arguments[0] instanceof X && arguments[1] instanceof X) {
            var s2 = arguments[0], a2 = arguments[1], o2 = a2.x - s2.x, u3 = a2.y - s2.y;
            if (0 === o2 && 0 === u3) throw new m("Cannot compute the octant for two identical points " + s2);
            return t2.octant(o2, u3);
          }
        } }]);
      }(), mn = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "getCoordinates", value: function() {
        } }, { key: "size", value: function() {
        } }, { key: "getCoordinate", value: function(t2) {
        } }, { key: "isClosed", value: function() {
        } }, { key: "setData", value: function(t2) {
        } }, { key: "getData", value: function() {
        } }]);
      }(), kn = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "addIntersection", value: function(t2, e2) {
        } }, { key: "interfaces_", get: function() {
          return [mn];
        } }]);
      }(), xn = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "getCoordinates", value: function() {
          return this._pts;
        } }, { key: "size", value: function() {
          return this._pts.length;
        } }, { key: "getCoordinate", value: function(t3) {
          return this._pts[t3];
        } }, { key: "isClosed", value: function() {
          return this._pts[0].equals(this._pts[this._pts.length - 1]);
        } }, { key: "getSegmentOctant", value: function(t3) {
          return t3 === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t3), this.getCoordinate(t3 + 1));
        } }, { key: "setData", value: function(t3) {
          this._data = t3;
        } }, { key: "safeOctant", value: function(t3, e2) {
          return t3.equals2D(e2) ? 0 : pn.octant(t3, e2);
        } }, { key: "getData", value: function() {
          return this._data;
        } }, { key: "addIntersection", value: function() {
          if (2 === arguments.length) {
            var t3 = arguments[0], e2 = arguments[1];
            this.addIntersectionNode(t3, e2);
          } else if (4 === arguments.length) {
            var n2 = arguments[1], i2 = arguments[3], r2 = new X(arguments[0].getIntersection(i2));
            this.addIntersection(r2, n2);
          }
        } }, { key: "toString", value: function() {
          return Ce.toLineString(new Qt(this._pts));
        } }, { key: "getNodeList", value: function() {
          return this._nodeList;
        } }, { key: "addIntersectionNode", value: function(t3, e2) {
          var n2 = e2, i2 = n2 + 1;
          if (i2 < this._pts.length) {
            var r2 = this._pts[i2];
            t3.equals2D(r2) && (n2 = i2);
          }
          return this._nodeList.add(t3, n2);
        } }, { key: "addIntersections", value: function(t3, e2, n2) {
          for (var i2 = 0; i2 < t3.getIntersectionNum(); i2++) this.addIntersection(t3, e2, n2, i2);
        } }, { key: "interfaces_", get: function() {
          return [kn];
        } }], [{ key: "constructor_", value: function() {
          this._nodeList = new _n(this), this._pts = null, this._data = null;
          var t3 = arguments[0], e2 = arguments[1];
          this._pts = t3, this._data = e2;
        } }, { key: "getNodedSubstrings", value: function() {
          if (1 === arguments.length) {
            var e2 = arguments[0], n2 = new yt();
            return t2.getNodedSubstrings(e2, n2), n2;
          }
          if (2 === arguments.length) for (var i2 = arguments[1], r2 = arguments[0].iterator(); r2.hasNext(); ) {
            r2.next().getNodeList().addSplitEdges(i2);
          }
        } }]);
      }(), In = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "minX", value: function() {
          return Math.min(this.p0.x, this.p1.x);
        } }, { key: "orientationIndex", value: function() {
          if (arguments[0] instanceof t2) {
            var e2 = arguments[0], n2 = ct.index(this.p0, this.p1, e2.p0), i2 = ct.index(this.p0, this.p1, e2.p1);
            return n2 >= 0 && i2 >= 0 || n2 <= 0 && i2 <= 0 ? Math.max(n2, i2) : 0;
          }
          if (arguments[0] instanceof X) {
            var r2 = arguments[0];
            return ct.index(this.p0, this.p1, r2);
          }
        } }, { key: "toGeometry", value: function(t3) {
          return t3.createLineString([this.p0, this.p1]);
        } }, { key: "isVertical", value: function() {
          return this.p0.x === this.p1.x;
        } }, { key: "equals", value: function(e2) {
          if (!(e2 instanceof t2)) return false;
          var n2 = e2;
          return this.p0.equals(n2.p0) && this.p1.equals(n2.p1);
        } }, { key: "intersection", value: function(t3) {
          var e2 = new we();
          return e2.computeIntersection(this.p0, this.p1, t3.p0, t3.p1), e2.hasIntersection() ? e2.getIntersection(0) : null;
        } }, { key: "project", value: function() {
          if (arguments[0] instanceof X) {
            var e2 = arguments[0];
            if (e2.equals(this.p0) || e2.equals(this.p1)) return new X(e2);
            var n2 = this.projectionFactor(e2), i2 = new X();
            return i2.x = this.p0.x + n2 * (this.p1.x - this.p0.x), i2.y = this.p0.y + n2 * (this.p1.y - this.p0.y), i2;
          }
          if (arguments[0] instanceof t2) {
            var r2 = arguments[0], s2 = this.projectionFactor(r2.p0), a2 = this.projectionFactor(r2.p1);
            if (s2 >= 1 && a2 >= 1) return null;
            if (s2 <= 0 && a2 <= 0) return null;
            var o2 = this.project(r2.p0);
            s2 < 0 && (o2 = this.p0), s2 > 1 && (o2 = this.p1);
            var u3 = this.project(r2.p1);
            return a2 < 0 && (u3 = this.p0), a2 > 1 && (u3 = this.p1), new t2(o2, u3);
          }
        } }, { key: "normalize", value: function() {
          this.p1.compareTo(this.p0) < 0 && this.reverse();
        } }, { key: "angle", value: function() {
          return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
        } }, { key: "getCoordinate", value: function(t3) {
          return 0 === t3 ? this.p0 : this.p1;
        } }, { key: "distancePerpendicular", value: function(t3) {
          return xt.pointToLinePerpendicular(t3, this.p0, this.p1);
        } }, { key: "minY", value: function() {
          return Math.min(this.p0.y, this.p1.y);
        } }, { key: "midPoint", value: function() {
          return t2.midPoint(this.p0, this.p1);
        } }, { key: "projectionFactor", value: function(t3) {
          if (t3.equals(this.p0)) return 0;
          if (t3.equals(this.p1)) return 1;
          var e2 = this.p1.x - this.p0.x, n2 = this.p1.y - this.p0.y, i2 = e2 * e2 + n2 * n2;
          return i2 <= 0 ? A.NaN : ((t3.x - this.p0.x) * e2 + (t3.y - this.p0.y) * n2) / i2;
        } }, { key: "closestPoints", value: function(t3) {
          var e2 = this.intersection(t3);
          if (null !== e2) return [e2, e2];
          var n2 = new Array(2).fill(null), i2 = A.MAX_VALUE, r2 = null, s2 = this.closestPoint(t3.p0);
          i2 = s2.distance(t3.p0), n2[0] = s2, n2[1] = t3.p0;
          var a2 = this.closestPoint(t3.p1);
          (r2 = a2.distance(t3.p1)) < i2 && (i2 = r2, n2[0] = a2, n2[1] = t3.p1);
          var o2 = t3.closestPoint(this.p0);
          (r2 = o2.distance(this.p0)) < i2 && (i2 = r2, n2[0] = this.p0, n2[1] = o2);
          var u3 = t3.closestPoint(this.p1);
          return (r2 = u3.distance(this.p1)) < i2 && (i2 = r2, n2[0] = this.p1, n2[1] = u3), n2;
        } }, { key: "closestPoint", value: function(t3) {
          var e2 = this.projectionFactor(t3);
          return e2 > 0 && e2 < 1 ? this.project(t3) : this.p0.distance(t3) < this.p1.distance(t3) ? this.p0 : this.p1;
        } }, { key: "maxX", value: function() {
          return Math.max(this.p0.x, this.p1.x);
        } }, { key: "getLength", value: function() {
          return this.p0.distance(this.p1);
        } }, { key: "compareTo", value: function(t3) {
          var e2 = t3, n2 = this.p0.compareTo(e2.p0);
          return 0 !== n2 ? n2 : this.p1.compareTo(e2.p1);
        } }, { key: "reverse", value: function() {
          var t3 = this.p0;
          this.p0 = this.p1, this.p1 = t3;
        } }, { key: "equalsTopo", value: function(t3) {
          return this.p0.equals(t3.p0) && this.p1.equals(t3.p1) || this.p0.equals(t3.p1) && this.p1.equals(t3.p0);
        } }, { key: "lineIntersection", value: function(t3) {
          return pt.intersection(this.p0, this.p1, t3.p0, t3.p1);
        } }, { key: "maxY", value: function() {
          return Math.max(this.p0.y, this.p1.y);
        } }, { key: "pointAlongOffset", value: function(t3, e2) {
          var n2 = this.p0.x + t3 * (this.p1.x - this.p0.x), i2 = this.p0.y + t3 * (this.p1.y - this.p0.y), r2 = this.p1.x - this.p0.x, s2 = this.p1.y - this.p0.y, a2 = Math.sqrt(r2 * r2 + s2 * s2), o2 = 0, u3 = 0;
          if (0 !== e2) {
            if (a2 <= 0) throw new IllegalStateException("Cannot compute offset from zero-length line segment");
            o2 = e2 * r2 / a2, u3 = e2 * s2 / a2;
          }
          return new X(n2 - u3, i2 + o2);
        } }, { key: "setCoordinates", value: function() {
          if (1 === arguments.length) {
            var t3 = arguments[0];
            this.setCoordinates(t3.p0, t3.p1);
          } else if (2 === arguments.length) {
            var e2 = arguments[0], n2 = arguments[1];
            this.p0.x = e2.x, this.p0.y = e2.y, this.p1.x = n2.x, this.p1.y = n2.y;
          }
        } }, { key: "segmentFraction", value: function(t3) {
          var e2 = this.projectionFactor(t3);
          return e2 < 0 ? e2 = 0 : (e2 > 1 || A.isNaN(e2)) && (e2 = 1), e2;
        } }, { key: "toString", value: function() {
          return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
        } }, { key: "isHorizontal", value: function() {
          return this.p0.y === this.p1.y;
        } }, { key: "reflect", value: function(t3) {
          var e2 = this.p1.getY() - this.p0.getY(), n2 = this.p0.getX() - this.p1.getX(), i2 = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY()), r2 = e2 * e2 + n2 * n2, s2 = e2 * e2 - n2 * n2, a2 = t3.getX(), o2 = t3.getY();
          return new X((-s2 * a2 - 2 * e2 * n2 * o2 - 2 * e2 * i2) / r2, (s2 * o2 - 2 * e2 * n2 * a2 - 2 * n2 * i2) / r2);
        } }, { key: "distance", value: function() {
          if (arguments[0] instanceof t2) {
            var e2 = arguments[0];
            return xt.segmentToSegment(this.p0, this.p1, e2.p0, e2.p1);
          }
          if (arguments[0] instanceof X) {
            var n2 = arguments[0];
            return xt.pointToSegment(n2, this.p0, this.p1);
          }
        } }, { key: "pointAlong", value: function(t3) {
          var e2 = new X();
          return e2.x = this.p0.x + t3 * (this.p1.x - this.p0.x), e2.y = this.p0.y + t3 * (this.p1.y - this.p0.y), e2;
        } }, { key: "hashCode", value: function() {
          var t3 = A.doubleToLongBits(this.p0.x);
          t3 ^= 31 * A.doubleToLongBits(this.p0.y);
          var e2 = Math.trunc(t3) ^ Math.trunc(t3 >> 32), n2 = A.doubleToLongBits(this.p1.x);
          return n2 ^= 31 * A.doubleToLongBits(this.p1.y), e2 ^ (Math.trunc(n2) ^ Math.trunc(n2 >> 32));
        } }, { key: "interfaces_", get: function() {
          return [x, E];
        } }], [{ key: "constructor_", value: function() {
          if (this.p0 = null, this.p1 = null, 0 === arguments.length) t2.constructor_.call(this, new X(), new X());
          else if (1 === arguments.length) {
            var e2 = arguments[0];
            t2.constructor_.call(this, e2.p0, e2.p1);
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this.p0 = n2, this.p1 = i2;
          } else if (4 === arguments.length) {
            var r2 = arguments[0], s2 = arguments[1], a2 = arguments[2], o2 = arguments[3];
            t2.constructor_.call(this, new X(r2, s2), new X(a2, o2));
          }
        } }, { key: "midPoint", value: function(t3, e2) {
          return new X((t3.x + e2.x) / 2, (t3.y + e2.y) / 2);
        } }]);
      }(), En = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "overlap", value: function() {
          if (2 === arguments.length) ;
          else if (4 === arguments.length) {
            var t2 = arguments[1], e2 = arguments[2], n2 = arguments[3];
            arguments[0].getLineSegment(t2, this._overlapSeg1), e2.getLineSegment(n2, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
          }
        } }], [{ key: "constructor_", value: function() {
          this._overlapSeg1 = new In(), this._overlapSeg2 = new In();
        } }]);
      }(), Nn = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "getLineSegment", value: function(t2, e2) {
          e2.p0 = this._pts[t2], e2.p1 = this._pts[t2 + 1];
        } }, { key: "computeSelect", value: function(t2, e2, n2, i2) {
          var r2 = this._pts[e2], s2 = this._pts[n2];
          if (n2 - e2 == 1) return i2.select(this, e2), null;
          if (!t2.intersects(r2, s2)) return null;
          var a2 = Math.trunc((e2 + n2) / 2);
          e2 < a2 && this.computeSelect(t2, e2, a2, i2), a2 < n2 && this.computeSelect(t2, a2, n2, i2);
        } }, { key: "getCoordinates", value: function() {
          for (var t2 = new Array(this._end - this._start + 1).fill(null), e2 = 0, n2 = this._start; n2 <= this._end; n2++) t2[e2++] = this._pts[n2];
          return t2;
        } }, { key: "computeOverlaps", value: function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e2 = arguments[1];
            this.computeOverlaps(this._start, this._end, t2, t2._start, t2._end, e2);
          } else if (6 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], s2 = arguments[3], a2 = arguments[4], o2 = arguments[5];
            if (i2 - n2 == 1 && a2 - s2 == 1) return o2.overlap(this, n2, r2, s2), null;
            if (!this.overlaps(n2, i2, r2, s2, a2)) return null;
            var u3 = Math.trunc((n2 + i2) / 2), l2 = Math.trunc((s2 + a2) / 2);
            n2 < u3 && (s2 < l2 && this.computeOverlaps(n2, u3, r2, s2, l2, o2), l2 < a2 && this.computeOverlaps(n2, u3, r2, l2, a2, o2)), u3 < i2 && (s2 < l2 && this.computeOverlaps(u3, i2, r2, s2, l2, o2), l2 < a2 && this.computeOverlaps(u3, i2, r2, l2, a2, o2));
          }
        } }, { key: "setId", value: function(t2) {
          this._id = t2;
        } }, { key: "select", value: function(t2, e2) {
          this.computeSelect(t2, this._start, this._end, e2);
        } }, { key: "getEnvelope", value: function() {
          if (null === this._env) {
            var t2 = this._pts[this._start], e2 = this._pts[this._end];
            this._env = new U(t2, e2);
          }
          return this._env;
        } }, { key: "overlaps", value: function(t2, e2, n2, i2, r2) {
          return U.intersects(this._pts[t2], this._pts[e2], n2._pts[i2], n2._pts[r2]);
        } }, { key: "getEndIndex", value: function() {
          return this._end;
        } }, { key: "getStartIndex", value: function() {
          return this._start;
        } }, { key: "getContext", value: function() {
          return this._context;
        } }, { key: "getId", value: function() {
          return this._id;
        } }], [{ key: "constructor_", value: function() {
          this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
          var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i2 = arguments[3];
          this._pts = t2, this._start = e2, this._end = n2, this._context = i2;
        } }]);
      }(), Tn = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "findChainEnd", value: function(t3, e2) {
          for (var n2 = e2; n2 < t3.length - 1 && t3[n2].equals2D(t3[n2 + 1]); ) n2++;
          if (n2 >= t3.length - 1) return t3.length - 1;
          for (var i2 = je.quadrant(t3[n2], t3[n2 + 1]), r2 = e2 + 1; r2 < t3.length; ) {
            if (!t3[r2 - 1].equals2D(t3[r2])) {
              if (je.quadrant(t3[r2 - 1], t3[r2]) !== i2) break;
            }
            r2++;
          }
          return r2 - 1;
        } }, { key: "getChains", value: function() {
          if (1 === arguments.length) {
            var e2 = arguments[0];
            return t2.getChains(e2, null);
          }
          if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = new yt(), s2 = 0;
            do {
              var a2 = t2.findChainEnd(n2, s2), o2 = new Nn(n2, s2, a2, i2);
              r2.add(o2), s2 = a2;
            } while (s2 < n2.length - 1);
            return r2;
          }
        } }]);
      }(), Sn = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "computeNodes", value: function(t2) {
        } }, { key: "getNodedSubstrings", value: function() {
        } }]);
      }(), Ln = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "setSegmentIntersector", value: function(t2) {
          this._segInt = t2;
        } }, { key: "interfaces_", get: function() {
          return [Sn];
        } }], [{ key: "constructor_", value: function() {
          if (this._segInt = null, 0 === arguments.length) ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setSegmentIntersector(t2);
          }
        } }]);
      }(), Cn = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "getMonotoneChains", value: function() {
          return this._monoChains;
        } }, { key: "getNodedSubstrings", value: function() {
          return xn.getNodedSubstrings(this._nodedSegStrings);
        } }, { key: "getIndex", value: function() {
          return this._index;
        } }, { key: "add", value: function(t3) {
          for (var e2 = Tn.getChains(t3.getCoordinates(), t3).iterator(); e2.hasNext(); ) {
            var n2 = e2.next();
            n2.setId(this._idCounter++), this._index.insert(n2.getEnvelope(), n2), this._monoChains.add(n2);
          }
        } }, { key: "computeNodes", value: function(t3) {
          this._nodedSegStrings = t3;
          for (var e2 = t3.iterator(); e2.hasNext(); ) this.add(e2.next());
          this.intersectChains();
        } }, { key: "intersectChains", value: function() {
          for (var t3 = new Rn(this._segInt), e2 = this._monoChains.iterator(); e2.hasNext(); ) for (var n2 = e2.next(), i3 = this._index.query(n2.getEnvelope()).iterator(); i3.hasNext(); ) {
            var r2 = i3.next();
            if (r2.getId() > n2.getId() && (n2.computeOverlaps(r2, t3), this._nOverlaps++), this._segInt.isDone()) return null;
          }
        } }], [{ key: "constructor_", value: function() {
          if (this._monoChains = new yt(), this._index = new fn(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0, 0 === arguments.length) ;
          else if (1 === arguments.length) {
            var t3 = arguments[0];
            Ln.constructor_.call(this, t3);
          }
        } }]);
      }(Ln), Rn = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "overlap", value: function() {
          if (4 !== arguments.length) return f(i2, "overlap", this, 1).apply(this, arguments);
          var t3 = arguments[1], e2 = arguments[2], n2 = arguments[3], r2 = arguments[0].getContext(), s2 = e2.getContext();
          this._si.processIntersections(r2, t3, s2, n2);
        } }], [{ key: "constructor_", value: function() {
          this._si = null;
          var t3 = arguments[0];
          this._si = t3;
        } }]);
      }(En);
      Cn.SegmentOverlapAction = Rn;
      var wn = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "isDeletable", value: function(t3, e2, n2, i2) {
          var r2 = this._inputLine[t3], s2 = this._inputLine[e2], a2 = this._inputLine[n2];
          return !!this.isConcave(r2, s2, a2) && (!!this.isShallow(r2, s2, a2, i2) && this.isShallowSampled(r2, s2, t3, n2, i2));
        } }, { key: "deleteShallowConcavities", value: function() {
          for (var e2 = 1, n2 = this.findNextNonDeletedIndex(e2), i2 = this.findNextNonDeletedIndex(n2), r2 = false; i2 < this._inputLine.length; ) {
            var s2 = false;
            this.isDeletable(e2, n2, i2, this._distanceTol) && (this._isDeleted[n2] = t2.DELETE, s2 = true, r2 = true), e2 = s2 ? i2 : n2, n2 = this.findNextNonDeletedIndex(e2), i2 = this.findNextNonDeletedIndex(n2);
          }
          return r2;
        } }, { key: "isShallowConcavity", value: function(t3, e2, n2, i2) {
          return ct.index(t3, e2, n2) === this._angleOrientation && xt.pointToSegment(e2, t3, n2) < i2;
        } }, { key: "isShallowSampled", value: function(e2, n2, i2, r2, s2) {
          var a2 = Math.trunc((r2 - i2) / t2.NUM_PTS_TO_CHECK);
          a2 <= 0 && (a2 = 1);
          for (var o2 = i2; o2 < r2; o2 += a2) if (!this.isShallow(e2, n2, this._inputLine[o2], s2)) return false;
          return true;
        } }, { key: "isConcave", value: function(t3, e2, n2) {
          var i2 = ct.index(t3, e2, n2) === this._angleOrientation;
          return i2;
        } }, { key: "simplify", value: function(t3) {
          this._distanceTol = Math.abs(t3), t3 < 0 && (this._angleOrientation = ct.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
          var e2 = false;
          do {
            e2 = this.deleteShallowConcavities();
          } while (e2);
          return this.collapseLine();
        } }, { key: "findNextNonDeletedIndex", value: function(e2) {
          for (var n2 = e2 + 1; n2 < this._inputLine.length && this._isDeleted[n2] === t2.DELETE; ) n2++;
          return n2;
        } }, { key: "isShallow", value: function(t3, e2, n2, i2) {
          return xt.pointToSegment(e2, t3, n2) < i2;
        } }, { key: "collapseLine", value: function() {
          for (var e2 = new Zt(), n2 = 0; n2 < this._inputLine.length; n2++) this._isDeleted[n2] !== t2.DELETE && e2.add(this._inputLine[n2]);
          return e2.toCoordinateArray();
        } }], [{ key: "constructor_", value: function() {
          this._inputLine = null, this._distanceTol = null, this._isDeleted = null, this._angleOrientation = ct.COUNTERCLOCKWISE;
          var t3 = arguments[0];
          this._inputLine = t3;
        } }, { key: "simplify", value: function(e2, n2) {
          return new t2(e2).simplify(n2);
        } }]);
      }();
      wn.INIT = 0, wn.DELETE = 1, wn.KEEP = 1, wn.NUM_PTS_TO_CHECK = 10;
      var On = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "getCoordinates", value: function() {
          return this._ptList.toArray(t2.COORDINATE_ARRAY_TYPE);
        } }, { key: "setPrecisionModel", value: function(t3) {
          this._precisionModel = t3;
        } }, { key: "addPt", value: function(t3) {
          var e2 = new X(t3);
          if (this._precisionModel.makePrecise(e2), this.isRedundant(e2)) return null;
          this._ptList.add(e2);
        } }, { key: "reverse", value: function() {
        } }, { key: "addPts", value: function(t3, e2) {
          if (e2) for (var n2 = 0; n2 < t3.length; n2++) this.addPt(t3[n2]);
          else for (var i2 = t3.length - 1; i2 >= 0; i2--) this.addPt(t3[i2]);
        } }, { key: "isRedundant", value: function(t3) {
          if (this._ptList.size() < 1) return false;
          var e2 = this._ptList.get(this._ptList.size() - 1);
          return t3.distance(e2) < this._minimimVertexDistance;
        } }, { key: "toString", value: function() {
          return new ae().createLineString(this.getCoordinates()).toString();
        } }, { key: "closeRing", value: function() {
          if (this._ptList.size() < 1) return null;
          var t3 = new X(this._ptList.get(0)), e2 = this._ptList.get(this._ptList.size() - 1);
          if (t3.equals(e2)) return null;
          this._ptList.add(t3);
        } }, { key: "setMinimumVertexDistance", value: function(t3) {
          this._minimimVertexDistance = t3;
        } }], [{ key: "constructor_", value: function() {
          this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new yt();
        } }]);
      }();
      On.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);
      var bn = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, null, [{ key: "toDegrees", value: function(t3) {
          return 180 * t3 / Math.PI;
        } }, { key: "normalize", value: function(e2) {
          for (; e2 > Math.PI; ) e2 -= t2.PI_TIMES_2;
          for (; e2 <= -Math.PI; ) e2 += t2.PI_TIMES_2;
          return e2;
        } }, { key: "angle", value: function() {
          if (1 === arguments.length) {
            var t3 = arguments[0];
            return Math.atan2(t3.y, t3.x);
          }
          if (2 === arguments.length) {
            var e2 = arguments[0], n2 = arguments[1], i2 = n2.x - e2.x, r2 = n2.y - e2.y;
            return Math.atan2(r2, i2);
          }
        } }, { key: "isAcute", value: function(t3, e2, n2) {
          var i2 = t3.x - e2.x, r2 = t3.y - e2.y;
          return i2 * (n2.x - e2.x) + r2 * (n2.y - e2.y) > 0;
        } }, { key: "isObtuse", value: function(t3, e2, n2) {
          var i2 = t3.x - e2.x, r2 = t3.y - e2.y;
          return i2 * (n2.x - e2.x) + r2 * (n2.y - e2.y) < 0;
        } }, { key: "interiorAngle", value: function(e2, n2, i2) {
          var r2 = t2.angle(n2, e2), s2 = t2.angle(n2, i2);
          return Math.abs(s2 - r2);
        } }, { key: "normalizePositive", value: function(e2) {
          if (e2 < 0) {
            for (; e2 < 0; ) e2 += t2.PI_TIMES_2;
            e2 >= t2.PI_TIMES_2 && (e2 = 0);
          } else {
            for (; e2 >= t2.PI_TIMES_2; ) e2 -= t2.PI_TIMES_2;
            e2 < 0 && (e2 = 0);
          }
          return e2;
        } }, { key: "angleBetween", value: function(e2, n2, i2) {
          var r2 = t2.angle(n2, e2), s2 = t2.angle(n2, i2);
          return t2.diff(r2, s2);
        } }, { key: "diff", value: function(t3, e2) {
          var n2 = null;
          return (n2 = t3 < e2 ? e2 - t3 : t3 - e2) > Math.PI && (n2 = 2 * Math.PI - n2), n2;
        } }, { key: "toRadians", value: function(t3) {
          return t3 * Math.PI / 180;
        } }, { key: "getTurn", value: function(e2, n2) {
          var i2 = Math.sin(n2 - e2);
          return i2 > 0 ? t2.COUNTERCLOCKWISE : i2 < 0 ? t2.CLOCKWISE : t2.NONE;
        } }, { key: "angleBetweenOriented", value: function(e2, n2, i2) {
          var r2 = t2.angle(n2, e2), s2 = t2.angle(n2, i2) - r2;
          return s2 <= -Math.PI ? s2 + t2.PI_TIMES_2 : s2 > Math.PI ? s2 - t2.PI_TIMES_2 : s2;
        } }]);
      }();
      bn.PI_TIMES_2 = 2 * Math.PI, bn.PI_OVER_2 = Math.PI / 2, bn.PI_OVER_4 = Math.PI / 4, bn.COUNTERCLOCKWISE = ct.COUNTERCLOCKWISE, bn.CLOCKWISE = ct.CLOCKWISE, bn.NONE = ct.COLLINEAR;
      var Mn = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "addNextSegment", value: function(t3, e2) {
          if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t3, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;
          var n2 = ct.index(this._s0, this._s1, this._s2), i2 = n2 === ct.CLOCKWISE && this._side === $.LEFT || n2 === ct.COUNTERCLOCKWISE && this._side === $.RIGHT;
          0 === n2 ? this.addCollinear(e2) : i2 ? this.addOutsideTurn(n2, e2) : this.addInsideTurn(n2, e2);
        } }, { key: "addLineEndCap", value: function(t3, e2) {
          var n2 = new In(t3, e2), i2 = new In();
          this.computeOffsetSegment(n2, $.LEFT, this._distance, i2);
          var r2 = new In();
          this.computeOffsetSegment(n2, $.RIGHT, this._distance, r2);
          var s2 = e2.x - t3.x, a2 = e2.y - t3.y, o2 = Math.atan2(a2, s2);
          switch (this._bufParams.getEndCapStyle()) {
            case _.CAP_ROUND:
              this._segList.addPt(i2.p1), this.addDirectedFillet(e2, o2 + Math.PI / 2, o2 - Math.PI / 2, ct.CLOCKWISE, this._distance), this._segList.addPt(r2.p1);
              break;
            case _.CAP_FLAT:
              this._segList.addPt(i2.p1), this._segList.addPt(r2.p1);
              break;
            case _.CAP_SQUARE:
              var u3 = new X();
              u3.x = Math.abs(this._distance) * Math.cos(o2), u3.y = Math.abs(this._distance) * Math.sin(o2);
              var l2 = new X(i2.p1.x + u3.x, i2.p1.y + u3.y), h2 = new X(r2.p1.x + u3.x, r2.p1.y + u3.y);
              this._segList.addPt(l2), this._segList.addPt(h2);
          }
        } }, { key: "getCoordinates", value: function() {
          return this._segList.getCoordinates();
        } }, { key: "addMitreJoin", value: function(t3, e2, n2, i2) {
          var r2 = pt.intersection(e2.p0, e2.p1, n2.p0, n2.p1);
          if (null !== r2 && (i2 <= 0 ? 1 : r2.distance(t3) / Math.abs(i2)) <= this._bufParams.getMitreLimit()) return this._segList.addPt(r2), null;
          this.addLimitedMitreJoin(e2, n2, i2, this._bufParams.getMitreLimit());
        } }, { key: "addOutsideTurn", value: function(e2, n2) {
          if (this._offset0.p1.distance(this._offset1.p0) < this._distance * t2.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;
          this._bufParams.getJoinStyle() === _.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === _.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (n2 && this._segList.addPt(this._offset0.p1), this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, e2, this._distance), this._segList.addPt(this._offset1.p0));
        } }, { key: "createSquare", value: function(t3) {
          this._segList.addPt(new X(t3.x + this._distance, t3.y + this._distance)), this._segList.addPt(new X(t3.x + this._distance, t3.y - this._distance)), this._segList.addPt(new X(t3.x - this._distance, t3.y - this._distance)), this._segList.addPt(new X(t3.x - this._distance, t3.y + this._distance)), this._segList.closeRing();
        } }, { key: "addSegments", value: function(t3, e2) {
          this._segList.addPts(t3, e2);
        } }, { key: "addFirstSegment", value: function() {
          this._segList.addPt(this._offset1.p0);
        } }, { key: "addCornerFillet", value: function(t3, e2, n2, i2, r2) {
          var s2 = e2.x - t3.x, a2 = e2.y - t3.y, o2 = Math.atan2(a2, s2), u3 = n2.x - t3.x, l2 = n2.y - t3.y, h2 = Math.atan2(l2, u3);
          i2 === ct.CLOCKWISE ? o2 <= h2 && (o2 += 2 * Math.PI) : o2 >= h2 && (o2 -= 2 * Math.PI), this._segList.addPt(e2), this.addDirectedFillet(t3, o2, h2, i2, r2), this._segList.addPt(n2);
        } }, { key: "addLastSegment", value: function() {
          this._segList.addPt(this._offset1.p1);
        } }, { key: "initSideSegments", value: function(t3, e2, n2) {
          this._s1 = t3, this._s2 = e2, this._side = n2, this._seg1.setCoordinates(t3, e2), this.computeOffsetSegment(this._seg1, n2, this._distance, this._offset1);
        } }, { key: "addLimitedMitreJoin", value: function(t3, e2, n2, i2) {
          var r2 = this._seg0.p1, s2 = bn.angle(r2, this._seg0.p0), a2 = bn.angleBetweenOriented(this._seg0.p0, r2, this._seg1.p1) / 2, o2 = bn.normalize(s2 + a2), u3 = bn.normalize(o2 + Math.PI), l2 = i2 * n2, h2 = n2 - l2 * Math.abs(Math.sin(a2)), c2 = r2.x + l2 * Math.cos(u3), f2 = r2.y + l2 * Math.sin(u3), g2 = new X(c2, f2), v2 = new In(r2, g2), y2 = v2.pointAlongOffset(1, h2), d2 = v2.pointAlongOffset(1, -h2);
          this._side === $.LEFT ? (this._segList.addPt(y2), this._segList.addPt(d2)) : (this._segList.addPt(d2), this._segList.addPt(y2));
        } }, { key: "addDirectedFillet", value: function(t3, e2, n2, i2, r2) {
          var s2 = i2 === ct.CLOCKWISE ? -1 : 1, a2 = Math.abs(e2 - n2), o2 = Math.trunc(a2 / this._filletAngleQuantum + 0.5);
          if (o2 < 1) return null;
          for (var u3 = a2 / o2, l2 = new X(), h2 = 0; h2 < o2; h2++) {
            var c2 = e2 + s2 * h2 * u3;
            l2.x = t3.x + r2 * Math.cos(c2), l2.y = t3.y + r2 * Math.sin(c2), this._segList.addPt(l2);
          }
        } }, { key: "computeOffsetSegment", value: function(t3, e2, n2, i2) {
          var r2 = e2 === $.LEFT ? 1 : -1, s2 = t3.p1.x - t3.p0.x, a2 = t3.p1.y - t3.p0.y, o2 = Math.sqrt(s2 * s2 + a2 * a2), u3 = r2 * n2 * s2 / o2, l2 = r2 * n2 * a2 / o2;
          i2.p0.x = t3.p0.x - l2, i2.p0.y = t3.p0.y + u3, i2.p1.x = t3.p1.x - l2, i2.p1.y = t3.p1.y + u3;
        } }, { key: "addInsideTurn", value: function(e2, n2) {
          if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0));
          else if (this._hasNarrowConcaveAngle = true, this._offset0.p1.distance(this._offset1.p0) < this._distance * t2.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1);
          else {
            if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
              var i2 = new X((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(i2);
              var r2 = new X((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(r2);
            } else this._segList.addPt(this._s1);
            this._segList.addPt(this._offset1.p0);
          }
        } }, { key: "createCircle", value: function(t3) {
          var e2 = new X(t3.x + this._distance, t3.y);
          this._segList.addPt(e2), this.addDirectedFillet(t3, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
        } }, { key: "addBevelJoin", value: function(t3, e2) {
          this._segList.addPt(t3.p1), this._segList.addPt(e2.p0);
        } }, { key: "init", value: function(e2) {
          this._distance = e2, this._maxCurveSegmentError = e2 * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new On(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(e2 * t2.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
        } }, { key: "addCollinear", value: function(t3) {
          this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2), this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === _.JOIN_BEVEL || this._bufParams.getJoinStyle() === _.JOIN_MITRE ? (t3 && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, ct.CLOCKWISE, this._distance));
        } }, { key: "closeRing", value: function() {
          this._segList.closeRing();
        } }, { key: "hasNarrowConcaveAngle", value: function() {
          return this._hasNarrowConcaveAngle;
        } }], [{ key: "constructor_", value: function() {
          this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new In(), this._seg1 = new In(), this._offset0 = new In(), this._offset1 = new In(), this._side = 0, this._hasNarrowConcaveAngle = false;
          var e2 = arguments[0], n2 = arguments[1], i2 = arguments[2];
          this._precisionModel = e2, this._bufParams = n2, this._li = new we(), this._filletAngleQuantum = Math.PI / 2 / n2.getQuadrantSegments(), n2.getQuadrantSegments() >= 8 && n2.getJoinStyle() === _.JOIN_ROUND && (this._closingSegLengthFactor = t2.MAX_CLOSING_SEG_LEN_FACTOR), this.init(i2);
        } }]);
      }();
      Mn.OFFSET_SEGMENT_SEPARATION_FACTOR = 1e-3, Mn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1e-3, Mn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, Mn.MAX_CLOSING_SEG_LEN_FACTOR = 80;
      var An = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "getOffsetCurve", value: function(t3, e2) {
          if (this._distance = e2, 0 === e2) return null;
          var n2 = e2 < 0, i2 = Math.abs(e2), r2 = this.getSegGen(i2);
          t3.length <= 1 ? this.computePointCurve(t3[0], r2) : this.computeOffsetCurve(t3, n2, r2);
          var s2 = r2.getCoordinates();
          return n2 && jt.reverse(s2), s2;
        } }, { key: "computeSingleSidedBufferCurve", value: function(t3, e2, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          if (e2) {
            n2.addSegments(t3, true);
            var r2 = wn.simplify(t3, -i2), s2 = r2.length - 1;
            n2.initSideSegments(r2[s2], r2[s2 - 1], $.LEFT), n2.addFirstSegment();
            for (var a2 = s2 - 2; a2 >= 0; a2--) n2.addNextSegment(r2[a2], true);
          } else {
            n2.addSegments(t3, false);
            var o2 = wn.simplify(t3, i2), u3 = o2.length - 1;
            n2.initSideSegments(o2[0], o2[1], $.LEFT), n2.addFirstSegment();
            for (var l2 = 2; l2 <= u3; l2++) n2.addNextSegment(o2[l2], true);
          }
          n2.addLastSegment(), n2.closeRing();
        } }, { key: "computeRingBufferCurve", value: function(t3, e2, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          e2 === $.RIGHT && (i2 = -i2);
          var r2 = wn.simplify(t3, i2), s2 = r2.length - 1;
          n2.initSideSegments(r2[s2 - 1], r2[0], e2);
          for (var a2 = 1; a2 <= s2; a2++) {
            var o2 = 1 !== a2;
            n2.addNextSegment(r2[a2], o2);
          }
          n2.closeRing();
        } }, { key: "computeLineBufferCurve", value: function(t3, e2) {
          var n2 = this.simplifyTolerance(this._distance), i2 = wn.simplify(t3, n2), r2 = i2.length - 1;
          e2.initSideSegments(i2[0], i2[1], $.LEFT);
          for (var s2 = 2; s2 <= r2; s2++) e2.addNextSegment(i2[s2], true);
          e2.addLastSegment(), e2.addLineEndCap(i2[r2 - 1], i2[r2]);
          var a2 = wn.simplify(t3, -n2), o2 = a2.length - 1;
          e2.initSideSegments(a2[o2], a2[o2 - 1], $.LEFT);
          for (var u3 = o2 - 2; u3 >= 0; u3--) e2.addNextSegment(a2[u3], true);
          e2.addLastSegment(), e2.addLineEndCap(a2[1], a2[0]), e2.closeRing();
        } }, { key: "computePointCurve", value: function(t3, e2) {
          switch (this._bufParams.getEndCapStyle()) {
            case _.CAP_ROUND:
              e2.createCircle(t3);
              break;
            case _.CAP_SQUARE:
              e2.createSquare(t3);
          }
        } }, { key: "getLineCurve", value: function(t3, e2) {
          if (this._distance = e2, this.isLineOffsetEmpty(e2)) return null;
          var n2 = Math.abs(e2), i2 = this.getSegGen(n2);
          if (t3.length <= 1) this.computePointCurve(t3[0], i2);
          else if (this._bufParams.isSingleSided()) {
            var r2 = e2 < 0;
            this.computeSingleSidedBufferCurve(t3, r2, i2);
          } else this.computeLineBufferCurve(t3, i2);
          return i2.getCoordinates();
        } }, { key: "getBufferParameters", value: function() {
          return this._bufParams;
        } }, { key: "simplifyTolerance", value: function(t3) {
          return t3 * this._bufParams.getSimplifyFactor();
        } }, { key: "getRingCurve", value: function(e2, n2, i2) {
          if (this._distance = i2, e2.length <= 2) return this.getLineCurve(e2, i2);
          if (0 === i2) return t2.copyCoordinates(e2);
          var r2 = this.getSegGen(i2);
          return this.computeRingBufferCurve(e2, n2, r2), r2.getCoordinates();
        } }, { key: "computeOffsetCurve", value: function(t3, e2, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          if (e2) {
            var r2 = wn.simplify(t3, -i2), s2 = r2.length - 1;
            n2.initSideSegments(r2[s2], r2[s2 - 1], $.LEFT), n2.addFirstSegment();
            for (var a2 = s2 - 2; a2 >= 0; a2--) n2.addNextSegment(r2[a2], true);
          } else {
            var o2 = wn.simplify(t3, i2), u3 = o2.length - 1;
            n2.initSideSegments(o2[0], o2[1], $.LEFT), n2.addFirstSegment();
            for (var l2 = 2; l2 <= u3; l2++) n2.addNextSegment(o2[l2], true);
          }
          n2.addLastSegment();
        } }, { key: "isLineOffsetEmpty", value: function(t3) {
          return 0 === t3 || t3 < 0 && !this._bufParams.isSingleSided();
        } }, { key: "getSegGen", value: function(t3) {
          return new Mn(this._precisionModel, this._bufParams, t3);
        } }], [{ key: "constructor_", value: function() {
          this._distance = 0, this._precisionModel = null, this._bufParams = null;
          var t3 = arguments[0], e2 = arguments[1];
          this._precisionModel = t3, this._bufParams = e2;
        } }, { key: "copyCoordinates", value: function(t3) {
          for (var e2 = new Array(t3.length).fill(null), n2 = 0; n2 < e2.length; n2++) e2[n2] = new X(t3[n2]);
          return e2;
        } }]);
      }(), Pn = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "findStabbedSegments", value: function() {
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e2 = new yt(), n2 = this._subgraphs.iterator(); n2.hasNext(); ) {
              var i2 = n2.next(), r2 = i2.getEnvelope();
              t2.y < r2.getMinY() || t2.y > r2.getMaxY() || this.findStabbedSegments(t2, i2.getDirectedEdges(), e2);
            }
            return e2;
          }
          if (3 === arguments.length) {
            if (rt(arguments[2], nt) && arguments[0] instanceof X && arguments[1] instanceof Ke) for (var s2 = arguments[0], a2 = arguments[1], o2 = arguments[2], u3 = a2.getEdge().getCoordinates(), l2 = 0; l2 < u3.length - 1; l2++) {
              if (this._seg.p0 = u3[l2], this._seg.p1 = u3[l2 + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse(), !(Math.max(this._seg.p0.x, this._seg.p1.x) < s2.x || this._seg.isHorizontal() || s2.y < this._seg.p0.y || s2.y > this._seg.p1.y || ct.index(this._seg.p0, this._seg.p1, s2) === ct.RIGHT)) {
                var h2 = a2.getDepth($.LEFT);
                this._seg.p0.equals(u3[l2]) || (h2 = a2.getDepth($.RIGHT));
                var c2 = new Dn(this._seg, h2);
                o2.add(c2);
              }
            }
            else if (rt(arguments[2], nt) && arguments[0] instanceof X && rt(arguments[1], nt)) for (var f2 = arguments[0], g2 = arguments[2], v2 = arguments[1].iterator(); v2.hasNext(); ) {
              var y2 = v2.next();
              y2.isForward() && this.findStabbedSegments(f2, y2, g2);
            }
          }
        } }, { key: "getDepth", value: function(t2) {
          var e2 = this.findStabbedSegments(t2);
          return 0 === e2.size() ? 0 : an.min(e2)._leftDepth;
        } }], [{ key: "constructor_", value: function() {
          this._subgraphs = null, this._seg = new In();
          var t2 = arguments[0];
          this._subgraphs = t2;
        } }]);
      }(), Dn = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "compareTo", value: function(t2) {
          var e2 = t2;
          if (this._upwardSeg.minX() >= e2._upwardSeg.maxX()) return 1;
          if (this._upwardSeg.maxX() <= e2._upwardSeg.minX()) return -1;
          var n2 = this._upwardSeg.orientationIndex(e2._upwardSeg);
          return 0 !== n2 || 0 !== (n2 = -1 * e2._upwardSeg.orientationIndex(this._upwardSeg)) ? n2 : this._upwardSeg.compareTo(e2._upwardSeg);
        } }, { key: "compareX", value: function(t2, e2) {
          var n2 = t2.p0.compareTo(e2.p0);
          return 0 !== n2 ? n2 : t2.p1.compareTo(e2.p1);
        } }, { key: "toString", value: function() {
          return this._upwardSeg.toString();
        } }, { key: "interfaces_", get: function() {
          return [x];
        } }], [{ key: "constructor_", value: function() {
          this._upwardSeg = null, this._leftDepth = null;
          var t2 = arguments[0], e2 = arguments[1];
          this._upwardSeg = new In(t2), this._leftDepth = e2;
        } }]);
      }();
      Pn.DepthSegment = Dn;
      var Fn = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, null, [{ key: "constructor_", value: function() {
          p.constructor_.call(this, "Projective point not representable on the Cartesian plane.");
        } }]);
      }(p), Gn = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "getY", value: function() {
          var t3 = this.y / this.w;
          if (A.isNaN(t3) || A.isInfinite(t3)) throw new Fn();
          return t3;
        } }, { key: "getX", value: function() {
          var t3 = this.x / this.w;
          if (A.isNaN(t3) || A.isInfinite(t3)) throw new Fn();
          return t3;
        } }, { key: "getCoordinate", value: function() {
          var t3 = new X();
          return t3.x = this.getX(), t3.y = this.getY(), t3;
        } }], [{ key: "constructor_", value: function() {
          if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.x = 0, this.y = 0, this.w = 1;
          else if (1 === arguments.length) {
            var e2 = arguments[0];
            this.x = e2.x, this.y = e2.y, this.w = 1;
          } else if (2 === arguments.length) {
            if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
              var n2 = arguments[0], i2 = arguments[1];
              this.x = n2, this.y = i2, this.w = 1;
            } else if (arguments[0] instanceof t2 && arguments[1] instanceof t2) {
              var r2 = arguments[0], s2 = arguments[1];
              this.x = r2.y * s2.w - s2.y * r2.w, this.y = s2.x * r2.w - r2.x * s2.w, this.w = r2.x * s2.y - s2.x * r2.y;
            } else if (arguments[0] instanceof X && arguments[1] instanceof X) {
              var a2 = arguments[0], o2 = arguments[1];
              this.x = a2.y - o2.y, this.y = o2.x - a2.x, this.w = a2.x * o2.y - o2.x * a2.y;
            }
          } else if (3 === arguments.length) {
            var u3 = arguments[0], l2 = arguments[1], h2 = arguments[2];
            this.x = u3, this.y = l2, this.w = h2;
          } else if (4 === arguments.length) {
            var c2 = arguments[0], f2 = arguments[1], g2 = arguments[2], v2 = arguments[3], y2 = c2.y - f2.y, d2 = f2.x - c2.x, _2 = c2.x * f2.y - f2.x * c2.y, p2 = g2.y - v2.y, m2 = v2.x - g2.x, k2 = g2.x * v2.y - v2.x * g2.y;
            this.x = d2 * k2 - m2 * _2, this.y = p2 * _2 - y2 * k2, this.w = y2 * m2 - p2 * d2;
          }
        } }]);
      }(), qn = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "area", value: function() {
          return t2.area(this.p0, this.p1, this.p2);
        } }, { key: "signedArea", value: function() {
          return t2.signedArea(this.p0, this.p1, this.p2);
        } }, { key: "interpolateZ", value: function(e2) {
          if (null === e2) throw new m("Supplied point is null.");
          return t2.interpolateZ(e2, this.p0, this.p1, this.p2);
        } }, { key: "longestSideLength", value: function() {
          return t2.longestSideLength(this.p0, this.p1, this.p2);
        } }, { key: "isAcute", value: function() {
          return t2.isAcute(this.p0, this.p1, this.p2);
        } }, { key: "circumcentre", value: function() {
          return t2.circumcentre(this.p0, this.p1, this.p2);
        } }, { key: "area3D", value: function() {
          return t2.area3D(this.p0, this.p1, this.p2);
        } }, { key: "centroid", value: function() {
          return t2.centroid(this.p0, this.p1, this.p2);
        } }, { key: "inCentre", value: function() {
          return t2.inCentre(this.p0, this.p1, this.p2);
        } }], [{ key: "constructor_", value: function() {
          this.p0 = null, this.p1 = null, this.p2 = null;
          var t3 = arguments[0], e2 = arguments[1], n2 = arguments[2];
          this.p0 = t3, this.p1 = e2, this.p2 = n2;
        } }, { key: "area", value: function(t3, e2, n2) {
          return Math.abs(((n2.x - t3.x) * (e2.y - t3.y) - (e2.x - t3.x) * (n2.y - t3.y)) / 2);
        } }, { key: "signedArea", value: function(t3, e2, n2) {
          return ((n2.x - t3.x) * (e2.y - t3.y) - (e2.x - t3.x) * (n2.y - t3.y)) / 2;
        } }, { key: "det", value: function(t3, e2, n2, i2) {
          return t3 * i2 - e2 * n2;
        } }, { key: "interpolateZ", value: function(t3, e2, n2, i2) {
          var r2 = e2.x, s2 = e2.y, a2 = n2.x - r2, o2 = i2.x - r2, u3 = n2.y - s2, l2 = i2.y - s2, h2 = a2 * l2 - o2 * u3, c2 = t3.x - r2, f2 = t3.y - s2, g2 = (l2 * c2 - o2 * f2) / h2, v2 = (-u3 * c2 + a2 * f2) / h2;
          return e2.getZ() + g2 * (n2.getZ() - e2.getZ()) + v2 * (i2.getZ() - e2.getZ());
        } }, { key: "longestSideLength", value: function(t3, e2, n2) {
          var i2 = t3.distance(e2), r2 = e2.distance(n2), s2 = n2.distance(t3), a2 = i2;
          return r2 > a2 && (a2 = r2), s2 > a2 && (a2 = s2), a2;
        } }, { key: "circumcentreDD", value: function(t3, e2, n2) {
          var i2 = ut.valueOf(t3.x).subtract(n2.x), r2 = ut.valueOf(t3.y).subtract(n2.y), s2 = ut.valueOf(e2.x).subtract(n2.x), a2 = ut.valueOf(e2.y).subtract(n2.y), o2 = ut.determinant(i2, r2, s2, a2).multiply(2), u3 = i2.sqr().add(r2.sqr()), l2 = s2.sqr().add(a2.sqr()), h2 = ut.determinant(r2, u3, a2, l2), c2 = ut.determinant(i2, u3, s2, l2), f2 = ut.valueOf(n2.x).subtract(h2.divide(o2)).doubleValue(), g2 = ut.valueOf(n2.y).add(c2.divide(o2)).doubleValue();
          return new X(f2, g2);
        } }, { key: "isAcute", value: function(t3, e2, n2) {
          return !!bn.isAcute(t3, e2, n2) && (!!bn.isAcute(e2, n2, t3) && !!bn.isAcute(n2, t3, e2));
        } }, { key: "circumcentre", value: function(e2, n2, i2) {
          var r2 = i2.x, s2 = i2.y, a2 = e2.x - r2, o2 = e2.y - s2, u3 = n2.x - r2, l2 = n2.y - s2, h2 = 2 * t2.det(a2, o2, u3, l2), c2 = t2.det(o2, a2 * a2 + o2 * o2, l2, u3 * u3 + l2 * l2), f2 = t2.det(a2, a2 * a2 + o2 * o2, u3, u3 * u3 + l2 * l2);
          return new X(r2 - c2 / h2, s2 + f2 / h2);
        } }, { key: "perpendicularBisector", value: function(t3, e2) {
          var n2 = e2.x - t3.x, i2 = e2.y - t3.y, r2 = new Gn(t3.x + n2 / 2, t3.y + i2 / 2, 1), s2 = new Gn(t3.x - i2 + n2 / 2, t3.y + n2 + i2 / 2, 1);
          return new Gn(r2, s2);
        } }, { key: "angleBisector", value: function(t3, e2, n2) {
          var i2 = e2.distance(t3), r2 = i2 / (i2 + e2.distance(n2)), s2 = n2.x - t3.x, a2 = n2.y - t3.y;
          return new X(t3.x + r2 * s2, t3.y + r2 * a2);
        } }, { key: "area3D", value: function(t3, e2, n2) {
          var i2 = e2.x - t3.x, r2 = e2.y - t3.y, s2 = e2.getZ() - t3.getZ(), a2 = n2.x - t3.x, o2 = n2.y - t3.y, u3 = n2.getZ() - t3.getZ(), l2 = r2 * u3 - s2 * o2, h2 = s2 * a2 - i2 * u3, c2 = i2 * o2 - r2 * a2, f2 = l2 * l2 + h2 * h2 + c2 * c2, g2 = Math.sqrt(f2) / 2;
          return g2;
        } }, { key: "centroid", value: function(t3, e2, n2) {
          var i2 = (t3.x + e2.x + n2.x) / 3, r2 = (t3.y + e2.y + n2.y) / 3;
          return new X(i2, r2);
        } }, { key: "inCentre", value: function(t3, e2, n2) {
          var i2 = e2.distance(n2), r2 = t3.distance(n2), s2 = t3.distance(e2), a2 = i2 + r2 + s2, o2 = (i2 * t3.x + r2 * e2.x + s2 * n2.x) / a2, u3 = (i2 * t3.y + r2 * e2.y + s2 * n2.y) / a2;
          return new X(o2, u3);
        } }]);
      }(), Yn = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "addRingSide", value: function(t2, e2, n2, i2, r2) {
          if (0 === e2 && t2.length < Xt.MINIMUM_VALID_SIZE) return null;
          var s2 = i2, a2 = r2;
          t2.length >= Xt.MINIMUM_VALID_SIZE && ct.isCCW(t2) && (s2 = r2, a2 = i2, n2 = $.opposite(n2));
          var o2 = this._curveBuilder.getRingCurve(t2, n2, e2);
          this.addCurve(o2, s2, a2);
        } }, { key: "addRingBothSides", value: function(t2, e2) {
          this.addRingSide(t2, e2, $.LEFT, H.EXTERIOR, H.INTERIOR), this.addRingSide(t2, e2, $.RIGHT, H.INTERIOR, H.EXTERIOR);
        } }, { key: "addPoint", value: function(t2) {
          if (this._distance <= 0) return null;
          var e2 = t2.getCoordinates(), n2 = this._curveBuilder.getLineCurve(e2, this._distance);
          this.addCurve(n2, H.EXTERIOR, H.INTERIOR);
        } }, { key: "addPolygon", value: function(t2) {
          var e2 = this._distance, n2 = $.LEFT;
          this._distance < 0 && (e2 = -this._distance, n2 = $.RIGHT);
          var i2 = t2.getExteriorRing(), r2 = jt.removeRepeatedPoints(i2.getCoordinates());
          if (this._distance < 0 && this.isErodedCompletely(i2, this._distance)) return null;
          if (this._distance <= 0 && r2.length < 3) return null;
          this.addRingSide(r2, e2, n2, H.EXTERIOR, H.INTERIOR);
          for (var s2 = 0; s2 < t2.getNumInteriorRing(); s2++) {
            var a2 = t2.getInteriorRingN(s2), o2 = jt.removeRepeatedPoints(a2.getCoordinates());
            this._distance > 0 && this.isErodedCompletely(a2, -this._distance) || this.addRingSide(o2, e2, $.opposite(n2), H.INTERIOR, H.EXTERIOR);
          }
        } }, { key: "isTriangleErodedCompletely", value: function(t2, e2) {
          var n2 = new qn(t2[0], t2[1], t2[2]), i2 = n2.inCentre();
          return xt.pointToSegment(i2, n2.p0, n2.p1) < Math.abs(e2);
        } }, { key: "addLineString", value: function(t2) {
          if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null;
          var e2 = jt.removeRepeatedPoints(t2.getCoordinates());
          if (jt.isRing(e2) && !this._curveBuilder.getBufferParameters().isSingleSided()) this.addRingBothSides(e2, this._distance);
          else {
            var n2 = this._curveBuilder.getLineCurve(e2, this._distance);
            this.addCurve(n2, H.EXTERIOR, H.INTERIOR);
          }
        } }, { key: "addCurve", value: function(t2, e2, n2) {
          if (null === t2 || t2.length < 2) return null;
          var i2 = new xn(t2, new Ae(0, H.BOUNDARY, e2, n2));
          this._curveList.add(i2);
        } }, { key: "getCurves", value: function() {
          return this.add(this._inputGeom), this._curveList;
        } }, { key: "add", value: function(t2) {
          if (t2.isEmpty()) return null;
          if (t2 instanceof Dt) this.addPolygon(t2);
          else if (t2 instanceof wt) this.addLineString(t2);
          else if (t2 instanceof bt) this.addPoint(t2);
          else if (t2 instanceof zt) this.addCollection(t2);
          else if (t2 instanceof se) this.addCollection(t2);
          else if (t2 instanceof te) this.addCollection(t2);
          else {
            if (!(t2 instanceof Yt)) throw new W(t2.getGeometryType());
            this.addCollection(t2);
          }
        } }, { key: "isErodedCompletely", value: function(t2, e2) {
          var n2 = t2.getCoordinates();
          if (n2.length < 4) return e2 < 0;
          if (4 === n2.length) return this.isTriangleErodedCompletely(n2, e2);
          var i2 = t2.getEnvelopeInternal(), r2 = Math.min(i2.getHeight(), i2.getWidth());
          return e2 < 0 && 2 * Math.abs(e2) > r2;
        } }, { key: "addCollection", value: function(t2) {
          for (var e2 = 0; e2 < t2.getNumGeometries(); e2++) {
            var n2 = t2.getGeometryN(e2);
            this.add(n2);
          }
        } }], [{ key: "constructor_", value: function() {
          this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new yt();
          var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
          this._inputGeom = t2, this._distance = e2, this._curveBuilder = n2;
        } }]);
      }(), zn = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "locate", value: function(t2) {
        } }]);
      }(), Xn = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "next", value: function() {
          if (this._atStart) return this._atStart = false, t2.isAtomic(this._parent) && this._index++, this._parent;
          if (null !== this._subcollectionIterator) {
            if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();
            this._subcollectionIterator = null;
          }
          if (this._index >= this._max) throw new j();
          var e2 = this._parent.getGeometryN(this._index++);
          return e2 instanceof Yt ? (this._subcollectionIterator = new t2(e2), this._subcollectionIterator.next()) : e2;
        } }, { key: "remove", value: function() {
          throw new W(this.getClass().getName());
        } }, { key: "hasNext", value: function() {
          if (this._atStart) return true;
          if (null !== this._subcollectionIterator) {
            if (this._subcollectionIterator.hasNext()) return true;
            this._subcollectionIterator = null;
          }
          return !(this._index >= this._max);
        } }, { key: "interfaces_", get: function() {
          return [dn];
        } }], [{ key: "constructor_", value: function() {
          this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
          var t3 = arguments[0];
          this._parent = t3, this._atStart = true, this._index = 0, this._max = t3.getNumGeometries();
        } }, { key: "isAtomic", value: function(t3) {
          return !(t3 instanceof Yt);
        } }]);
      }(), Bn = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "locate", value: function(e2) {
          return t2.locate(e2, this._geom);
        } }, { key: "interfaces_", get: function() {
          return [zn];
        } }], [{ key: "constructor_", value: function() {
          this._geom = null;
          var t3 = arguments[0];
          this._geom = t3;
        } }, { key: "locatePointInPolygon", value: function(e2, n2) {
          if (n2.isEmpty()) return H.EXTERIOR;
          var i2 = n2.getExteriorRing(), r2 = t2.locatePointInRing(e2, i2);
          if (r2 !== H.INTERIOR) return r2;
          for (var s2 = 0; s2 < n2.getNumInteriorRing(); s2++) {
            var a2 = n2.getInteriorRingN(s2), o2 = t2.locatePointInRing(e2, a2);
            if (o2 === H.BOUNDARY) return H.BOUNDARY;
            if (o2 === H.INTERIOR) return H.EXTERIOR;
          }
          return H.INTERIOR;
        } }, { key: "locatePointInRing", value: function(t3, e2) {
          return e2.getEnvelopeInternal().intersects(t3) ? be.locateInRing(t3, e2.getCoordinates()) : H.EXTERIOR;
        } }, { key: "containsPointInPolygon", value: function(e2, n2) {
          return H.EXTERIOR !== t2.locatePointInPolygon(e2, n2);
        } }, { key: "locateInGeometry", value: function(e2, n2) {
          if (n2 instanceof Dt) return t2.locatePointInPolygon(e2, n2);
          if (n2 instanceof Yt) for (var i2 = new Xn(n2); i2.hasNext(); ) {
            var r2 = i2.next();
            if (r2 !== n2) {
              var s2 = t2.locateInGeometry(e2, r2);
              if (s2 !== H.EXTERIOR) return s2;
            }
          }
          return H.EXTERIOR;
        } }, { key: "isContained", value: function(e2, n2) {
          return H.EXTERIOR !== t2.locate(e2, n2);
        } }, { key: "locate", value: function(e2, n2) {
          return n2.isEmpty() ? H.EXTERIOR : n2.getEnvelopeInternal().intersects(e2) ? t2.locateInGeometry(e2, n2) : H.EXTERIOR;
        } }]);
      }(), Un = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "getNextCW", value: function(t2) {
          this.getEdges();
          var e2 = this._edgeList.indexOf(t2), n2 = e2 - 1;
          return 0 === e2 && (n2 = this._edgeList.size() - 1), this._edgeList.get(n2);
        } }, { key: "propagateSideLabels", value: function(t2) {
          for (var e2 = H.NONE, n2 = this.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().getLabel();
            i2.isArea(t2) && i2.getLocation(t2, $.LEFT) !== H.NONE && (e2 = i2.getLocation(t2, $.LEFT));
          }
          if (e2 === H.NONE) return null;
          for (var r2 = e2, s2 = this.iterator(); s2.hasNext(); ) {
            var a2 = s2.next(), o2 = a2.getLabel();
            if (o2.getLocation(t2, $.ON) === H.NONE && o2.setLocation(t2, $.ON, r2), o2.isArea(t2)) {
              var u3 = o2.getLocation(t2, $.LEFT), l2 = o2.getLocation(t2, $.RIGHT);
              if (l2 !== H.NONE) {
                if (l2 !== r2) throw new gt("side location conflict", a2.getCoordinate());
                u3 === H.NONE && G.shouldNeverReachHere("found single null side (at " + a2.getCoordinate() + ")"), r2 = u3;
              } else G.isTrue(o2.getLocation(t2, $.LEFT) === H.NONE, "found single null side"), o2.setLocation(t2, $.RIGHT, r2), o2.setLocation(t2, $.LEFT, r2);
            }
          }
        } }, { key: "getCoordinate", value: function() {
          var t2 = this.iterator();
          return t2.hasNext() ? t2.next().getCoordinate() : null;
        } }, { key: "print", value: function(t2) {
          mt.out.println("EdgeEndStar:   " + this.getCoordinate());
          for (var e2 = this.iterator(); e2.hasNext(); ) {
            e2.next().print(t2);
          }
        } }, { key: "isAreaLabelsConsistent", value: function(t2) {
          return this.computeEdgeEndLabels(t2.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
        } }, { key: "checkAreaLabelsConsistent", value: function(t2) {
          var e2 = this.getEdges();
          if (e2.size() <= 0) return true;
          var n2 = e2.size() - 1, i2 = e2.get(n2).getLabel().getLocation(t2, $.LEFT);
          G.isTrue(i2 !== H.NONE, "Found unlabelled area edge");
          for (var r2 = i2, s2 = this.iterator(); s2.hasNext(); ) {
            var a2 = s2.next().getLabel();
            G.isTrue(a2.isArea(t2), "Found non-area edge");
            var o2 = a2.getLocation(t2, $.LEFT), u3 = a2.getLocation(t2, $.RIGHT);
            if (o2 === u3) return false;
            if (u3 !== r2) return false;
            r2 = o2;
          }
          return true;
        } }, { key: "findIndex", value: function(t2) {
          this.iterator();
          for (var e2 = 0; e2 < this._edgeList.size(); e2++) {
            if (this._edgeList.get(e2) === t2) return e2;
          }
          return -1;
        } }, { key: "iterator", value: function() {
          return this.getEdges().iterator();
        } }, { key: "getEdges", value: function() {
          return null === this._edgeList && (this._edgeList = new yt(this._edgeMap.values())), this._edgeList;
        } }, { key: "getLocation", value: function(t2, e2, n2) {
          return this._ptInAreaLocation[t2] === H.NONE && (this._ptInAreaLocation[t2] = Bn.locate(e2, n2[t2].getGeometry())), this._ptInAreaLocation[t2];
        } }, { key: "toString", value: function() {
          var t2 = new st();
          t2.append("EdgeEndStar:   " + this.getCoordinate()), t2.append("\n");
          for (var e2 = this.iterator(); e2.hasNext(); ) {
            var n2 = e2.next();
            t2.append(n2), t2.append("\n");
          }
          return t2.toString();
        } }, { key: "computeEdgeEndLabels", value: function(t2) {
          for (var e2 = this.iterator(); e2.hasNext(); ) {
            e2.next().computeLabel(t2);
          }
        } }, { key: "computeLabelling", value: function(t2) {
          this.computeEdgeEndLabels(t2[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
          for (var e2 = [false, false], n2 = this.iterator(); n2.hasNext(); ) for (var i2 = n2.next().getLabel(), r2 = 0; r2 < 2; r2++) i2.isLine(r2) && i2.getLocation(r2) === H.BOUNDARY && (e2[r2] = true);
          for (var s2 = this.iterator(); s2.hasNext(); ) for (var a2 = s2.next(), o2 = a2.getLabel(), u3 = 0; u3 < 2; u3++) if (o2.isAnyNull(u3)) {
            var l2 = H.NONE;
            if (e2[u3]) l2 = H.EXTERIOR;
            else {
              var h2 = a2.getCoordinate();
              l2 = this.getLocation(u3, h2, t2);
            }
            o2.setAllLocationsIfNull(u3, l2);
          }
        } }, { key: "getDegree", value: function() {
          return this._edgeMap.size();
        } }, { key: "insertEdgeEnd", value: function(t2, e2) {
          this._edgeMap.put(t2, e2), this._edgeList = null;
        } }], [{ key: "constructor_", value: function() {
          this._edgeMap = new He(), this._edgeList = null, this._ptInAreaLocation = [H.NONE, H.NONE];
        } }]);
      }(), Vn = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "linkResultDirectedEdges", value: function() {
          this.getResultAreaEdges();
          for (var t3 = null, e2 = null, n2 = this._SCANNING_FOR_INCOMING, i3 = 0; i3 < this._resultAreaEdgeList.size(); i3++) {
            var r2 = this._resultAreaEdgeList.get(i3), s2 = r2.getSym();
            if (r2.getLabel().isArea()) switch (null === t3 && r2.isInResult() && (t3 = r2), n2) {
              case this._SCANNING_FOR_INCOMING:
                if (!s2.isInResult()) continue;
                e2 = s2, n2 = this._LINKING_TO_OUTGOING;
                break;
              case this._LINKING_TO_OUTGOING:
                if (!r2.isInResult()) continue;
                e2.setNext(r2), n2 = this._SCANNING_FOR_INCOMING;
            }
          }
          if (n2 === this._LINKING_TO_OUTGOING) {
            if (null === t3) throw new gt("no outgoing dirEdge found", this.getCoordinate());
            G.isTrue(t3.isInResult(), "unable to link last incoming dirEdge"), e2.setNext(t3);
          }
        } }, { key: "insert", value: function(t3) {
          var e2 = t3;
          this.insertEdgeEnd(e2, e2);
        } }, { key: "getRightmostEdge", value: function() {
          var t3 = this.getEdges(), e2 = t3.size();
          if (e2 < 1) return null;
          var n2 = t3.get(0);
          if (1 === e2) return n2;
          var i3 = t3.get(e2 - 1), r2 = n2.getQuadrant(), s2 = i3.getQuadrant();
          return je.isNorthern(r2) && je.isNorthern(s2) ? n2 : je.isNorthern(r2) || je.isNorthern(s2) ? 0 !== n2.getDy() ? n2 : 0 !== i3.getDy() ? i3 : (G.shouldNeverReachHere("found two horizontal edges incident on node"), null) : i3;
        } }, { key: "print", value: function(t3) {
          mt.out.println("DirectedEdgeStar: " + this.getCoordinate());
          for (var e2 = this.iterator(); e2.hasNext(); ) {
            var n2 = e2.next();
            t3.print("out "), n2.print(t3), t3.println(), t3.print("in "), n2.getSym().print(t3), t3.println();
          }
        } }, { key: "getResultAreaEdges", value: function() {
          if (null !== this._resultAreaEdgeList) return this._resultAreaEdgeList;
          this._resultAreaEdgeList = new yt();
          for (var t3 = this.iterator(); t3.hasNext(); ) {
            var e2 = t3.next();
            (e2.isInResult() || e2.getSym().isInResult()) && this._resultAreaEdgeList.add(e2);
          }
          return this._resultAreaEdgeList;
        } }, { key: "updateLabelling", value: function(t3) {
          for (var e2 = this.iterator(); e2.hasNext(); ) {
            var n2 = e2.next().getLabel();
            n2.setAllLocationsIfNull(0, t3.getLocation(0)), n2.setAllLocationsIfNull(1, t3.getLocation(1));
          }
        } }, { key: "linkAllDirectedEdges", value: function() {
          this.getEdges();
          for (var t3 = null, e2 = null, n2 = this._edgeList.size() - 1; n2 >= 0; n2--) {
            var i3 = this._edgeList.get(n2), r2 = i3.getSym();
            null === e2 && (e2 = r2), null !== t3 && r2.setNext(t3), t3 = i3;
          }
          e2.setNext(t3);
        } }, { key: "computeDepths", value: function() {
          if (1 === arguments.length) {
            var t3 = arguments[0], e2 = this.findIndex(t3), n2 = t3.getDepth($.LEFT), i3 = t3.getDepth($.RIGHT), r2 = this.computeDepths(e2 + 1, this._edgeList.size(), n2);
            if (this.computeDepths(0, e2, r2) !== i3) throw new gt("depth mismatch at " + t3.getCoordinate());
          } else if (3 === arguments.length) {
            for (var s2 = arguments[1], a2 = arguments[2], o2 = arguments[0]; o2 < s2; o2++) {
              var u3 = this._edgeList.get(o2);
              u3.setEdgeDepths($.RIGHT, a2), a2 = u3.getDepth($.LEFT);
            }
            return a2;
          }
        } }, { key: "mergeSymLabels", value: function() {
          for (var t3 = this.iterator(); t3.hasNext(); ) {
            var e2 = t3.next();
            e2.getLabel().merge(e2.getSym().getLabel());
          }
        } }, { key: "linkMinimalDirectedEdges", value: function(t3) {
          for (var e2 = null, n2 = null, i3 = this._SCANNING_FOR_INCOMING, r2 = this._resultAreaEdgeList.size() - 1; r2 >= 0; r2--) {
            var s2 = this._resultAreaEdgeList.get(r2), a2 = s2.getSym();
            switch (null === e2 && s2.getEdgeRing() === t3 && (e2 = s2), i3) {
              case this._SCANNING_FOR_INCOMING:
                if (a2.getEdgeRing() !== t3) continue;
                n2 = a2, i3 = this._LINKING_TO_OUTGOING;
                break;
              case this._LINKING_TO_OUTGOING:
                if (s2.getEdgeRing() !== t3) continue;
                n2.setNextMin(s2), i3 = this._SCANNING_FOR_INCOMING;
            }
          }
          i3 === this._LINKING_TO_OUTGOING && (G.isTrue(null !== e2, "found null for first outgoing dirEdge"), G.isTrue(e2.getEdgeRing() === t3, "unable to link last incoming dirEdge"), n2.setNextMin(e2));
        } }, { key: "getOutgoingDegree", value: function() {
          if (0 === arguments.length) {
            for (var t3 = 0, e2 = this.iterator(); e2.hasNext(); ) {
              e2.next().isInResult() && t3++;
            }
            return t3;
          }
          if (1 === arguments.length) {
            for (var n2 = arguments[0], i3 = 0, r2 = this.iterator(); r2.hasNext(); ) {
              r2.next().getEdgeRing() === n2 && i3++;
            }
            return i3;
          }
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "findCoveredLineEdges", value: function() {
          for (var t3 = H.NONE, e2 = this.iterator(); e2.hasNext(); ) {
            var n2 = e2.next(), i3 = n2.getSym();
            if (!n2.isLineEdge()) {
              if (n2.isInResult()) {
                t3 = H.INTERIOR;
                break;
              }
              if (i3.isInResult()) {
                t3 = H.EXTERIOR;
                break;
              }
            }
          }
          if (t3 === H.NONE) return null;
          for (var r2 = t3, s2 = this.iterator(); s2.hasNext(); ) {
            var a2 = s2.next(), o2 = a2.getSym();
            a2.isLineEdge() ? a2.getEdge().setCovered(r2 === H.INTERIOR) : (a2.isInResult() && (r2 = H.EXTERIOR), o2.isInResult() && (r2 = H.INTERIOR));
          }
        } }, { key: "computeLabelling", value: function(t3) {
          f(i2, "computeLabelling", this, 1).call(this, t3), this._label = new Ae(H.NONE);
          for (var e2 = this.iterator(); e2.hasNext(); ) for (var n2 = e2.next().getEdge().getLabel(), r2 = 0; r2 < 2; r2++) {
            var s2 = n2.getLocation(r2);
            s2 !== H.INTERIOR && s2 !== H.BOUNDARY || this._label.setLocation(r2, H.INTERIOR);
          }
        } }], [{ key: "constructor_", value: function() {
          this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
        } }]);
      }(Un), Hn = function(t2) {
        function i2() {
          return n(this, i2), e(this, i2);
        }
        return l(i2, t2), s(i2, [{ key: "createNode", value: function(t3) {
          return new qe(t3, new Vn());
        } }]);
      }(Je), Zn = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "compareTo", value: function(e2) {
          var n2 = e2;
          return t2.compareOriented(this._pts, this._orientation, n2._pts, n2._orientation);
        } }, { key: "interfaces_", get: function() {
          return [x];
        } }], [{ key: "constructor_", value: function() {
          this._pts = null, this._orientation = null;
          var e2 = arguments[0];
          this._pts = e2, this._orientation = t2.orientation(e2);
        } }, { key: "orientation", value: function(t3) {
          return 1 === jt.increasingDirection(t3);
        } }, { key: "compareOriented", value: function(t3, e2, n2, i2) {
          for (var r2 = e2 ? 1 : -1, s2 = i2 ? 1 : -1, a2 = e2 ? t3.length : -1, o2 = i2 ? n2.length : -1, u3 = e2 ? 0 : t3.length - 1, l2 = i2 ? 0 : n2.length - 1; ; ) {
            var h2 = t3[u3].compareTo(n2[l2]);
            if (0 !== h2) return h2;
            var c2 = (u3 += r2) === a2, f2 = (l2 += s2) === o2;
            if (c2 && !f2) return -1;
            if (!c2 && f2) return 1;
            if (c2 && f2) return 0;
          }
        } }]);
      }(), jn = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "print", value: function(t2) {
          t2.print("MULTILINESTRING ( ");
          for (var e2 = 0; e2 < this._edges.size(); e2++) {
            var n2 = this._edges.get(e2);
            e2 > 0 && t2.print(","), t2.print("(");
            for (var i2 = n2.getCoordinates(), r2 = 0; r2 < i2.length; r2++) r2 > 0 && t2.print(","), t2.print(i2[r2].x + " " + i2[r2].y);
            t2.println(")");
          }
          t2.print(")  ");
        } }, { key: "addAll", value: function(t2) {
          for (var e2 = t2.iterator(); e2.hasNext(); ) this.add(e2.next());
        } }, { key: "findEdgeIndex", value: function(t2) {
          for (var e2 = 0; e2 < this._edges.size(); e2++) if (this._edges.get(e2).equals(t2)) return e2;
          return -1;
        } }, { key: "iterator", value: function() {
          return this._edges.iterator();
        } }, { key: "getEdges", value: function() {
          return this._edges;
        } }, { key: "get", value: function(t2) {
          return this._edges.get(t2);
        } }, { key: "findEqualEdge", value: function(t2) {
          var e2 = new Zn(t2.getCoordinates());
          return this._ocaMap.get(e2);
        } }, { key: "add", value: function(t2) {
          this._edges.add(t2);
          var e2 = new Zn(t2.getCoordinates());
          this._ocaMap.put(e2, t2);
        } }], [{ key: "constructor_", value: function() {
          this._edges = new yt(), this._ocaMap = new He();
        } }]);
      }(), Wn = function() {
        return s(function t2() {
          n(this, t2);
        }, [{ key: "processIntersections", value: function(t2, e2, n2, i2) {
        } }, { key: "isDone", value: function() {
        } }]);
      }(), Kn = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "isTrivialIntersection", value: function(e2, n2, i2, r2) {
          if (e2 === i2 && 1 === this._li.getIntersectionNum()) {
            if (t2.isAdjacentSegments(n2, r2)) return true;
            if (e2.isClosed()) {
              var s2 = e2.size() - 1;
              if (0 === n2 && r2 === s2 || 0 === r2 && n2 === s2) return true;
            }
          }
          return false;
        } }, { key: "getProperIntersectionPoint", value: function() {
          return this._properIntersectionPoint;
        } }, { key: "hasProperInteriorIntersection", value: function() {
          return this._hasProperInterior;
        } }, { key: "getLineIntersector", value: function() {
          return this._li;
        } }, { key: "hasProperIntersection", value: function() {
          return this._hasProper;
        } }, { key: "processIntersections", value: function(t3, e2, n2, i2) {
          if (t3 === n2 && e2 === i2) return null;
          this.numTests++;
          var r2 = t3.getCoordinates()[e2], s2 = t3.getCoordinates()[e2 + 1], a2 = n2.getCoordinates()[i2], o2 = n2.getCoordinates()[i2 + 1];
          this._li.computeIntersection(r2, s2, a2, o2), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = true), this.isTrivialIntersection(t3, e2, n2, i2) || (this._hasIntersection = true, t3.addIntersections(this._li, e2, 0), n2.addIntersections(this._li, i2, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = true, this._hasProperInterior = true)));
        } }, { key: "hasIntersection", value: function() {
          return this._hasIntersection;
        } }, { key: "isDone", value: function() {
          return false;
        } }, { key: "hasInteriorIntersection", value: function() {
          return this._hasInterior;
        } }, { key: "interfaces_", get: function() {
          return [Wn];
        } }], [{ key: "constructor_", value: function() {
          this._hasIntersection = false, this._hasProper = false, this._hasProperInterior = false, this._hasInterior = false, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
          var t3 = arguments[0];
          this._li = t3;
        } }, { key: "isAdjacentSegments", value: function(t3, e2) {
          return 1 === Math.abs(t3 - e2);
        } }]);
      }(), Jn = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "getSegmentIndex", value: function() {
          return this.segmentIndex;
        } }, { key: "getCoordinate", value: function() {
          return this.coord;
        } }, { key: "print", value: function(t2) {
          t2.print(this.coord), t2.print(" seg # = " + this.segmentIndex), t2.println(" dist = " + this.dist);
        } }, { key: "compareTo", value: function(t2) {
          var e2 = t2;
          return this.compare(e2.segmentIndex, e2.dist);
        } }, { key: "isEndPoint", value: function(t2) {
          return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t2;
        } }, { key: "toString", value: function() {
          return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
        } }, { key: "getDistance", value: function() {
          return this.dist;
        } }, { key: "compare", value: function(t2, e2) {
          return this.segmentIndex < t2 ? -1 : this.segmentIndex > t2 ? 1 : this.dist < e2 ? -1 : this.dist > e2 ? 1 : 0;
        } }, { key: "interfaces_", get: function() {
          return [x];
        } }], [{ key: "constructor_", value: function() {
          this.coord = null, this.segmentIndex = null, this.dist = null;
          var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2];
          this.coord = new X(t2), this.segmentIndex = e2, this.dist = n2;
        } }]);
      }(), Qn = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "print", value: function(t2) {
          t2.println("Intersections:");
          for (var e2 = this.iterator(); e2.hasNext(); ) {
            e2.next().print(t2);
          }
        } }, { key: "iterator", value: function() {
          return this._nodeMap.values().iterator();
        } }, { key: "addSplitEdges", value: function(t2) {
          this.addEndpoints();
          for (var e2 = this.iterator(), n2 = e2.next(); e2.hasNext(); ) {
            var i2 = e2.next(), r2 = this.createSplitEdge(n2, i2);
            t2.add(r2), n2 = i2;
          }
        } }, { key: "addEndpoints", value: function() {
          var t2 = this.edge.pts.length - 1;
          this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t2], t2, 0);
        } }, { key: "createSplitEdge", value: function(t2, e2) {
          var n2 = e2.segmentIndex - t2.segmentIndex + 2, i2 = this.edge.pts[e2.segmentIndex], r2 = e2.dist > 0 || !e2.coord.equals2D(i2);
          r2 || n2--;
          var s2 = new Array(n2).fill(null), a2 = 0;
          s2[a2++] = new X(t2.coord);
          for (var o2 = t2.segmentIndex + 1; o2 <= e2.segmentIndex; o2++) s2[a2++] = this.edge.pts[o2];
          return r2 && (s2[a2] = e2.coord), new ri(s2, new Ae(this.edge._label));
        } }, { key: "add", value: function(t2, e2, n2) {
          var i2 = new Jn(t2, e2, n2), r2 = this._nodeMap.get(i2);
          return null !== r2 ? r2 : (this._nodeMap.put(i2, i2), i2);
        } }, { key: "isIntersection", value: function(t2) {
          for (var e2 = this.iterator(); e2.hasNext(); ) {
            if (e2.next().coord.equals(t2)) return true;
          }
          return false;
        } }], [{ key: "constructor_", value: function() {
          this._nodeMap = new He(), this.edge = null;
          var t2 = arguments[0];
          this.edge = t2;
        } }]);
      }(), $n = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "isIntersects", value: function() {
          return !this.isDisjoint();
        } }, { key: "isCovers", value: function() {
          return (t2.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) || t2.isTrue(this._matrix[H.INTERIOR][H.BOUNDARY]) || t2.isTrue(this._matrix[H.BOUNDARY][H.INTERIOR]) || t2.isTrue(this._matrix[H.BOUNDARY][H.BOUNDARY])) && this._matrix[H.EXTERIOR][H.INTERIOR] === Lt.FALSE && this._matrix[H.EXTERIOR][H.BOUNDARY] === Lt.FALSE;
        } }, { key: "isCoveredBy", value: function() {
          return (t2.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) || t2.isTrue(this._matrix[H.INTERIOR][H.BOUNDARY]) || t2.isTrue(this._matrix[H.BOUNDARY][H.INTERIOR]) || t2.isTrue(this._matrix[H.BOUNDARY][H.BOUNDARY])) && this._matrix[H.INTERIOR][H.EXTERIOR] === Lt.FALSE && this._matrix[H.BOUNDARY][H.EXTERIOR] === Lt.FALSE;
        } }, { key: "set", value: function() {
          if (1 === arguments.length) for (var t3 = arguments[0], e2 = 0; e2 < t3.length; e2++) {
            var n2 = Math.trunc(e2 / 3), i2 = e2 % 3;
            this._matrix[n2][i2] = Lt.toDimensionValue(t3.charAt(e2));
          }
          else if (3 === arguments.length) {
            var r2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
            this._matrix[r2][s2] = a2;
          }
        } }, { key: "isContains", value: function() {
          return t2.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && this._matrix[H.EXTERIOR][H.INTERIOR] === Lt.FALSE && this._matrix[H.EXTERIOR][H.BOUNDARY] === Lt.FALSE;
        } }, { key: "setAtLeast", value: function() {
          if (1 === arguments.length) for (var t3 = arguments[0], e2 = 0; e2 < t3.length; e2++) {
            var n2 = Math.trunc(e2 / 3), i2 = e2 % 3;
            this.setAtLeast(n2, i2, Lt.toDimensionValue(t3.charAt(e2)));
          }
          else if (3 === arguments.length) {
            var r2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
            this._matrix[r2][s2] < a2 && (this._matrix[r2][s2] = a2);
          }
        } }, { key: "setAtLeastIfValid", value: function(t3, e2, n2) {
          t3 >= 0 && e2 >= 0 && this.setAtLeast(t3, e2, n2);
        } }, { key: "isWithin", value: function() {
          return t2.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && this._matrix[H.INTERIOR][H.EXTERIOR] === Lt.FALSE && this._matrix[H.BOUNDARY][H.EXTERIOR] === Lt.FALSE;
        } }, { key: "isTouches", value: function(e2, n2) {
          return e2 > n2 ? this.isTouches(n2, e2) : (e2 === Lt.A && n2 === Lt.A || e2 === Lt.L && n2 === Lt.L || e2 === Lt.L && n2 === Lt.A || e2 === Lt.P && n2 === Lt.A || e2 === Lt.P && n2 === Lt.L) && (this._matrix[H.INTERIOR][H.INTERIOR] === Lt.FALSE && (t2.isTrue(this._matrix[H.INTERIOR][H.BOUNDARY]) || t2.isTrue(this._matrix[H.BOUNDARY][H.INTERIOR]) || t2.isTrue(this._matrix[H.BOUNDARY][H.BOUNDARY])));
        } }, { key: "isOverlaps", value: function(e2, n2) {
          return e2 === Lt.P && n2 === Lt.P || e2 === Lt.A && n2 === Lt.A ? t2.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && t2.isTrue(this._matrix[H.INTERIOR][H.EXTERIOR]) && t2.isTrue(this._matrix[H.EXTERIOR][H.INTERIOR]) : e2 === Lt.L && n2 === Lt.L && (1 === this._matrix[H.INTERIOR][H.INTERIOR] && t2.isTrue(this._matrix[H.INTERIOR][H.EXTERIOR]) && t2.isTrue(this._matrix[H.EXTERIOR][H.INTERIOR]));
        } }, { key: "isEquals", value: function(e2, n2) {
          return e2 === n2 && (t2.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && this._matrix[H.INTERIOR][H.EXTERIOR] === Lt.FALSE && this._matrix[H.BOUNDARY][H.EXTERIOR] === Lt.FALSE && this._matrix[H.EXTERIOR][H.INTERIOR] === Lt.FALSE && this._matrix[H.EXTERIOR][H.BOUNDARY] === Lt.FALSE);
        } }, { key: "toString", value: function() {
          for (var t3 = new Jt("123456789"), e2 = 0; e2 < 3; e2++) for (var n2 = 0; n2 < 3; n2++) t3.setCharAt(3 * e2 + n2, Lt.toDimensionSymbol(this._matrix[e2][n2]));
          return t3.toString();
        } }, { key: "setAll", value: function(t3) {
          for (var e2 = 0; e2 < 3; e2++) for (var n2 = 0; n2 < 3; n2++) this._matrix[e2][n2] = t3;
        } }, { key: "get", value: function(t3, e2) {
          return this._matrix[t3][e2];
        } }, { key: "transpose", value: function() {
          var t3 = this._matrix[1][0];
          return this._matrix[1][0] = this._matrix[0][1], this._matrix[0][1] = t3, t3 = this._matrix[2][0], this._matrix[2][0] = this._matrix[0][2], this._matrix[0][2] = t3, t3 = this._matrix[2][1], this._matrix[2][1] = this._matrix[1][2], this._matrix[1][2] = t3, this;
        } }, { key: "matches", value: function(e2) {
          if (9 !== e2.length) throw new m("Should be length 9: " + e2);
          for (var n2 = 0; n2 < 3; n2++) for (var i2 = 0; i2 < 3; i2++) if (!t2.matches(this._matrix[n2][i2], e2.charAt(3 * n2 + i2))) return false;
          return true;
        } }, { key: "add", value: function(t3) {
          for (var e2 = 0; e2 < 3; e2++) for (var n2 = 0; n2 < 3; n2++) this.setAtLeast(e2, n2, t3.get(e2, n2));
        } }, { key: "isDisjoint", value: function() {
          return this._matrix[H.INTERIOR][H.INTERIOR] === Lt.FALSE && this._matrix[H.INTERIOR][H.BOUNDARY] === Lt.FALSE && this._matrix[H.BOUNDARY][H.INTERIOR] === Lt.FALSE && this._matrix[H.BOUNDARY][H.BOUNDARY] === Lt.FALSE;
        } }, { key: "isCrosses", value: function(e2, n2) {
          return e2 === Lt.P && n2 === Lt.L || e2 === Lt.P && n2 === Lt.A || e2 === Lt.L && n2 === Lt.A ? t2.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && t2.isTrue(this._matrix[H.INTERIOR][H.EXTERIOR]) : e2 === Lt.L && n2 === Lt.P || e2 === Lt.A && n2 === Lt.P || e2 === Lt.A && n2 === Lt.L ? t2.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && t2.isTrue(this._matrix[H.EXTERIOR][H.INTERIOR]) : e2 === Lt.L && n2 === Lt.L && 0 === this._matrix[H.INTERIOR][H.INTERIOR];
        } }, { key: "interfaces_", get: function() {
          return [I];
        } }], [{ key: "constructor_", value: function() {
          if (this._matrix = null, 0 === arguments.length) this._matrix = Array(3).fill().map(function() {
            return Array(3);
          }), this.setAll(Lt.FALSE);
          else if (1 === arguments.length) {
            if ("string" == typeof arguments[0]) {
              var e2 = arguments[0];
              t2.constructor_.call(this), this.set(e2);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              t2.constructor_.call(this), this._matrix[H.INTERIOR][H.INTERIOR] = n2._matrix[H.INTERIOR][H.INTERIOR], this._matrix[H.INTERIOR][H.BOUNDARY] = n2._matrix[H.INTERIOR][H.BOUNDARY], this._matrix[H.INTERIOR][H.EXTERIOR] = n2._matrix[H.INTERIOR][H.EXTERIOR], this._matrix[H.BOUNDARY][H.INTERIOR] = n2._matrix[H.BOUNDARY][H.INTERIOR], this._matrix[H.BOUNDARY][H.BOUNDARY] = n2._matrix[H.BOUNDARY][H.BOUNDARY], this._matrix[H.BOUNDARY][H.EXTERIOR] = n2._matrix[H.BOUNDARY][H.EXTERIOR], this._matrix[H.EXTERIOR][H.INTERIOR] = n2._matrix[H.EXTERIOR][H.INTERIOR], this._matrix[H.EXTERIOR][H.BOUNDARY] = n2._matrix[H.EXTERIOR][H.BOUNDARY], this._matrix[H.EXTERIOR][H.EXTERIOR] = n2._matrix[H.EXTERIOR][H.EXTERIOR];
            }
          }
        } }, { key: "matches", value: function() {
          if (Number.isInteger(arguments[0]) && "string" == typeof arguments[1]) {
            var e2 = arguments[0], n2 = arguments[1];
            return n2 === Lt.SYM_DONTCARE || (n2 === Lt.SYM_TRUE && (e2 >= 0 || e2 === Lt.TRUE) || (n2 === Lt.SYM_FALSE && e2 === Lt.FALSE || (n2 === Lt.SYM_P && e2 === Lt.P || (n2 === Lt.SYM_L && e2 === Lt.L || n2 === Lt.SYM_A && e2 === Lt.A))));
          }
          if ("string" == typeof arguments[0] && "string" == typeof arguments[1]) {
            var i2 = arguments[1];
            return new t2(arguments[0]).matches(i2);
          }
        } }, { key: "isTrue", value: function(t3) {
          return t3 >= 0 || t3 === Lt.TRUE;
        } }]);
      }(), ti = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "size", value: function() {
          return this._size;
        } }, { key: "addAll", value: function(t3) {
          return null === t3 || 0 === t3.length ? null : (this.ensureCapacity(this._size + t3.length), mt.arraycopy(t3, 0, this._data, this._size, t3.length), void (this._size += t3.length));
        } }, { key: "ensureCapacity", value: function(t3) {
          if (t3 <= this._data.length) return null;
          var e2 = Math.max(t3, 2 * this._data.length);
          this._data = At.copyOf(this._data, e2);
        } }, { key: "toArray", value: function() {
          var t3 = new Array(this._size).fill(null);
          return mt.arraycopy(this._data, 0, t3, 0, this._size), t3;
        } }, { key: "add", value: function(t3) {
          this.ensureCapacity(this._size + 1), this._data[this._size] = t3, ++this._size;
        } }], [{ key: "constructor_", value: function() {
          if (this._data = null, this._size = 0, 0 === arguments.length) t2.constructor_.call(this, 10);
          else if (1 === arguments.length) {
            var e2 = arguments[0];
            this._data = new Array(e2).fill(null);
          }
        } }]);
      }(), ei = function() {
        function t2() {
          n(this, t2);
        }
        return s(t2, [{ key: "getChainStartIndices", value: function(t3) {
          var e2 = 0, n2 = new ti(Math.trunc(t3.length / 2));
          n2.add(e2);
          do {
            var i2 = this.findChainEnd(t3, e2);
            n2.add(i2), e2 = i2;
          } while (e2 < t3.length - 1);
          return n2.toArray();
        } }, { key: "findChainEnd", value: function(t3, e2) {
          for (var n2 = je.quadrant(t3[e2], t3[e2 + 1]), i2 = e2 + 1; i2 < t3.length; ) {
            if (je.quadrant(t3[i2 - 1], t3[i2]) !== n2) break;
            i2++;
          }
          return i2 - 1;
        } }, { key: "OLDgetChainStartIndices", value: function(e2) {
          var n2 = 0, i2 = new yt();
          i2.add(n2);
          do {
            var r2 = this.findChainEnd(e2, n2);
            i2.add(r2), n2 = r2;
          } while (n2 < e2.length - 1);
          return t2.toIntArray(i2);
        } }], [{ key: "toIntArray", value: function(t3) {
          for (var e2 = new Array(t3.size()).fill(null), n2 = 0; n2 < e2.length; n2++) e2[n2] = t3.get(n2).intValue();
          return e2;
        } }]);
      }(), ni = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "getCoordinates", value: function() {
          return this.pts;
        } }, { key: "getMaxX", value: function(t2) {
          var e2 = this.pts[this.startIndex[t2]].x, n2 = this.pts[this.startIndex[t2 + 1]].x;
          return e2 > n2 ? e2 : n2;
        } }, { key: "getMinX", value: function(t2) {
          var e2 = this.pts[this.startIndex[t2]].x, n2 = this.pts[this.startIndex[t2 + 1]].x;
          return e2 < n2 ? e2 : n2;
        } }, { key: "computeIntersectsForChain", value: function() {
          if (4 === arguments.length) {
            var t2 = arguments[0], e2 = arguments[1], n2 = arguments[2], i2 = arguments[3];
            this.computeIntersectsForChain(this.startIndex[t2], this.startIndex[t2 + 1], e2, e2.startIndex[n2], e2.startIndex[n2 + 1], i2);
          } else if (6 === arguments.length) {
            var r2 = arguments[0], s2 = arguments[1], a2 = arguments[2], o2 = arguments[3], u3 = arguments[4], l2 = arguments[5];
            if (s2 - r2 == 1 && u3 - o2 == 1) return l2.addIntersections(this.e, r2, a2.e, o2), null;
            if (!this.overlaps(r2, s2, a2, o2, u3)) return null;
            var h2 = Math.trunc((r2 + s2) / 2), c2 = Math.trunc((o2 + u3) / 2);
            r2 < h2 && (o2 < c2 && this.computeIntersectsForChain(r2, h2, a2, o2, c2, l2), c2 < u3 && this.computeIntersectsForChain(r2, h2, a2, c2, u3, l2)), h2 < s2 && (o2 < c2 && this.computeIntersectsForChain(h2, s2, a2, o2, c2, l2), c2 < u3 && this.computeIntersectsForChain(h2, s2, a2, c2, u3, l2));
          }
        } }, { key: "overlaps", value: function(t2, e2, n2, i2, r2) {
          return U.intersects(this.pts[t2], this.pts[e2], n2.pts[i2], n2.pts[r2]);
        } }, { key: "getStartIndexes", value: function() {
          return this.startIndex;
        } }, { key: "computeIntersects", value: function(t2, e2) {
          for (var n2 = 0; n2 < this.startIndex.length - 1; n2++) for (var i2 = 0; i2 < t2.startIndex.length - 1; i2++) this.computeIntersectsForChain(n2, t2, i2, e2);
        } }], [{ key: "constructor_", value: function() {
          this.e = null, this.pts = null, this.startIndex = null;
          var t2 = arguments[0];
          this.e = t2, this.pts = t2.getCoordinates();
          var e2 = new ei();
          this.startIndex = e2.getChainStartIndices(this.pts);
        } }]);
      }(), ii = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "getDepth", value: function(t3, e2) {
          return this._depth[t3][e2];
        } }, { key: "setDepth", value: function(t3, e2, n2) {
          this._depth[t3][e2] = n2;
        } }, { key: "isNull", value: function() {
          if (0 === arguments.length) {
            for (var e2 = 0; e2 < 2; e2++) for (var n2 = 0; n2 < 3; n2++) if (this._depth[e2][n2] !== t2.NULL_VALUE) return false;
            return true;
          }
          if (1 === arguments.length) {
            var i2 = arguments[0];
            return this._depth[i2][1] === t2.NULL_VALUE;
          }
          if (2 === arguments.length) {
            var r2 = arguments[0], s2 = arguments[1];
            return this._depth[r2][s2] === t2.NULL_VALUE;
          }
        } }, { key: "normalize", value: function() {
          for (var t3 = 0; t3 < 2; t3++) if (!this.isNull(t3)) {
            var e2 = this._depth[t3][1];
            this._depth[t3][2] < e2 && (e2 = this._depth[t3][2]), e2 < 0 && (e2 = 0);
            for (var n2 = 1; n2 < 3; n2++) {
              var i2 = 0;
              this._depth[t3][n2] > e2 && (i2 = 1), this._depth[t3][n2] = i2;
            }
          }
        } }, { key: "getDelta", value: function(t3) {
          return this._depth[t3][$.RIGHT] - this._depth[t3][$.LEFT];
        } }, { key: "getLocation", value: function(t3, e2) {
          return this._depth[t3][e2] <= 0 ? H.EXTERIOR : H.INTERIOR;
        } }, { key: "toString", value: function() {
          return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
        } }, { key: "add", value: function() {
          if (1 === arguments.length) for (var e2 = arguments[0], n2 = 0; n2 < 2; n2++) for (var i2 = 1; i2 < 3; i2++) {
            var r2 = e2.getLocation(n2, i2);
            r2 !== H.EXTERIOR && r2 !== H.INTERIOR || (this.isNull(n2, i2) ? this._depth[n2][i2] = t2.depthAtLocation(r2) : this._depth[n2][i2] += t2.depthAtLocation(r2));
          }
          else if (3 === arguments.length) {
            var s2 = arguments[0], a2 = arguments[1];
            arguments[2] === H.INTERIOR && this._depth[s2][a2]++;
          }
        } }], [{ key: "constructor_", value: function() {
          this._depth = Array(2).fill().map(function() {
            return Array(3);
          });
          for (var e2 = 0; e2 < 2; e2++) for (var n2 = 0; n2 < 3; n2++) this._depth[e2][n2] = t2.NULL_VALUE;
        } }, { key: "depthAtLocation", value: function(e2) {
          return e2 === H.EXTERIOR ? 0 : e2 === H.INTERIOR ? 1 : t2.NULL_VALUE;
        } }]);
      }();
      ii.NULL_VALUE = -1;
      var ri = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "getDepth", value: function() {
          return this._depth;
        } }, { key: "getCollapsedEdge", value: function() {
          var t3 = new Array(2).fill(null);
          return t3[0] = this.pts[0], t3[1] = this.pts[1], new i2(t3, Ae.toLineLabel(this._label));
        } }, { key: "isIsolated", value: function() {
          return this._isIsolated;
        } }, { key: "getCoordinates", value: function() {
          return this.pts;
        } }, { key: "setIsolated", value: function(t3) {
          this._isIsolated = t3;
        } }, { key: "setName", value: function(t3) {
          this._name = t3;
        } }, { key: "equals", value: function(t3) {
          if (!(t3 instanceof i2)) return false;
          var e2 = t3;
          if (this.pts.length !== e2.pts.length) return false;
          for (var n2 = true, r2 = true, s2 = this.pts.length, a2 = 0; a2 < this.pts.length; a2++) if (this.pts[a2].equals2D(e2.pts[a2]) || (n2 = false), this.pts[a2].equals2D(e2.pts[--s2]) || (r2 = false), !n2 && !r2) return false;
          return true;
        } }, { key: "getCoordinate", value: function() {
          if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null;
          if (1 === arguments.length) {
            var t3 = arguments[0];
            return this.pts[t3];
          }
        } }, { key: "print", value: function(t3) {
          t3.print("edge " + this._name + ": "), t3.print("LINESTRING (");
          for (var e2 = 0; e2 < this.pts.length; e2++) e2 > 0 && t3.print(","), t3.print(this.pts[e2].x + " " + this.pts[e2].y);
          t3.print(")  " + this._label + " " + this._depthDelta);
        } }, { key: "computeIM", value: function(t3) {
          i2.updateIM(this._label, t3);
        } }, { key: "isCollapsed", value: function() {
          return !!this._label.isArea() && (3 === this.pts.length && !!this.pts[0].equals(this.pts[2]));
        } }, { key: "isClosed", value: function() {
          return this.pts[0].equals(this.pts[this.pts.length - 1]);
        } }, { key: "getMaximumSegmentIndex", value: function() {
          return this.pts.length - 1;
        } }, { key: "getDepthDelta", value: function() {
          return this._depthDelta;
        } }, { key: "getNumPoints", value: function() {
          return this.pts.length;
        } }, { key: "printReverse", value: function(t3) {
          t3.print("edge " + this._name + ": ");
          for (var e2 = this.pts.length - 1; e2 >= 0; e2--) t3.print(this.pts[e2] + " ");
          t3.println("");
        } }, { key: "getMonotoneChainEdge", value: function() {
          return null === this._mce && (this._mce = new ni(this)), this._mce;
        } }, { key: "getEnvelope", value: function() {
          if (null === this._env) {
            this._env = new U();
            for (var t3 = 0; t3 < this.pts.length; t3++) this._env.expandToInclude(this.pts[t3]);
          }
          return this._env;
        } }, { key: "addIntersection", value: function(t3, e2, n2, i3) {
          var r2 = new X(t3.getIntersection(i3)), s2 = e2, a2 = t3.getEdgeDistance(n2, i3), o2 = s2 + 1;
          if (o2 < this.pts.length) {
            var u3 = this.pts[o2];
            r2.equals2D(u3) && (s2 = o2, a2 = 0);
          }
          this.eiList.add(r2, s2, a2);
        } }, { key: "toString", value: function() {
          var t3 = new Jt();
          t3.append("edge " + this._name + ": "), t3.append("LINESTRING (");
          for (var e2 = 0; e2 < this.pts.length; e2++) e2 > 0 && t3.append(","), t3.append(this.pts[e2].x + " " + this.pts[e2].y);
          return t3.append(")  " + this._label + " " + this._depthDelta), t3.toString();
        } }, { key: "isPointwiseEqual", value: function(t3) {
          if (this.pts.length !== t3.pts.length) return false;
          for (var e2 = 0; e2 < this.pts.length; e2++) if (!this.pts[e2].equals2D(t3.pts[e2])) return false;
          return true;
        } }, { key: "setDepthDelta", value: function(t3) {
          this._depthDelta = t3;
        } }, { key: "getEdgeIntersectionList", value: function() {
          return this.eiList;
        } }, { key: "addIntersections", value: function(t3, e2, n2) {
          for (var i3 = 0; i3 < t3.getIntersectionNum(); i3++) this.addIntersection(t3, e2, n2, i3);
        } }], [{ key: "constructor_", value: function() {
          if (this.pts = null, this._env = null, this.eiList = new Qn(this), this._name = null, this._mce = null, this._isIsolated = true, this._depth = new ii(), this._depthDelta = 0, 1 === arguments.length) {
            var t3 = arguments[0];
            i2.constructor_.call(this, t3, null);
          } else if (2 === arguments.length) {
            var e2 = arguments[0], n2 = arguments[1];
            this.pts = e2, this._label = n2;
          }
        } }, { key: "updateIM", value: function() {
          if (!(2 === arguments.length && arguments[1] instanceof $n && arguments[0] instanceof Ae)) return f(i2, "updateIM", this).apply(this, arguments);
          var t3 = arguments[0], e2 = arguments[1];
          e2.setAtLeastIfValid(t3.getLocation(0, $.ON), t3.getLocation(1, $.ON), 1), t3.isArea() && (e2.setAtLeastIfValid(t3.getLocation(0, $.LEFT), t3.getLocation(1, $.LEFT), 2), e2.setAtLeastIfValid(t3.getLocation(0, $.RIGHT), t3.getLocation(1, $.RIGHT), 2));
        } }]);
      }(Ge), si = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "setWorkingPrecisionModel", value: function(t3) {
          this._workingPrecisionModel = t3;
        } }, { key: "insertUniqueEdge", value: function(e2) {
          var n2 = this._edgeList.findEqualEdge(e2);
          if (null !== n2) {
            var i2 = n2.getLabel(), r2 = e2.getLabel();
            n2.isPointwiseEqual(e2) || (r2 = new Ae(e2.getLabel())).flip(), i2.merge(r2);
            var s2 = t2.depthDelta(r2), a2 = n2.getDepthDelta() + s2;
            n2.setDepthDelta(a2);
          } else this._edgeList.add(e2), e2.setDepthDelta(t2.depthDelta(e2.getLabel()));
        } }, { key: "buildSubgraphs", value: function(t3, e2) {
          for (var n2 = new yt(), i2 = t3.iterator(); i2.hasNext(); ) {
            var r2 = i2.next(), s2 = r2.getRightmostCoordinate(), a2 = new Pn(n2).getDepth(s2);
            r2.computeDepth(a2), r2.findResultEdges(), n2.add(r2), e2.add(r2.getDirectedEdges(), r2.getNodes());
          }
        } }, { key: "createSubgraphs", value: function(t3) {
          for (var e2 = new yt(), n2 = t3.getNodes().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (!i2.isVisited()) {
              var r2 = new _t();
              r2.create(i2), e2.add(r2);
            }
          }
          return an.sort(e2, an.reverseOrder()), e2;
        } }, { key: "createEmptyResultGeometry", value: function() {
          return this._geomFact.createPolygon();
        } }, { key: "getNoder", value: function(t3) {
          if (null !== this._workingNoder) return this._workingNoder;
          var e2 = new Cn(), n2 = new we();
          return n2.setPrecisionModel(t3), e2.setSegmentIntersector(new Kn(n2)), e2;
        } }, { key: "buffer", value: function(t3, e2) {
          var n2 = this._workingPrecisionModel;
          null === n2 && (n2 = t3.getPrecisionModel()), this._geomFact = t3.getFactory();
          var i2 = new An(n2, this._bufParams), r2 = new Yn(t3, e2, i2).getCurves();
          if (r2.size() <= 0) return this.createEmptyResultGeometry();
          this.computeNodedEdges(r2, n2), this._graph = new Qe(new Hn()), this._graph.addEdges(this._edgeList.getEdges());
          var s2 = this.createSubgraphs(this._graph), a2 = new $e(this._geomFact);
          this.buildSubgraphs(s2, a2);
          var o2 = a2.getPolygons();
          return o2.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(o2);
        } }, { key: "computeNodedEdges", value: function(t3, e2) {
          var n2 = this.getNoder(e2);
          n2.computeNodes(t3);
          for (var i2 = n2.getNodedSubstrings().iterator(); i2.hasNext(); ) {
            var r2 = i2.next(), s2 = r2.getCoordinates();
            if (2 !== s2.length || !s2[0].equals2D(s2[1])) {
              var a2 = r2.getData(), o2 = new ri(r2.getCoordinates(), new Ae(a2));
              this.insertUniqueEdge(o2);
            }
          }
        } }, { key: "setNoder", value: function(t3) {
          this._workingNoder = t3;
        } }], [{ key: "constructor_", value: function() {
          this._bufParams = null, this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new jn();
          var t3 = arguments[0];
          this._bufParams = t3;
        } }, { key: "depthDelta", value: function(t3) {
          var e2 = t3.getLocation(0, $.LEFT), n2 = t3.getLocation(0, $.RIGHT);
          return e2 === H.INTERIOR && n2 === H.EXTERIOR ? 1 : e2 === H.EXTERIOR && n2 === H.INTERIOR ? -1 : 0;
        } }, { key: "convertSegStrings", value: function(t3) {
          for (var e2 = new ae(), n2 = new yt(); t3.hasNext(); ) {
            var i2 = t3.next(), r2 = e2.createLineString(i2.getCoordinates());
            n2.add(r2);
          }
          return e2.buildGeometry(n2);
        } }]);
      }(), ai = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "rescale", value: function() {
          if (rt(arguments[0], Z)) for (var t3 = arguments[0].iterator(); t3.hasNext(); ) {
            var e2 = t3.next();
            this.rescale(e2.getCoordinates());
          }
          else if (arguments[0] instanceof Array) {
            for (var n2 = arguments[0], i2 = 0; i2 < n2.length; i2++) n2[i2].x = n2[i2].x / this._scaleFactor + this._offsetX, n2[i2].y = n2[i2].y / this._scaleFactor + this._offsetY;
            2 === n2.length && n2[0].equals2D(n2[1]) && mt.out.println(n2);
          }
        } }, { key: "scale", value: function() {
          if (rt(arguments[0], Z)) {
            for (var t3 = arguments[0], e2 = new yt(t3.size()), n2 = t3.iterator(); n2.hasNext(); ) {
              var i2 = n2.next();
              e2.add(new xn(this.scale(i2.getCoordinates()), i2.getData()));
            }
            return e2;
          }
          if (arguments[0] instanceof Array) {
            for (var r2 = arguments[0], s2 = new Array(r2.length).fill(null), a2 = 0; a2 < r2.length; a2++) s2[a2] = new X(Math.round((r2[a2].x - this._offsetX) * this._scaleFactor), Math.round((r2[a2].y - this._offsetY) * this._scaleFactor), r2[a2].getZ());
            return jt.removeRepeatedPoints(s2);
          }
        } }, { key: "isIntegerPrecision", value: function() {
          return 1 === this._scaleFactor;
        } }, { key: "getNodedSubstrings", value: function() {
          var t3 = this._noder.getNodedSubstrings();
          return this._isScaled && this.rescale(t3), t3;
        } }, { key: "computeNodes", value: function(t3) {
          var e2 = t3;
          this._isScaled && (e2 = this.scale(t3)), this._noder.computeNodes(e2);
        } }, { key: "interfaces_", get: function() {
          return [Sn];
        } }], [{ key: "constructor_", value: function() {
          if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = false, 2 === arguments.length) {
            var e2 = arguments[0], n2 = arguments[1];
            t2.constructor_.call(this, e2, n2, 0, 0);
          } else if (4 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this._noder = i2, this._scaleFactor = r2, this._isScaled = !this.isIntegerPrecision();
          }
        } }]);
      }(), oi = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "checkEndPtVertexIntersections", value: function() {
          if (0 === arguments.length) for (var t3 = this._segStrings.iterator(); t3.hasNext(); ) {
            var e2 = t3.next().getCoordinates();
            this.checkEndPtVertexIntersections(e2[0], this._segStrings), this.checkEndPtVertexIntersections(e2[e2.length - 1], this._segStrings);
          }
          else if (2 === arguments.length) {
            for (var n2 = arguments[0], i2 = arguments[1].iterator(); i2.hasNext(); ) for (var r2 = i2.next().getCoordinates(), s2 = 1; s2 < r2.length - 1; s2++) if (r2[s2].equals(n2)) throw new D2("found endpt/interior pt intersection at index " + s2 + " :pt " + n2);
          }
        } }, { key: "checkInteriorIntersections", value: function() {
          if (0 === arguments.length) for (var t3 = this._segStrings.iterator(); t3.hasNext(); ) for (var e2 = t3.next(), n2 = this._segStrings.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            this.checkInteriorIntersections(e2, i2);
          }
          else if (2 === arguments.length) for (var r2 = arguments[0], s2 = arguments[1], a2 = r2.getCoordinates(), o2 = s2.getCoordinates(), u3 = 0; u3 < a2.length - 1; u3++) for (var l2 = 0; l2 < o2.length - 1; l2++) this.checkInteriorIntersections(r2, u3, s2, l2);
          else if (4 === arguments.length) {
            var h2 = arguments[0], c2 = arguments[1], f2 = arguments[2], g2 = arguments[3];
            if (h2 === f2 && c2 === g2) return null;
            var v2 = h2.getCoordinates()[c2], y2 = h2.getCoordinates()[c2 + 1], d2 = f2.getCoordinates()[g2], _2 = f2.getCoordinates()[g2 + 1];
            if (this._li.computeIntersection(v2, y2, d2, _2), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, v2, y2) || this.hasInteriorIntersection(this._li, d2, _2))) throw new D2("found non-noded intersection at " + v2 + "-" + y2 + " and " + d2 + "-" + _2);
          }
        } }, { key: "checkValid", value: function() {
          this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
        } }, { key: "checkCollapses", value: function() {
          if (0 === arguments.length) for (var t3 = this._segStrings.iterator(); t3.hasNext(); ) {
            var e2 = t3.next();
            this.checkCollapses(e2);
          }
          else if (1 === arguments.length) for (var n2 = arguments[0].getCoordinates(), i2 = 0; i2 < n2.length - 2; i2++) this.checkCollapse(n2[i2], n2[i2 + 1], n2[i2 + 2]);
        } }, { key: "hasInteriorIntersection", value: function(t3, e2, n2) {
          for (var i2 = 0; i2 < t3.getIntersectionNum(); i2++) {
            var r2 = t3.getIntersection(i2);
            if (!r2.equals(e2) && !r2.equals(n2)) return true;
          }
          return false;
        } }, { key: "checkCollapse", value: function(e2, n2, i2) {
          if (e2.equals(i2)) throw new D2("found non-noded collapse at " + t2.fact.createLineString([e2, n2, i2]));
        } }], [{ key: "constructor_", value: function() {
          this._li = new we(), this._segStrings = null;
          var t3 = arguments[0];
          this._segStrings = t3;
        } }]);
      }();
      oi.fact = new ae();
      var ui = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "intersectsScaled", value: function(t3, e2) {
          var n2 = Math.min(t3.x, e2.x), i2 = Math.max(t3.x, e2.x), r2 = Math.min(t3.y, e2.y), s2 = Math.max(t3.y, e2.y), a2 = this._maxx < n2 || this._minx > i2 || this._maxy < r2 || this._miny > s2;
          if (a2) return false;
          var o2 = this.intersectsToleranceSquare(t3, e2);
          return G.isTrue(!(a2 && o2), "Found bad envelope test"), o2;
        } }, { key: "initCorners", value: function(t3) {
          var e2 = 0.5;
          this._minx = t3.x - e2, this._maxx = t3.x + e2, this._miny = t3.y - e2, this._maxy = t3.y + e2, this._corner[0] = new X(this._maxx, this._maxy), this._corner[1] = new X(this._minx, this._maxy), this._corner[2] = new X(this._minx, this._miny), this._corner[3] = new X(this._maxx, this._miny);
        } }, { key: "intersects", value: function(t3, e2) {
          return 1 === this._scaleFactor ? this.intersectsScaled(t3, e2) : (this.copyScaled(t3, this._p0Scaled), this.copyScaled(e2, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
        } }, { key: "scale", value: function(t3) {
          return Math.round(t3 * this._scaleFactor);
        } }, { key: "getCoordinate", value: function() {
          return this._originalPt;
        } }, { key: "copyScaled", value: function(t3, e2) {
          e2.x = this.scale(t3.x), e2.y = this.scale(t3.y);
        } }, { key: "getSafeEnvelope", value: function() {
          if (null === this._safeEnv) {
            var e2 = t2.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
            this._safeEnv = new U(this._originalPt.x - e2, this._originalPt.x + e2, this._originalPt.y - e2, this._originalPt.y + e2);
          }
          return this._safeEnv;
        } }, { key: "intersectsPixelClosure", value: function(t3, e2) {
          return this._li.computeIntersection(t3, e2, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(t3, e2, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(t3, e2, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(t3, e2, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));
        } }, { key: "intersectsToleranceSquare", value: function(t3, e2) {
          var n2 = false, i2 = false;
          return this._li.computeIntersection(t3, e2, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(t3, e2, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (n2 = true), this._li.computeIntersection(t3, e2, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (i2 = true), this._li.computeIntersection(t3, e2, this._corner[3], this._corner[0]), !!this._li.isProper() || (!(!n2 || !i2) || (!!t3.equals(this._pt) || !!e2.equals(this._pt))))));
        } }, { key: "addSnappedNode", value: function(t3, e2) {
          var n2 = t3.getCoordinate(e2), i2 = t3.getCoordinate(e2 + 1);
          return !!this.intersects(n2, i2) && (t3.addIntersection(this.getCoordinate(), e2), true);
        } }], [{ key: "constructor_", value: function() {
          this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
          var t3 = arguments[0], e2 = arguments[1], n2 = arguments[2];
          if (this._originalPt = t3, this._pt = t3, this._scaleFactor = e2, this._li = n2, e2 <= 0) throw new m("Scale factor must be non-zero");
          1 !== e2 && (this._pt = new X(this.scale(t3.x), this.scale(t3.y)), this._p0Scaled = new X(), this._p1Scaled = new X()), this.initCorners(this._pt);
        } }]);
      }();
      ui.SAFE_ENV_EXPANSION_FACTOR = 0.75;
      var li = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "select", value: function() {
          if (1 === arguments.length) ;
          else if (2 === arguments.length) {
            var t2 = arguments[1];
            arguments[0].getLineSegment(t2, this.selectedSegment), this.select(this.selectedSegment);
          }
        } }], [{ key: "constructor_", value: function() {
          this.selectedSegment = new In();
        } }]);
      }(), hi = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "snap", value: function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.snap(t2, null, -1);
          }
          if (3 === arguments.length) {
            var e2 = arguments[0], i2 = arguments[1], r2 = arguments[2], a2 = e2.getSafeEnvelope(), o2 = new ci(e2, i2, r2);
            return this._index.query(a2, new (function() {
              return s(function t3() {
                n(this, t3);
              }, [{ key: "interfaces_", get: function() {
                return [ln];
              } }, { key: "visitItem", value: function(t3) {
                t3.select(a2, o2);
              } }]);
            }())()), o2.isNodeAdded();
          }
        } }], [{ key: "constructor_", value: function() {
          this._index = null;
          var t2 = arguments[0];
          this._index = t2;
        } }]);
      }(), ci = function(t2) {
        function i2() {
          var t3;
          return n(this, i2), t3 = e(this, i2), i2.constructor_.apply(t3, arguments), t3;
        }
        return l(i2, t2), s(i2, [{ key: "isNodeAdded", value: function() {
          return this._isNodeAdded;
        } }, { key: "select", value: function() {
          if (!(2 === arguments.length && Number.isInteger(arguments[1]) && arguments[0] instanceof Nn)) return f(i2, "select", this, 1).apply(this, arguments);
          var t3 = arguments[1], e2 = arguments[0].getContext();
          if (this._parentEdge === e2 && (t3 === this._hotPixelVertexIndex || t3 + 1 === this._hotPixelVertexIndex)) return null;
          this._isNodeAdded |= this._hotPixel.addSnappedNode(e2, t3);
        } }], [{ key: "constructor_", value: function() {
          this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = false;
          var t3 = arguments[0], e2 = arguments[1], n2 = arguments[2];
          this._hotPixel = t3, this._parentEdge = e2, this._hotPixelVertexIndex = n2;
        } }]);
      }(li);
      hi.HotPixelSnapAction = ci;
      var fi = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "processIntersections", value: function(t2, e2, n2, i2) {
          if (t2 === n2 && e2 === i2) return null;
          var r2 = t2.getCoordinates()[e2], s2 = t2.getCoordinates()[e2 + 1], a2 = n2.getCoordinates()[i2], o2 = n2.getCoordinates()[i2 + 1];
          if (this._li.computeIntersection(r2, s2, a2, o2), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
            for (var u3 = 0; u3 < this._li.getIntersectionNum(); u3++) this._interiorIntersections.add(this._li.getIntersection(u3));
            t2.addIntersections(this._li, e2, 0), n2.addIntersections(this._li, i2, 1);
          }
        } }, { key: "isDone", value: function() {
          return false;
        } }, { key: "getInteriorIntersections", value: function() {
          return this._interiorIntersections;
        } }, { key: "interfaces_", get: function() {
          return [Wn];
        } }], [{ key: "constructor_", value: function() {
          this._li = null, this._interiorIntersections = null;
          var t2 = arguments[0];
          this._li = t2, this._interiorIntersections = new yt();
        } }]);
      }(), gi = function() {
        return s(function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }, [{ key: "checkCorrectness", value: function(t2) {
          var e2 = xn.getNodedSubstrings(t2), n2 = new oi(e2);
          try {
            n2.checkValid();
          } catch (t3) {
            if (!(t3 instanceof p)) throw t3;
            t3.printStackTrace();
          }
        } }, { key: "getNodedSubstrings", value: function() {
          return xn.getNodedSubstrings(this._nodedSegStrings);
        } }, { key: "snapRound", value: function(t2, e2) {
          var n2 = this.findInteriorIntersections(t2, e2);
          this.computeIntersectionSnaps(n2), this.computeVertexSnaps(t2);
        } }, { key: "findInteriorIntersections", value: function(t2, e2) {
          var n2 = new fi(e2);
          return this._noder.setSegmentIntersector(n2), this._noder.computeNodes(t2), n2.getInteriorIntersections();
        } }, { key: "computeVertexSnaps", value: function() {
          if (rt(arguments[0], Z)) for (var t2 = arguments[0].iterator(); t2.hasNext(); ) {
            var e2 = t2.next();
            this.computeVertexSnaps(e2);
          }
          else if (arguments[0] instanceof xn) for (var n2 = arguments[0], i2 = n2.getCoordinates(), r2 = 0; r2 < i2.length; r2++) {
            var s2 = new ui(i2[r2], this._scaleFactor, this._li);
            this._pointSnapper.snap(s2, n2, r2) && n2.addIntersection(i2[r2], r2);
          }
        } }, { key: "computeNodes", value: function(t2) {
          this._nodedSegStrings = t2, this._noder = new Cn(), this._pointSnapper = new hi(this._noder.getIndex()), this.snapRound(t2, this._li);
        } }, { key: "computeIntersectionSnaps", value: function(t2) {
          for (var e2 = t2.iterator(); e2.hasNext(); ) {
            var n2 = e2.next(), i2 = new ui(n2, this._scaleFactor, this._li);
            this._pointSnapper.snap(i2);
          }
        } }, { key: "interfaces_", get: function() {
          return [Sn];
        } }], [{ key: "constructor_", value: function() {
          this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
          var t2 = arguments[0];
          this._pm = t2, this._li = new we(), this._li.setPrecisionModel(t2), this._scaleFactor = t2.getScale();
        } }]);
      }(), vi = function() {
        function t2() {
          n(this, t2), t2.constructor_.apply(this, arguments);
        }
        return s(t2, [{ key: "bufferFixedPrecision", value: function(t3) {
          var e2 = new ai(new gi(new ie(1)), t3.getScale()), n2 = new si(this._bufParams);
          n2.setWorkingPrecisionModel(t3), n2.setNoder(e2), this._resultGeometry = n2.buffer(this._argGeom, this._distance);
        } }, { key: "bufferReducedPrecision", value: function() {
          if (0 === arguments.length) {
            for (var e2 = t2.MAX_PRECISION_DIGITS; e2 >= 0; e2--) {
              try {
                this.bufferReducedPrecision(e2);
              } catch (t3) {
                if (!(t3 instanceof gt)) throw t3;
                this._saveException = t3;
              }
              if (null !== this._resultGeometry) return null;
            }
            throw this._saveException;
          }
          if (1 === arguments.length) {
            var n2 = arguments[0], i2 = t2.precisionScaleFactor(this._argGeom, this._distance, n2), r2 = new ie(i2);
            this.bufferFixedPrecision(r2);
          }
        } }, { key: "computeGeometry", value: function() {
          if (this.bufferOriginalPrecision(), null !== this._resultGeometry) return null;
          var t3 = this._argGeom.getFactory().getPrecisionModel();
          t3.getType() === ie.FIXED ? this.bufferFixedPrecision(t3) : this.bufferReducedPrecision();
        } }, { key: "setQuadrantSegments", value: function(t3) {
          this._bufParams.setQuadrantSegments(t3);
        } }, { key: "bufferOriginalPrecision", value: function() {
          try {
            var t3 = new si(this._bufParams);
            this._resultGeometry = t3.buffer(this._argGeom, this._distance);
          } catch (t4) {
            if (!(t4 instanceof D2)) throw t4;
            this._saveException = t4;
          }
        } }, { key: "getResultGeometry", value: function(t3) {
          return this._distance = t3, this.computeGeometry(), this._resultGeometry;
        } }, { key: "setEndCapStyle", value: function(t3) {
          this._bufParams.setEndCapStyle(t3);
        } }], [{ key: "constructor_", value: function() {
          if (this._argGeom = null, this._distance = null, this._bufParams = new _(), this._resultGeometry = null, this._saveException = null, 1 === arguments.length) {
            var t3 = arguments[0];
            this._argGeom = t3;
          } else if (2 === arguments.length) {
            var e2 = arguments[0], n2 = arguments[1];
            this._argGeom = e2, this._bufParams = n2;
          }
        } }, { key: "bufferOp", value: function() {
          if (2 === arguments.length) {
            var e2 = arguments[1];
            return new t2(arguments[0]).getResultGeometry(e2);
          }
          if (3 === arguments.length) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof V && "number" == typeof arguments[1]) {
              var n2 = arguments[1], i2 = arguments[2], r2 = new t2(arguments[0]);
              return r2.setQuadrantSegments(i2), r2.getResultGeometry(n2);
            }
            if (arguments[2] instanceof _ && arguments[0] instanceof V && "number" == typeof arguments[1]) {
              var s2 = arguments[1];
              return new t2(arguments[0], arguments[2]).getResultGeometry(s2);
            }
          } else if (4 === arguments.length) {
            var a2 = arguments[1], o2 = arguments[2], u3 = arguments[3], l2 = new t2(arguments[0]);
            return l2.setQuadrantSegments(o2), l2.setEndCapStyle(u3), l2.getResultGeometry(a2);
          }
        } }, { key: "precisionScaleFactor", value: function(t3, e2, n2) {
          var i2 = t3.getEnvelopeInternal(), r2 = kt.max(Math.abs(i2.getMaxX()), Math.abs(i2.getMaxY()), Math.abs(i2.getMinX()), Math.abs(i2.getMinY())) + 2 * (e2 > 0 ? e2 : 0), s2 = n2 - Math.trunc(Math.log(r2) / Math.log(10) + 1);
          return Math.pow(10, s2);
        } }]);
      }();
      vi.CAP_ROUND = _.CAP_ROUND, vi.CAP_BUTT = _.CAP_FLAT, vi.CAP_FLAT = _.CAP_FLAT, vi.CAP_SQUARE = _.CAP_SQUARE, vi.MAX_PRECISION_DIGITS = 12;
      var yi = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], di = function() {
        return s(function t2(e2) {
          n(this, t2), this.geometryFactory = e2 || new ae();
        }, [{ key: "read", value: function(t2) {
          var e2, n2 = (e2 = "string" == typeof t2 ? JSON.parse(t2) : t2).type;
          if (!_i[n2]) throw new Error("Unknown GeoJSON type: " + e2.type);
          return -1 !== yi.indexOf(n2) ? _i[n2].call(this, e2.coordinates) : "GeometryCollection" === n2 ? _i[n2].call(this, e2.geometries) : _i[n2].call(this, e2);
        } }, { key: "write", value: function(t2) {
          var e2 = t2.getGeometryType();
          if (!pi2[e2]) throw new Error("Geometry is not supported");
          return pi2[e2].call(this, t2);
        } }]);
      }(), _i = { Feature: function(t2) {
        var e2 = {};
        for (var n2 in t2) e2[n2] = t2[n2];
        if (t2.geometry) {
          var i2 = t2.geometry.type;
          if (!_i[i2]) throw new Error("Unknown GeoJSON type: " + t2.type);
          e2.geometry = this.read(t2.geometry);
        }
        return t2.bbox && (e2.bbox = _i.bbox.call(this, t2.bbox)), e2;
      }, FeatureCollection: function(t2) {
        var e2 = {};
        if (t2.features) {
          e2.features = [];
          for (var n2 = 0; n2 < t2.features.length; ++n2) e2.features.push(this.read(t2.features[n2]));
        }
        return t2.bbox && (e2.bbox = this.parse.bbox.call(this, t2.bbox)), e2;
      }, coordinates: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.length; ++n2) {
          var r2 = t2[n2];
          e2.push(i(X, g(r2)));
        }
        return e2;
      }, bbox: function(t2) {
        return this.geometryFactory.createLinearRing([new X(t2[0], t2[1]), new X(t2[2], t2[1]), new X(t2[2], t2[3]), new X(t2[0], t2[3]), new X(t2[0], t2[1])]);
      }, Point: function(t2) {
        var e2 = i(X, g(t2));
        return this.geometryFactory.createPoint(e2);
      }, MultiPoint: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.length; ++n2) e2.push(_i.Point.call(this, t2[n2]));
        return this.geometryFactory.createMultiPoint(e2);
      }, LineString: function(t2) {
        var e2 = _i.coordinates.call(this, t2);
        return this.geometryFactory.createLineString(e2);
      }, MultiLineString: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.length; ++n2) e2.push(_i.LineString.call(this, t2[n2]));
        return this.geometryFactory.createMultiLineString(e2);
      }, Polygon: function(t2) {
        for (var e2 = _i.coordinates.call(this, t2[0]), n2 = this.geometryFactory.createLinearRing(e2), i2 = [], r2 = 1; r2 < t2.length; ++r2) {
          var s2 = t2[r2], a2 = _i.coordinates.call(this, s2), o2 = this.geometryFactory.createLinearRing(a2);
          i2.push(o2);
        }
        return this.geometryFactory.createPolygon(n2, i2);
      }, MultiPolygon: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.length; ++n2) {
          var i2 = t2[n2];
          e2.push(_i.Polygon.call(this, i2));
        }
        return this.geometryFactory.createMultiPolygon(e2);
      }, GeometryCollection: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2.length; ++n2) {
          var i2 = t2[n2];
          e2.push(this.read(i2));
        }
        return this.geometryFactory.createGeometryCollection(e2);
      } }, pi2 = { coordinate: function(t2) {
        var e2 = [t2.x, t2.y];
        return t2.z && e2.push(t2.z), t2.m && e2.push(t2.m), e2;
      }, Point: function(t2) {
        return { type: "Point", coordinates: pi2.coordinate.call(this, t2.getCoordinate()) };
      }, MultiPoint: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
          var i2 = t2._geometries[n2], r2 = pi2.Point.call(this, i2);
          e2.push(r2.coordinates);
        }
        return { type: "MultiPoint", coordinates: e2 };
      }, LineString: function(t2) {
        for (var e2 = [], n2 = t2.getCoordinates(), i2 = 0; i2 < n2.length; ++i2) {
          var r2 = n2[i2];
          e2.push(pi2.coordinate.call(this, r2));
        }
        return { type: "LineString", coordinates: e2 };
      }, MultiLineString: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
          var i2 = t2._geometries[n2], r2 = pi2.LineString.call(this, i2);
          e2.push(r2.coordinates);
        }
        return { type: "MultiLineString", coordinates: e2 };
      }, Polygon: function(t2) {
        var e2 = [], n2 = pi2.LineString.call(this, t2._shell);
        e2.push(n2.coordinates);
        for (var i2 = 0; i2 < t2._holes.length; ++i2) {
          var r2 = t2._holes[i2], s2 = pi2.LineString.call(this, r2);
          e2.push(s2.coordinates);
        }
        return { type: "Polygon", coordinates: e2 };
      }, MultiPolygon: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
          var i2 = t2._geometries[n2], r2 = pi2.Polygon.call(this, i2);
          e2.push(r2.coordinates);
        }
        return { type: "MultiPolygon", coordinates: e2 };
      }, GeometryCollection: function(t2) {
        for (var e2 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
          var i2 = t2._geometries[n2], r2 = i2.getGeometryType();
          e2.push(pi2[r2].call(this, i2));
        }
        return { type: "GeometryCollection", geometries: e2 };
      } };
      return { BufferOp: vi, GeoJSONReader: function() {
        return s(function t2(e2) {
          n(this, t2), this.parser = new di(e2 || new ae());
        }, [{ key: "read", value: function(t2) {
          return this.parser.read(t2);
        } }]);
      }(), GeoJSONWriter: function() {
        return s(function t2() {
          n(this, t2), this.parser = new di(this.geometryFactory);
        }, [{ key: "write", value: function(t2) {
          return this.parser.write(t2);
        } }]);
      }() };
    });
  })(jsts_min$1);
  return jsts_min$1.exports;
}
var jsts_minExports = requireJsts_min();
const jsts = /* @__PURE__ */ getDefaultExportFromCjs(jsts_minExports);
function adder() {
  return new Adder();
}
function Adder() {
  this.reset();
}
Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = // rounded value
    this.t = 0;
  },
  add: function(y) {
    add(temp, y, this.t);
    add(this, temp.s, this.s);
    if (this.s) this.t += temp.t;
    else this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};
var temp = new Adder();
function add(adder2, a, b) {
  var x = adder2.s = a + b, bv = x - a, av = x - bv;
  adder2.t = a - av + (b - bv);
}
var epsilon = 1e-6;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var sin = Math.sin;
var sqrt = Math.sqrt;
function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}
function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}
function noop() {
}
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};
function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}
function geoStream(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}
adder();
adder();
function spherical(cartesian2) {
  return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
}
function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}
function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}
function cartesianNormalizeInPlace(d) {
  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}
adder();
function compose(a, b) {
  function compose2(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }
  if (a.invert && b.invert) compose2.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };
  return compose2;
}
function rotationIdentity(lambda, phi) {
  return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
  function rotation(lambda, phi) {
    var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      asin(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi) {
    var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      asin(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };
  return rotation;
}
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;
  }
  for (var point2, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point2 = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
    stream.point(point2[0], point2[1]);
  }
}
function circleRadius(cosRadius, point2) {
  point2 = cartesian(point2), point2[0] -= cosRadius;
  cartesianNormalizeInPlace(point2);
  var radius = acos(-point2[1]);
  return ((-point2[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
}
function clipBuffer() {
  var lines = [], line;
  return {
    point: function(x, y) {
      line.push([x, y]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}
function clipLine(a, b, x02, y02, x12, y12) {
  var ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
  r = x02 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }
  r = x12 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }
  r = y02 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }
  r = y12 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }
  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}
function pointEqual(a, b) {
  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
}
function Intersection(point2, points, other, entry) {
  this.x = point2;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function clipPolygon(segments, compareIntersection2, startInside, interpolate, stream) {
  var subject = [], clip2 = [], i, n;
  segments.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0) return;
    var n2, p0 = segment[0], p1 = segment[n2], x;
    if (pointEqual(p0, p1)) {
      stream.lineStart();
      for (i = 0; i < n2; ++i) stream.point((p0 = segment[i])[0], p0[1]);
      stream.lineEnd();
      return;
    }
    subject.push(x = new Intersection(p0, segment, null, true));
    clip2.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip2.push(x.o = new Intersection(p1, null, x, true));
  });
  if (!subject.length) return;
  clip2.sort(compareIntersection2);
  link(subject);
  link(clip2);
  for (i = 0, n = clip2.length; i < n; ++i) {
    clip2[i].e = startInside = !startInside;
  }
  var start = subject[0], points, point2;
  while (1) {
    var current = start, isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point2 = points[i])[0], point2[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point2 = points[i])[0], point2[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link(array) {
  if (!(n = array.length)) return;
  var n, i = 0, a = array[0], b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function bisector(compare2) {
  if (compare2.length === 1) compare2 = ascendingComparator(compare2);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare2(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare2(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}
function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}
bisector(ascending);
function merge(arrays) {
  var n = arrays.length, m, i = -1, j = 0, merged, array;
  while (++i < n) j += arrays[i].length;
  merged = new Array(j);
  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }
  return merged;
}
var clipMax = 1e9, clipMin = -clipMax;
function clipExtent(x02, y02, x12, y12) {
  function visible(x, y) {
    return x02 <= x && x <= x12 && y02 <= y && y <= y12;
  }
  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream.point(a === 0 || a === 3 ? x02 : x12, a > 1 ? y12 : y02);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p, direction) {
    return abs(p[0] - x02) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x12) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y02) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a, b) {
    return comparePoint(a.x, b.x);
  }
  function comparePoint(a, b) {
    var ca = corner(a, 1), cb = corner(b, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = clipBuffer(), segments, polygon2, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point2(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon2.length; i < n; ++i) {
        for (var ring2 = polygon2[i], j = 1, m = ring2.length, point3 = ring2[0], a0, a1, b0 = point3[0], b1 = point3[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point3 = ring2[j], b0 = point3[0], b1 = point3[1];
          if (a1 <= y12) {
            if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x02 - a0)) ++winding;
          } else {
            if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x02 - a0)) --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon2 = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          clipPolygon(segments, compareIntersection2, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon2 = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint;
      if (polygon2) polygon2.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point2;
      if (v_) activeStream.lineEnd();
    }
    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon2) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if (clipLine(a, b, x02, y02, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }
    return clipStream;
  };
}
var sum = adder();
function polygonContains(polygon2, point2) {
  var lambda = point2[0], phi = point2[1], normal = [sin(lambda), -cos(lambda), 0], angle = 0, winding = 0;
  sum.reset();
  for (var i = 0, n = polygon2.length; i < n; ++i) {
    if (!(m = (ring = polygon2[i]).length)) continue;
    var ring, m, point0 = ring[m - 1], lambda0 = point0[0], phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin(phi0), cosPhi0 = cos(phi0);
    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda1 = point1[0], phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi1), cosPhi1 = cos(phi1), delta = lambda1 - lambda0, sign = delta >= 0 ? 1 : -1, absDelta = sign * delta, antimeridian = absDelta > pi, k = sinPhi0 * sinPhi1;
      sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
      angle += antimeridian ? delta + sign * tau : delta;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection3 = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection3);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection3[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ winding & 1;
}
adder();
function identity(x) {
  return x;
}
adder();
adder();
var x0 = Infinity, y0 = x0, x1 = -x0, y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop,
  result: function() {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};
function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}
adder();
function clip(pointVisible, clipLine2, interpolate, start) {
  return function(rotate, sink) {
    var line = clipLine2(sink), rotatedStart = rotate.invert(start[0], start[1]), ringBuffer = clipBuffer(), ringSink = clipLine2(ringBuffer), polygonStarted = false, polygon2, segments, ring;
    var clip2 = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip2.point = pointRing;
        clip2.lineStart = ringStart;
        clip2.lineEnd = ringEnd;
        segments = [];
        polygon2 = [];
      },
      polygonEnd: function() {
        clip2.point = point2;
        clip2.lineStart = lineStart;
        clip2.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains(polygon2, rotatedStart);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          clipPolygon(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon2 = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point2(lambda, phi) {
      var point3 = rotate(lambda, phi);
      if (pointVisible(lambda = point3[0], phi = point3[1])) sink.point(lambda, phi);
    }
    function pointLine(lambda, phi) {
      var point3 = rotate(lambda, phi);
      line.point(point3[0], point3[1]);
    }
    function lineStart() {
      clip2.point = pointLine;
      line.lineStart();
    }
    function lineEnd() {
      clip2.point = point2;
      line.lineEnd();
    }
    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      var point3 = rotate(lambda, phi);
      ringSink.point(point3[0], point3[1]);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point3;
      ring.pop();
      polygon2.push(ring);
      ring = null;
      if (!n) return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point3 = segment[i])[0], point3[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip2;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
}
const clipAntimeridian = clip(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi, -halfPi]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi : -pi, delta = abs(lambda1 - lambda0);
      if (abs(delta - pi) < epsilon) {
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi) {
        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon;
        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin(lambda0 - lambda1);
  return abs(sinLambda0Lambda1) > epsilon ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1) - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * halfPi;
    stream.point(-pi, phi);
    stream.point(0, phi);
    stream.point(pi, phi);
    stream.point(pi, 0);
    stream.point(pi, -phi);
    stream.point(0, -phi);
    stream.point(-pi, -phi);
    stream.point(-pi, 0);
    stream.point(-pi, phi);
  } else if (abs(from[0] - to[0]) > epsilon) {
    var lambda = from[0] < to[0] ? pi : -pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}
function clipCircle(radius, delta) {
  var cr = cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon;
  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }
  function visible(lambda, phi) {
    return cos(lambda) * cos(phi) > cr;
  }
  function clipLine2(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi], point2, v = visible(lambda, phi), c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        if (v !== v0) {
          point2 = intersect2(point0, point1);
          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
            point1[0] += epsilon;
            point1[1] += epsilon;
            v = visible(point1[0], point1[1]);
          }
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            stream.lineStart();
            point2 = intersect2(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            point2 = intersect2(point0, point1);
            stream.point(point2[0], point2[1]);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          if (!(c & c0) && (t = intersect2(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
            }
          }
        }
        if (v && (!point0 || !pointEqual(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect2(a, b, two) {
    var pa = cartesian(a), pb = cartesian(b);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant) return !two && a;
    var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1), B2 = cartesianScale(n2, c2);
    cartesianAddInPlace(A, B2);
    var u2 = n1xn2, w = cartesianDot(A, u2), uu = cartesianDot(u2, u2), t2 = w * w - uu * (cartesianDot(A, A) - 1);
    if (t2 < 0) return;
    var t = sqrt(t2), q = cartesianScale(u2, (-w - t) / uu);
    cartesianAddInPlace(q, A);
    q = spherical(q);
    if (!two) return q;
    var lambda0 = a[0], lambda1 = b[0], phi0 = a[1], phi1 = b[1], z;
    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;
    var delta2 = lambda1 - lambda0, polar = abs(delta2 - pi) < epsilon, meridian = polar || delta2 < epsilon;
    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;
    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta2 > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = cartesianScale(u2, (-w + t) / uu);
      cartesianAddInPlace(q1, A);
      return [q, spherical(q1)];
    }
  }
  function code(lambda, phi) {
    var r = smallRadius ? radius : pi - radius, code2 = 0;
    if (lambda < -r) code2 |= 1;
    else if (lambda > r) code2 |= 2;
    if (phi < -r) code2 |= 4;
    else if (phi > r) code2 |= 8;
    return code2;
  }
  return clip(visible, clipLine2, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
}
function transformer(methods) {
  return function(stream) {
    var s = new TransformStream();
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) {
    this.stream.point(x, y);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function fitExtent(projection2, extent, object) {
  var w = extent[1][0] - extent[0][0], h = extent[1][1] - extent[0][1], clip2 = projection2.clipExtent && projection2.clipExtent();
  projection2.scale(150).translate([0, 0]);
  if (clip2 != null) projection2.clipExtent(null);
  geoStream(object, projection2.stream(boundsStream));
  var b = boundsStream.result(), k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
  if (clip2 != null) projection2.clipExtent(clip2);
  return projection2.scale(k * 150).translate([x, y]);
}
function fitSize(projection2, size, object) {
  return fitExtent(projection2, [[0, 0], size], object);
}
var maxDepth = 16, cosMinDistance = cos(30 * radians);
function resample(project, delta2) {
  return +delta2 ? resample$1(project, delta2) : resampleNone(project);
}
function resampleNone(project) {
  return transformer({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}
function resample$1(project, delta2) {
  function resampleLineTo(x02, y02, lambda0, a0, b0, c0, x12, y12, lambda1, a1, b1, c1, depth, stream) {
    var dx = x12 - x02, dy = y12 - y02, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = sqrt(a * a + b * b + c * c), phi2 = asin(c /= m), lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a), p = project(lambda2, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x02, dy2 = y2 - y02, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x02, y02, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x12, y12, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, lambda0, x02, y02, a0, b0, c0;
    var resampleStream = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point2(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }
    function lineStart() {
      x02 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }
    function linePoint(lambda, phi) {
      var c = cartesian([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x02, y02, lambda0, a0, b0, c0, x02 = p[0], y02 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x02, y02);
    }
    function lineEnd() {
      resampleStream.point = point2;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x02, y00 = y02, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }
    function ringEnd() {
      resampleLineTo(x02, y02, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}
var transformRadians = transformer({
  point: function(x, y) {
    this.stream.point(x * radians, y * radians);
  }
});
function projection(project) {
  return projectionMutator(function() {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project, k = 150, x = 480, y = 250, dx, dy, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, theta = null, preclip = clipAntimeridian, x02 = null, y02, x12, y12, postclip = identity, delta2 = 0.5, projectResample = resample(projectTransform, delta2), cache, cacheStream;
  function projection2(point2) {
    point2 = projectRotate(point2[0] * radians, point2[1] * radians);
    return [point2[0] * k + dx, dy - point2[1] * k];
  }
  function invert(point2) {
    point2 = projectRotate.invert((point2[0] - dx) / k, (dy - point2[1]) / k);
    return point2 && [point2[0] * degrees, point2[1] * degrees];
  }
  function projectTransform(x2, y2) {
    return x2 = project(x2, y2), [x2[0] * k + dx, dy - x2[1] * k];
  }
  projection2.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));
  };
  projection2.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
  };
  projection2.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity) : clipExtent(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
  };
  projection2.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };
  projection2.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };
  projection2.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
  };
  projection2.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };
  projection2.precision = function(_) {
    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
  };
  projection2.fitExtent = function(extent, object) {
    return fitExtent(projection2, extent, object);
  };
  projection2.fitSize = function(size, object) {
    return fitSize(projection2, size, object);
  };
  function recenter() {
    projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
    var center2 = project(lambda, phi);
    dx = x - center2[0] * k;
    dy = y + center2[1] * k;
    return reset();
  }
  function reset() {
    cache = cacheStream = null;
    return projection2;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection2.invert = project.invert && invert;
    return recenter();
  };
}
function azimuthalRaw(scale) {
  return function(x, y) {
    var cx = cos(x), cy = cos(y), k = scale(cx * cy);
    return [
      k * cy * sin(x),
      k * sin(y)
    ];
  };
}
function azimuthalInvert(angle) {
  return function(x, y) {
    var z = sqrt(x * x + y * y), c = angle(z), sc = sin(c), cc = cos(c);
    return [
      atan2(x * sc, z * cc),
      asin(z && y * sc / z)
    ];
  };
}
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin(z / 2);
});
var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
  return (c = acos(c)) && c / sin(c);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});
function geoAzimuthalEquidistant() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}
function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}
equirectangularRaw.invert = equirectangularRaw;
var { BufferOp, GeoJSONReader, GeoJSONWriter } = jsts;
function buffer(geojson, radius, options) {
  options = options || {};
  var units = options.units || "kilometers";
  var steps = options.steps || 8;
  if (!geojson) throw new Error("geojson is required");
  if (typeof options !== "object") throw new Error("options must be an object");
  if (typeof steps !== "number") throw new Error("steps must be an number");
  if (radius === void 0) throw new Error("radius is required");
  if (steps <= 0) throw new Error("steps must be greater than 0");
  var results = [];
  switch (geojson.type) {
    case "GeometryCollection":
      geomEach(geojson, function(geometry) {
        var buffered = bufferFeature(geometry, radius, units, steps);
        if (buffered) results.push(buffered);
      });
      return featureCollection(results);
    case "FeatureCollection":
      featureEach(geojson, function(feature2) {
        var multiBuffered = bufferFeature(feature2, radius, units, steps);
        if (multiBuffered) {
          featureEach(multiBuffered, function(buffered) {
            if (buffered) results.push(buffered);
          });
        }
      });
      return featureCollection(results);
  }
  return bufferFeature(geojson, radius, units, steps);
}
function bufferFeature(geojson, radius, units, steps) {
  var properties = geojson.properties || {};
  var geometry = geojson.type === "Feature" ? geojson.geometry : geojson;
  if (geometry.type === "GeometryCollection") {
    var results = [];
    geomEach(geojson, function(geometry2) {
      var buffered2 = bufferFeature(geometry2, radius, units, steps);
      if (buffered2) results.push(buffered2);
    });
    return featureCollection(results);
  }
  var projection2 = defineProjection(geometry);
  var projected = {
    type: geometry.type,
    coordinates: projectCoords(geometry.coordinates, projection2)
  };
  var reader = new GeoJSONReader();
  var geom = reader.read(projected);
  var distance2 = radiansToLength(lengthToRadians(radius, units), "meters");
  var buffered = BufferOp.bufferOp(geom, distance2, steps);
  var writer = new GeoJSONWriter();
  buffered = writer.write(buffered);
  if (coordsIsNaN(buffered.coordinates)) return void 0;
  var result = {
    type: buffered.type,
    coordinates: unprojectCoords(buffered.coordinates, projection2)
  };
  return feature(result, properties);
}
function coordsIsNaN(coords) {
  if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);
  return isNaN(coords[0]);
}
function projectCoords(coords, proj) {
  if (typeof coords[0] !== "object") return proj(coords);
  return coords.map(function(coord) {
    return projectCoords(coord, proj);
  });
}
function unprojectCoords(coords, proj) {
  if (typeof coords[0] !== "object") return proj.invert(coords);
  return coords.map(function(coord) {
    return unprojectCoords(coord, proj);
  });
}
function defineProjection(geojson) {
  var coords = center(geojson).geometry.coordinates;
  var rotation = [-coords[0], -coords[1]];
  return geoAzimuthalEquidistant().rotate(rotation).scale(earthRadius);
}
function centroid(geojson, options = {}) {
  let xSum = 0;
  let ySum = 0;
  let len = 0;
  coordEach(
    geojson,
    function(coord) {
      xSum += coord[0];
      ySum += coord[1];
      len++;
    },
    true
  );
  return point([xSum / len, ySum / len], options.properties);
}
var concaveman$1 = { exports: {} };
var rbush_min$1 = { exports: {} };
var rbush_min = rbush_min$1.exports;
var hasRequiredRbush_min;
function requireRbush_min() {
  if (hasRequiredRbush_min) return rbush_min$1.exports;
  hasRequiredRbush_min = 1;
  (function(module, exports) {
    !function(t, i) {
      module.exports = i();
    }(rbush_min, function() {
      function t(t2, r2, e2, a2, h2) {
        !function t3(n2, r3, e3, a3, h3) {
          for (; a3 > e3; ) {
            if (a3 - e3 > 600) {
              var o2 = a3 - e3 + 1, s2 = r3 - e3 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u3 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m2 = Math.max(e3, Math.floor(r3 - s2 * f2 / o2 + u3)), c2 = Math.min(a3, Math.floor(r3 + (o2 - s2) * f2 / o2 + u3));
              t3(n2, r3, m2, c2, h3);
            }
            var p2 = n2[r3], d2 = e3, x = a3;
            for (i(n2, e3, r3), h3(n2[a3], p2) > 0 && i(n2, e3, a3); d2 < x; ) {
              for (i(n2, d2, x), d2++, x--; h3(n2[d2], p2) < 0; ) d2++;
              for (; h3(n2[x], p2) > 0; ) x--;
            }
            0 === h3(n2[e3], p2) ? i(n2, e3, x) : i(n2, ++x, a3), x <= r3 && (e3 = x + 1), r3 <= x && (a3 = x - 1);
          }
        }(t2, r2, e2 || 0, a2 || t2.length - 1, h2 || n);
      }
      function i(t2, i2, n2) {
        var r2 = t2[i2];
        t2[i2] = t2[n2], t2[n2] = r2;
      }
      function n(t2, i2) {
        return t2 < i2 ? -1 : t2 > i2 ? 1 : 0;
      }
      var r = function(t2) {
        void 0 === t2 && (t2 = 9), this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
      };
      function e(t2, i2, n2) {
        if (!n2) return i2.indexOf(t2);
        for (var r2 = 0; r2 < i2.length; r2++) if (n2(t2, i2[r2])) return r2;
        return -1;
      }
      function a(t2, i2) {
        h(t2, 0, t2.children.length, i2, t2);
      }
      function h(t2, i2, n2, r2, e2) {
        e2 || (e2 = p(null)), e2.minX = 1 / 0, e2.minY = 1 / 0, e2.maxX = -1 / 0, e2.maxY = -1 / 0;
        for (var a2 = i2; a2 < n2; a2++) {
          var h2 = t2.children[a2];
          o(e2, t2.leaf ? r2(h2) : h2);
        }
        return e2;
      }
      function o(t2, i2) {
        return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
      }
      function s(t2, i2) {
        return t2.minX - i2.minX;
      }
      function l(t2, i2) {
        return t2.minY - i2.minY;
      }
      function f(t2) {
        return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
      }
      function u2(t2) {
        return t2.maxX - t2.minX + (t2.maxY - t2.minY);
      }
      function m(t2, i2) {
        return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
      }
      function c(t2, i2) {
        return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
      }
      function p(t2) {
        return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
      }
      function d(i2, n2, r2, e2, a2) {
        for (var h2 = [n2, r2]; h2.length; ) if (!((r2 = h2.pop()) - (n2 = h2.pop()) <= e2)) {
          var o2 = n2 + Math.ceil((r2 - n2) / e2 / 2) * e2;
          t(i2, o2, n2, r2, a2), h2.push(n2, o2, o2, r2);
        }
      }
      return r.prototype.all = function() {
        return this._all(this.data, []);
      }, r.prototype.search = function(t2) {
        var i2 = this.data, n2 = [];
        if (!c(t2, i2)) return n2;
        for (var r2 = this.toBBox, e2 = []; i2; ) {
          for (var a2 = 0; a2 < i2.children.length; a2++) {
            var h2 = i2.children[a2], o2 = i2.leaf ? r2(h2) : h2;
            c(t2, o2) && (i2.leaf ? n2.push(h2) : m(t2, o2) ? this._all(h2, n2) : e2.push(h2));
          }
          i2 = e2.pop();
        }
        return n2;
      }, r.prototype.collides = function(t2) {
        var i2 = this.data;
        if (!c(t2, i2)) return false;
        for (var n2 = []; i2; ) {
          for (var r2 = 0; r2 < i2.children.length; r2++) {
            var e2 = i2.children[r2], a2 = i2.leaf ? this.toBBox(e2) : e2;
            if (c(t2, a2)) {
              if (i2.leaf || m(t2, a2)) return true;
              n2.push(e2);
            }
          }
          i2 = n2.pop();
        }
        return false;
      }, r.prototype.load = function(t2) {
        if (!t2 || !t2.length) return this;
        if (t2.length < this._minEntries) {
          for (var i2 = 0; i2 < t2.length; i2++) this.insert(t2[i2]);
          return this;
        }
        var n2 = this._build(t2.slice(), 0, t2.length - 1, 0);
        if (this.data.children.length) if (this.data.height === n2.height) this._splitRoot(this.data, n2);
        else {
          if (this.data.height < n2.height) {
            var r2 = this.data;
            this.data = n2, n2 = r2;
          }
          this._insert(n2, this.data.height - n2.height - 1, true);
        }
        else this.data = n2;
        return this;
      }, r.prototype.insert = function(t2) {
        return t2 && this._insert(t2, this.data.height - 1), this;
      }, r.prototype.clear = function() {
        return this.data = p([]), this;
      }, r.prototype.remove = function(t2, i2) {
        if (!t2) return this;
        for (var n2, r2, a2, h2 = this.data, o2 = this.toBBox(t2), s2 = [], l2 = []; h2 || s2.length; ) {
          if (h2 || (h2 = s2.pop(), r2 = s2[s2.length - 1], n2 = l2.pop(), a2 = true), h2.leaf) {
            var f2 = e(t2, h2.children, i2);
            if (-1 !== f2) return h2.children.splice(f2, 1), s2.push(h2), this._condense(s2), this;
          }
          a2 || h2.leaf || !m(h2, o2) ? r2 ? (n2++, h2 = r2.children[n2], a2 = false) : h2 = null : (s2.push(h2), l2.push(n2), n2 = 0, r2 = h2, h2 = h2.children[0]);
        }
        return this;
      }, r.prototype.toBBox = function(t2) {
        return t2;
      }, r.prototype.compareMinX = function(t2, i2) {
        return t2.minX - i2.minX;
      }, r.prototype.compareMinY = function(t2, i2) {
        return t2.minY - i2.minY;
      }, r.prototype.toJSON = function() {
        return this.data;
      }, r.prototype.fromJSON = function(t2) {
        return this.data = t2, this;
      }, r.prototype._all = function(t2, i2) {
        for (var n2 = []; t2; ) t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
        return i2;
      }, r.prototype._build = function(t2, i2, n2, r2) {
        var e2, h2 = n2 - i2 + 1, o2 = this._maxEntries;
        if (h2 <= o2) return a(e2 = p(t2.slice(i2, n2 + 1)), this.toBBox), e2;
        r2 || (r2 = Math.ceil(Math.log(h2) / Math.log(o2)), o2 = Math.ceil(h2 / Math.pow(o2, r2 - 1))), (e2 = p([])).leaf = false, e2.height = r2;
        var s2 = Math.ceil(h2 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
        d(t2, i2, n2, l2, this.compareMinX);
        for (var f2 = i2; f2 <= n2; f2 += l2) {
          var u3 = Math.min(f2 + l2 - 1, n2);
          d(t2, f2, u3, s2, this.compareMinY);
          for (var m2 = f2; m2 <= u3; m2 += s2) {
            var c2 = Math.min(m2 + s2 - 1, u3);
            e2.children.push(this._build(t2, m2, c2, r2 - 1));
          }
        }
        return a(e2, this.toBBox), e2;
      }, r.prototype._chooseSubtree = function(t2, i2, n2, r2) {
        for (; r2.push(i2), !i2.leaf && r2.length - 1 !== n2; ) {
          for (var e2 = 1 / 0, a2 = 1 / 0, h2 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
            var s2 = i2.children[o2], l2 = f(s2), u3 = (m2 = t2, c2 = s2, (Math.max(c2.maxX, m2.maxX) - Math.min(c2.minX, m2.minX)) * (Math.max(c2.maxY, m2.maxY) - Math.min(c2.minY, m2.minY)) - l2);
            u3 < a2 ? (a2 = u3, e2 = l2 < e2 ? l2 : e2, h2 = s2) : u3 === a2 && l2 < e2 && (e2 = l2, h2 = s2);
          }
          i2 = h2 || i2.children[0];
        }
        var m2, c2;
        return i2;
      }, r.prototype._insert = function(t2, i2, n2) {
        var r2 = n2 ? t2 : this.toBBox(t2), e2 = [], a2 = this._chooseSubtree(r2, this.data, i2, e2);
        for (a2.children.push(t2), o(a2, r2); i2 >= 0 && e2[i2].children.length > this._maxEntries; ) this._split(e2, i2), i2--;
        this._adjustParentBBoxes(r2, e2, i2);
      }, r.prototype._split = function(t2, i2) {
        var n2 = t2[i2], r2 = n2.children.length, e2 = this._minEntries;
        this._chooseSplitAxis(n2, e2, r2);
        var h2 = this._chooseSplitIndex(n2, e2, r2), o2 = p(n2.children.splice(h2, n2.children.length - h2));
        o2.height = n2.height, o2.leaf = n2.leaf, a(n2, this.toBBox), a(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
      }, r.prototype._splitRoot = function(t2, i2) {
        this.data = p([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, a(this.data, this.toBBox);
      }, r.prototype._chooseSplitIndex = function(t2, i2, n2) {
        for (var r2, e2, a2, o2, s2, l2, u3, m2 = 1 / 0, c2 = 1 / 0, p2 = i2; p2 <= n2 - i2; p2++) {
          var d2 = h(t2, 0, p2, this.toBBox), x = h(t2, p2, n2, this.toBBox), v = (e2 = d2, a2 = x, o2 = void 0, s2 = void 0, l2 = void 0, u3 = void 0, o2 = Math.max(e2.minX, a2.minX), s2 = Math.max(e2.minY, a2.minY), l2 = Math.min(e2.maxX, a2.maxX), u3 = Math.min(e2.maxY, a2.maxY), Math.max(0, l2 - o2) * Math.max(0, u3 - s2)), M = f(d2) + f(x);
          v < m2 ? (m2 = v, r2 = p2, c2 = M < c2 ? M : c2) : v === m2 && M < c2 && (c2 = M, r2 = p2);
        }
        return r2 || n2 - i2;
      }, r.prototype._chooseSplitAxis = function(t2, i2, n2) {
        var r2 = t2.leaf ? this.compareMinX : s, e2 = t2.leaf ? this.compareMinY : l;
        this._allDistMargin(t2, i2, n2, r2) < this._allDistMargin(t2, i2, n2, e2) && t2.children.sort(r2);
      }, r.prototype._allDistMargin = function(t2, i2, n2, r2) {
        t2.children.sort(r2);
        for (var e2 = this.toBBox, a2 = h(t2, 0, i2, e2), s2 = h(t2, n2 - i2, n2, e2), l2 = u2(a2) + u2(s2), f2 = i2; f2 < n2 - i2; f2++) {
          var m2 = t2.children[f2];
          o(a2, t2.leaf ? e2(m2) : m2), l2 += u2(a2);
        }
        for (var c2 = n2 - i2 - 1; c2 >= i2; c2--) {
          var p2 = t2.children[c2];
          o(s2, t2.leaf ? e2(p2) : p2), l2 += u2(s2);
        }
        return l2;
      }, r.prototype._adjustParentBBoxes = function(t2, i2, n2) {
        for (var r2 = n2; r2 >= 0; r2--) o(i2[r2], t2);
      }, r.prototype._condense = function(t2) {
        for (var i2 = t2.length - 1, n2 = void 0; i2 >= 0; i2--) 0 === t2[i2].children.length ? i2 > 0 ? (n2 = t2[i2 - 1].children).splice(n2.indexOf(t2[i2]), 1) : this.clear() : a(t2[i2], this.toBBox);
      }, r;
    });
  })(rbush_min$1);
  return rbush_min$1.exports;
}
class TinyQueue2 {
  constructor(data = [], compare2 = defaultCompare) {
    this.data = data;
    this.length = this.data.length;
    this.compare = compare2;
    if (this.length > 0) {
      for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
    }
  }
  push(item) {
    this.data.push(item);
    this.length++;
    this._up(this.length - 1);
  }
  pop() {
    if (this.length === 0) return void 0;
    const top = this.data[0];
    const bottom = this.data.pop();
    this.length--;
    if (this.length > 0) {
      this.data[0] = bottom;
      this._down(0);
    }
    return top;
  }
  peek() {
    return this.data[0];
  }
  _up(pos) {
    const { data, compare: compare2 } = this;
    const item = data[pos];
    while (pos > 0) {
      const parent = pos - 1 >> 1;
      const current = data[parent];
      if (compare2(item, current) >= 0) break;
      data[pos] = current;
      pos = parent;
    }
    data[pos] = item;
  }
  _down(pos) {
    const { data, compare: compare2 } = this;
    const halfLength = this.length >> 1;
    const item = data[pos];
    while (pos < halfLength) {
      let left = (pos << 1) + 1;
      let best = data[left];
      const right = left + 1;
      if (right < this.length && compare2(data[right], best) < 0) {
        left = right;
        best = data[right];
      }
      if (compare2(best, item) >= 0) break;
      data[pos] = best;
      pos = left;
    }
    data[pos] = item;
  }
}
function defaultCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
const tinyqueue = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: TinyQueue2
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(tinyqueue);
var pointInPolygon = { exports: {} };
var flat;
var hasRequiredFlat;
function requireFlat() {
  if (hasRequiredFlat) return flat;
  hasRequiredFlat = 1;
  flat = function pointInPolygonFlat(point2, vs, start, end) {
    var x = point2[0], y = point2[1];
    var inside = false;
    if (start === void 0) start = 0;
    if (end === void 0) end = vs.length;
    var len = (end - start) / 2;
    for (var i = 0, j = len - 1; i < len; j = i++) {
      var xi = vs[start + i * 2 + 0], yi = vs[start + i * 2 + 1];
      var xj = vs[start + j * 2 + 0], yj = vs[start + j * 2 + 1];
      var intersect2 = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
      if (intersect2) inside = !inside;
    }
    return inside;
  };
  return flat;
}
var nested;
var hasRequiredNested;
function requireNested() {
  if (hasRequiredNested) return nested;
  hasRequiredNested = 1;
  nested = function pointInPolygonNested(point2, vs, start, end) {
    var x = point2[0], y = point2[1];
    var inside = false;
    if (start === void 0) start = 0;
    if (end === void 0) end = vs.length;
    var len = end - start;
    for (var i = 0, j = len - 1; i < len; j = i++) {
      var xi = vs[i + start][0], yi = vs[i + start][1];
      var xj = vs[j + start][0], yj = vs[j + start][1];
      var intersect2 = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
      if (intersect2) inside = !inside;
    }
    return inside;
  };
  return nested;
}
var hasRequiredPointInPolygon;
function requirePointInPolygon() {
  if (hasRequiredPointInPolygon) return pointInPolygon.exports;
  hasRequiredPointInPolygon = 1;
  var pointInPolygonFlat = requireFlat();
  var pointInPolygonNested = requireNested();
  pointInPolygon.exports = function pointInPolygon2(point2, vs, start, end) {
    if (vs.length > 0 && Array.isArray(vs[0])) {
      return pointInPolygonNested(point2, vs, start, end);
    } else {
      return pointInPolygonFlat(point2, vs, start, end);
    }
  };
  pointInPolygon.exports.nested = pointInPolygonNested;
  pointInPolygon.exports.flat = pointInPolygonFlat;
  return pointInPolygon.exports;
}
var orient2d_min$1 = { exports: {} };
var orient2d_min = orient2d_min$1.exports;
var hasRequiredOrient2d_min;
function requireOrient2d_min() {
  if (hasRequiredOrient2d_min) return orient2d_min$1.exports;
  hasRequiredOrient2d_min = 1;
  (function(module, exports) {
    !function(t, e) {
      e(exports);
    }(orient2d_min, function(t) {
      const e = 134217729, n = 33306690738754706e-32;
      function r(t2, e2, n2, r2, o2) {
        let f2, i2, u3, c2, s2 = e2[0], a2 = r2[0], d2 = 0, l2 = 0;
        a2 > s2 == a2 > -s2 ? (f2 = s2, s2 = e2[++d2]) : (f2 = a2, a2 = r2[++l2]);
        let p = 0;
        if (d2 < t2 && l2 < n2) for (a2 > s2 == a2 > -s2 ? (u3 = f2 - ((i2 = s2 + f2) - s2), s2 = e2[++d2]) : (u3 = f2 - ((i2 = a2 + f2) - a2), a2 = r2[++l2]), f2 = i2, 0 !== u3 && (o2[p++] = u3); d2 < t2 && l2 < n2; ) a2 > s2 == a2 > -s2 ? (u3 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e2[++d2]) : (u3 = f2 - ((i2 = f2 + a2) - (c2 = i2 - f2)) + (a2 - c2), a2 = r2[++l2]), f2 = i2, 0 !== u3 && (o2[p++] = u3);
        for (; d2 < t2; ) u3 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e2[++d2], f2 = i2, 0 !== u3 && (o2[p++] = u3);
        for (; l2 < n2; ) u3 = f2 - ((i2 = f2 + a2) - (c2 = i2 - f2)) + (a2 - c2), a2 = r2[++l2], f2 = i2, 0 !== u3 && (o2[p++] = u3);
        return 0 === f2 && 0 !== p || (o2[p++] = f2), p;
      }
      function o(t2) {
        return new Float64Array(t2);
      }
      const f = 33306690738754716e-32, i = 22204460492503146e-32, u2 = 11093356479670487e-47, c = o(4), s = o(8), a = o(12), d = o(16), l = o(4);
      t.orient2d = function(t2, o2, p, b, y, h) {
        const M = (o2 - h) * (p - y), x = (t2 - y) * (b - h), j = M - x;
        if (0 === M || 0 === x || M > 0 != x > 0) return j;
        const m = Math.abs(M + x);
        return Math.abs(j) >= f * m ? j : -function(t3, o3, f2, p2, b2, y2, h2) {
          let M2, x2, j2, m2, _, v, w, A, F, O, P, g, k, q, z, B2, C, D2;
          const E = t3 - b2, G = f2 - b2, H = o3 - y2, I = p2 - y2;
          _ = (z = (A = E - (w = (v = e * E) - (v - E))) * (O = I - (F = (v = e * I) - (v - I))) - ((q = E * I) - w * F - A * F - w * O)) - (P = z - (C = (A = H - (w = (v = e * H) - (v - H))) * (O = G - (F = (v = e * G) - (v - G))) - ((B2 = H * G) - w * F - A * F - w * O))), c[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), c[1] = k - (P + _) + (_ - B2), _ = (D2 = g + P) - g, c[2] = g - (D2 - _) + (P - _), c[3] = D2;
          let J = function(t4, e2) {
            let n2 = e2[0];
            for (let r2 = 1; r2 < t4; r2++) n2 += e2[r2];
            return n2;
          }(4, c), K = i * h2;
          if (J >= K || -J >= K) return J;
          if (M2 = t3 - (E + (_ = t3 - E)) + (_ - b2), j2 = f2 - (G + (_ = f2 - G)) + (_ - b2), x2 = o3 - (H + (_ = o3 - H)) + (_ - y2), m2 = p2 - (I + (_ = p2 - I)) + (_ - y2), 0 === M2 && 0 === x2 && 0 === j2 && 0 === m2) return J;
          if (K = u2 * h2 + n * Math.abs(J), (J += E * m2 + I * M2 - (H * j2 + G * x2)) >= K || -J >= K) return J;
          _ = (z = (A = M2 - (w = (v = e * M2) - (v - M2))) * (O = I - (F = (v = e * I) - (v - I))) - ((q = M2 * I) - w * F - A * F - w * O)) - (P = z - (C = (A = x2 - (w = (v = e * x2) - (v - x2))) * (O = G - (F = (v = e * G) - (v - G))) - ((B2 = x2 * G) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D2 = g + P) - g, l[2] = g - (D2 - _) + (P - _), l[3] = D2;
          const L2 = r(4, c, 4, l, s);
          _ = (z = (A = E - (w = (v = e * E) - (v - E))) * (O = m2 - (F = (v = e * m2) - (v - m2))) - ((q = E * m2) - w * F - A * F - w * O)) - (P = z - (C = (A = H - (w = (v = e * H) - (v - H))) * (O = j2 - (F = (v = e * j2) - (v - j2))) - ((B2 = H * j2) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D2 = g + P) - g, l[2] = g - (D2 - _) + (P - _), l[3] = D2;
          const N = r(L2, s, 4, l, a);
          _ = (z = (A = M2 - (w = (v = e * M2) - (v - M2))) * (O = m2 - (F = (v = e * m2) - (v - m2))) - ((q = M2 * m2) - w * F - A * F - w * O)) - (P = z - (C = (A = x2 - (w = (v = e * x2) - (v - x2))) * (O = j2 - (F = (v = e * j2) - (v - j2))) - ((B2 = x2 * j2) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D2 = g + P) - g, l[2] = g - (D2 - _) + (P - _), l[3] = D2;
          const Q = r(N, a, 4, l, d);
          return d[Q - 1];
        }(t2, o2, p, b, y, h, m);
      }, t.orient2dfast = function(t2, e2, n2, r2, o2, f2) {
        return (e2 - f2) * (n2 - o2) - (t2 - o2) * (r2 - f2);
      }, Object.defineProperty(t, "__esModule", { value: true });
    });
  })(orient2d_min$1, orient2d_min$1.exports);
  return orient2d_min$1.exports;
}
var hasRequiredConcaveman;
function requireConcaveman() {
  if (hasRequiredConcaveman) return concaveman$1.exports;
  hasRequiredConcaveman = 1;
  var RBush2 = requireRbush_min();
  var Queue = require$$1;
  var pointInPolygon2 = requirePointInPolygon();
  var orient = requireOrient2d_min().orient2d;
  if (Queue.default) {
    Queue = Queue.default;
  }
  concaveman$1.exports = concaveman2;
  concaveman$1.exports.default = concaveman2;
  function concaveman2(points, concavity, lengthThreshold) {
    concavity = Math.max(0, concavity === void 0 ? 2 : concavity);
    lengthThreshold = lengthThreshold || 0;
    var hull = fastConvexHull(points);
    var tree = new RBush2(16);
    tree.toBBox = function(a2) {
      return {
        minX: a2[0],
        minY: a2[1],
        maxX: a2[0],
        maxY: a2[1]
      };
    };
    tree.compareMinX = function(a2, b2) {
      return a2[0] - b2[0];
    };
    tree.compareMinY = function(a2, b2) {
      return a2[1] - b2[1];
    };
    tree.load(points);
    var queue = [];
    for (var i = 0, last; i < hull.length; i++) {
      var p = hull[i];
      tree.remove(p);
      last = insertNode(p, last);
      queue.push(last);
    }
    var segTree = new RBush2(16);
    for (i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));
    var sqConcavity = concavity * concavity;
    var sqLenThreshold = lengthThreshold * lengthThreshold;
    while (queue.length) {
      var node = queue.shift();
      var a = node.p;
      var b = node.next.p;
      var sqLen = getSqDist2(a, b);
      if (sqLen < sqLenThreshold) continue;
      var maxSqLen = sqLen / sqConcavity;
      p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);
      if (p && Math.min(getSqDist2(p, a), getSqDist2(p, b)) <= maxSqLen) {
        queue.push(node);
        queue.push(insertNode(p, node));
        tree.remove(p);
        segTree.remove(node);
        segTree.insert(updateBBox(node));
        segTree.insert(updateBBox(node.next));
      }
    }
    node = last;
    var concave = [];
    do {
      concave.push(node.p);
      node = node.next;
    } while (node !== last);
    concave.push(node.p);
    return concave;
  }
  function findCandidate(tree, a, b, c, d, maxDist, segTree) {
    var queue = new Queue([], compareDist);
    var node = tree.data;
    while (node) {
      for (var i = 0; i < node.children.length; i++) {
        var child = node.children[i];
        var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);
        if (dist > maxDist) continue;
        queue.push({
          node: child,
          dist
        });
      }
      while (queue.length && !queue.peek().node.children) {
        var item = queue.pop();
        var p = item.node;
        var d0 = sqSegDist(p, a, b);
        var d1 = sqSegDist(p, c, d);
        if (item.dist < d0 && item.dist < d1 && noIntersections(b, p, segTree) && noIntersections(c, p, segTree)) return p;
      }
      node = queue.pop();
      if (node) node = node.node;
    }
    return null;
  }
  function compareDist(a, b) {
    return a.dist - b.dist;
  }
  function sqSegBoxDist(a, b, bbox2) {
    if (inside(a, bbox2) || inside(b, bbox2)) return 0;
    var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox2.minX, bbox2.minY, bbox2.maxX, bbox2.minY);
    if (d1 === 0) return 0;
    var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox2.minX, bbox2.minY, bbox2.minX, bbox2.maxY);
    if (d2 === 0) return 0;
    var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox2.maxX, bbox2.minY, bbox2.maxX, bbox2.maxY);
    if (d3 === 0) return 0;
    var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox2.minX, bbox2.maxY, bbox2.maxX, bbox2.maxY);
    if (d4 === 0) return 0;
    return Math.min(d1, d2, d3, d4);
  }
  function inside(a, bbox2) {
    return a[0] >= bbox2.minX && a[0] <= bbox2.maxX && a[1] >= bbox2.minY && a[1] <= bbox2.maxY;
  }
  function noIntersections(a, b, segTree) {
    var minX = Math.min(a[0], b[0]);
    var minY = Math.min(a[1], b[1]);
    var maxX = Math.max(a[0], b[0]);
    var maxY = Math.max(a[1], b[1]);
    var edges = segTree.search({ minX, minY, maxX, maxY });
    for (var i = 0; i < edges.length; i++) {
      if (intersects2(edges[i].p, edges[i].next.p, a, b)) return false;
    }
    return true;
  }
  function cross(p1, p2, p3) {
    return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
  }
  function intersects2(p1, q1, p2, q2) {
    return p1 !== q2 && q1 !== p2 && cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 && cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;
  }
  function updateBBox(node) {
    var p1 = node.p;
    var p2 = node.next.p;
    node.minX = Math.min(p1[0], p2[0]);
    node.minY = Math.min(p1[1], p2[1]);
    node.maxX = Math.max(p1[0], p2[0]);
    node.maxY = Math.max(p1[1], p2[1]);
    return node;
  }
  function fastConvexHull(points) {
    var left = points[0];
    var top = points[0];
    var right = points[0];
    var bottom = points[0];
    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      if (p[0] < left[0]) left = p;
      if (p[0] > right[0]) right = p;
      if (p[1] < top[1]) top = p;
      if (p[1] > bottom[1]) bottom = p;
    }
    var cull = [left, top, right, bottom];
    var filtered = cull.slice();
    for (i = 0; i < points.length; i++) {
      if (!pointInPolygon2(points[i], cull)) filtered.push(points[i]);
    }
    return convexHull(filtered);
  }
  function insertNode(p, prev) {
    var node = {
      p,
      prev: null,
      next: null,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0
    };
    if (!prev) {
      node.prev = node;
      node.next = node;
    } else {
      node.next = prev.next;
      node.prev = prev;
      prev.next.prev = node;
      prev.next = node;
    }
    return node;
  }
  function getSqDist2(p1, p2) {
    var dx = p1[0] - p2[0], dy = p1[1] - p2[1];
    return dx * dx + dy * dy;
  }
  function sqSegDist(p, p1, p2) {
    var x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y;
    if (dx !== 0 || dy !== 0) {
      var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
      if (t > 1) {
        x = p2[0];
        y = p2[1];
      } else if (t > 0) {
        x += dx * t;
        y += dy * t;
      }
    }
    dx = p[0] - x;
    dy = p[1] - y;
    return dx * dx + dy * dy;
  }
  function sqSegSegDist(x02, y02, x12, y12, x2, y2, x3, y3) {
    var ux = x12 - x02;
    var uy = y12 - y02;
    var vx = x3 - x2;
    var vy = y3 - y2;
    var wx = x02 - x2;
    var wy = y02 - y2;
    var a = ux * ux + uy * uy;
    var b = ux * vx + uy * vy;
    var c = vx * vx + vy * vy;
    var d = ux * wx + uy * wy;
    var e = vx * wx + vy * wy;
    var D2 = a * c - b * b;
    var sc, sN, tc, tN;
    var sD = D2;
    var tD = D2;
    if (D2 === 0) {
      sN = 0;
      sD = 1;
      tN = e;
      tD = c;
    } else {
      sN = b * e - c * d;
      tN = a * e - b * d;
      if (sN < 0) {
        sN = 0;
        tN = e;
        tD = c;
      } else if (sN > sD) {
        sN = sD;
        tN = e + b;
        tD = c;
      }
    }
    if (tN < 0) {
      tN = 0;
      if (-d < 0) sN = 0;
      else if (-d > a) sN = sD;
      else {
        sN = -d;
        sD = a;
      }
    } else if (tN > tD) {
      tN = tD;
      if (-d + b < 0) sN = 0;
      else if (-d + b > a) sN = sD;
      else {
        sN = -d + b;
        sD = a;
      }
    }
    sc = sN === 0 ? 0 : sN / sD;
    tc = tN === 0 ? 0 : tN / tD;
    var cx = (1 - sc) * x02 + sc * x12;
    var cy = (1 - sc) * y02 + sc * y12;
    var cx2 = (1 - tc) * x2 + tc * x3;
    var cy2 = (1 - tc) * y2 + tc * y3;
    var dx = cx2 - cx;
    var dy = cy2 - cy;
    return dx * dx + dy * dy;
  }
  function compareByX(a, b) {
    return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
  }
  function convexHull(points) {
    points.sort(compareByX);
    var lower = [];
    for (var i = 0; i < points.length; i++) {
      while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {
        lower.pop();
      }
      lower.push(points[i]);
    }
    var upper = [];
    for (var ii = points.length - 1; ii >= 0; ii--) {
      while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0) {
        upper.pop();
      }
      upper.push(points[ii]);
    }
    upper.pop();
    lower.pop();
    return lower.concat(upper);
  }
  return concaveman$1.exports;
}
var concavemanExports = requireConcaveman();
const concaveman = /* @__PURE__ */ getDefaultExportFromCjs(concavemanExports);
function convex(geojson, options = {}) {
  options.concavity = options.concavity || Infinity;
  const points = [];
  coordEach(geojson, (coord) => {
    points.push([coord[0], coord[1]]);
  });
  if (!points.length) {
    return null;
  }
  const convexHull = concaveman(points, options.concavity);
  if (convexHull.length > 3) {
    return polygon([convexHull]);
  }
  return null;
}
function centerOfMass(geojson, options = {}) {
  switch (getType(geojson)) {
    case "Point":
      return point(getCoord(geojson), options.properties);
    case "Polygon":
      var coords = [];
      coordEach(geojson, function(coord) {
        coords.push(coord);
      });
      var centre = centroid(geojson, { properties: options.properties });
      var translation = centre.geometry.coordinates;
      var sx = 0;
      var sy = 0;
      var sArea = 0;
      var i, pi2, pj, xi, xj, yi, yj, a;
      var neutralizedPoints = coords.map(function(point2) {
        return [point2[0] - translation[0], point2[1] - translation[1]];
      });
      for (i = 0; i < coords.length - 1; i++) {
        pi2 = neutralizedPoints[i];
        xi = pi2[0];
        yi = pi2[1];
        pj = neutralizedPoints[i + 1];
        xj = pj[0];
        yj = pj[1];
        a = xi * yj - xj * yi;
        sArea += a;
        sx += (xi + xj) * a;
        sy += (yi + yj) * a;
      }
      if (sArea === 0) {
        return centre;
      } else {
        var area2 = sArea * 0.5;
        var areaFactor = 1 / (6 * area2);
        return point(
          [translation[0] + areaFactor * sx, translation[1] + areaFactor * sy],
          options.properties
        );
      }
    default:
      var hull = convex(geojson);
      if (hull) return centerOfMass(hull, { properties: options.properties });
      else return centroid(geojson, { properties: options.properties });
  }
}
function clone$1(geojson) {
  if (!geojson) {
    throw new Error("geojson is required");
  }
  switch (geojson.type) {
    case "Feature":
      return cloneFeature(geojson);
    case "FeatureCollection":
      return cloneFeatureCollection(geojson);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return cloneGeometry(geojson);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function cloneFeature(geojson) {
  const cloned = { type: "Feature" };
  Object.keys(geojson).forEach((key) => {
    switch (key) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.properties = cloneProperties(geojson.properties);
  if (geojson.geometry == null) {
    cloned.geometry = null;
  } else {
    cloned.geometry = cloneGeometry(geojson.geometry);
  }
  return cloned;
}
function cloneProperties(properties) {
  const cloned = {};
  if (!properties) {
    return cloned;
  }
  Object.keys(properties).forEach((key) => {
    const value = properties[key];
    if (typeof value === "object") {
      if (value === null) {
        cloned[key] = null;
      } else if (Array.isArray(value)) {
        cloned[key] = value.map((item) => {
          return item;
        });
      } else {
        cloned[key] = cloneProperties(value);
      }
    } else {
      cloned[key] = value;
    }
  });
  return cloned;
}
function cloneFeatureCollection(geojson) {
  const cloned = { type: "FeatureCollection" };
  Object.keys(geojson).forEach((key) => {
    switch (key) {
      case "type":
      case "features":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.features = geojson.features.map((feature2) => {
    return cloneFeature(feature2);
  });
  return cloned;
}
function cloneGeometry(geometry) {
  const geom = { type: geometry.type };
  if (geometry.bbox) {
    geom.bbox = geometry.bbox;
  }
  if (geometry.type === "GeometryCollection") {
    geom.geometries = geometry.geometries.map((g) => {
      return cloneGeometry(g);
    });
    return geom;
  }
  geom.coordinates = deepSlice(geometry.coordinates);
  return geom;
}
function deepSlice(coords) {
  const cloned = coords;
  if (typeof cloned[0] !== "object") {
    return cloned.slice();
  }
  return cloned.map((coord) => {
    return deepSlice(coord);
  });
}
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v, b) {
    var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
    if (!(x instanceof BigNumber2)) return new BigNumber2(v, b);
    if (b == null) {
      if (v && v._isBigNumber === true) {
        x.s = v.s;
        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }
        return;
      }
      if ((isNum = typeof v == "number") && v * 0 == 0) {
        x.s = 1 / v < 0 ? (v = -v, -1) : 1;
        if (v === ~~v) {
          for (e = 0, i = v; i >= 10; i /= 10, e++) ;
          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }
          return;
        }
        str = String(v);
      } else {
        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
      if ((i = str.search(/e/i)) > 0) {
        if (e < 0) e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {
        e = str.length;
      }
    } else {
      intCheck(b, 2, ALPHABET.length, "Base");
      if (b == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber2(v);
        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }
      str = String(v);
      if (isNum = typeof v == "number") {
        if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET.slice(0, b);
      e = i = 0;
      for (len = str.length; i < len; i++) {
        if (alphabet.indexOf(c = str.charAt(i)) < 0) {
          if (c == ".") {
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }
          return parseNumeric(x, String(v), isNum, b);
        }
      }
      isNum = false;
      str = convertBase(str, b, 10, x.s);
      if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
      else e = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; i++) ;
    for (len = str.length; str.charCodeAt(--len) === 48; ) ;
    if (str = str.slice(i, ++len)) {
      len -= i;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
        throw Error(tooManyDigits + x.s * v);
      }
      if ((e = e - i - 1) > MAX_EXP) {
        x.c = x.e = null;
      } else if (e < MIN_EXP) {
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = [];
        i = (e + 1) % LOG_BASE;
        if (e < 0) i += LOG_BASE;
        if (i < len) {
          if (i) x.c.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len; ) {
            x.c.push(+str.slice(i, i += LOG_BASE));
          }
          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }
        for (; i--; str += "0") ;
        x.c.push(+str);
      }
    } else {
      x.c = [x.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p, v;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        }
        if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        }
        if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }
        if (obj.hasOwnProperty(p = "RANGE")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error(bignumberError + p + " cannot be zero: " + v);
            }
          }
        }
        if (obj.hasOwnProperty(p = "CRYPTO")) {
          v = obj[p];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error(bignumberError + p + " not true or false: " + v);
          }
        }
        if (obj.hasOwnProperty(p = "MODULO_MODE")) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        }
        if (obj.hasOwnProperty(p = "POW_PRECISION")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        }
        if (obj.hasOwnProperty(p = "FORMAT")) {
          v = obj[p];
          if (typeof v == "object") FORMAT = v;
          else throw Error(bignumberError + p + " not an object: " + v);
        }
        if (obj.hasOwnProperty(p = "ALPHABET")) {
          v = obj[p];
          if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
            ALPHABET = v;
          } else {
            throw Error(bignumberError + p + " invalid: " + v);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber2.isBigNumber = function(v) {
    if (!v || v._isBigNumber !== true) return false;
    if (!BigNumber2.DEBUG) return true;
    var i, n, c = v.c, e = v.e, s = v.s;
    out: if ({}.toString.call(c) == "[object Array]") {
      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
        if (c[0] === 0) {
          if (e === 0 && c.length === 1) return true;
          break out;
        }
        i = (e + 1) % LOG_BASE;
        if (i < 1) i += LOG_BASE;
        if (String(c[0]).length == i) {
          for (i = 0; i < c.length; i++) {
            n = c[i];
            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
          }
          if (n !== 0) return true;
        }
      }
    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
      return true;
    }
    throw Error(bignumberError + "Invalid BigNumber: " + v);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, -1);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, 1);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
      if (dp == null) dp = DECIMAL_PLACES;
      else intCheck(dp, 0, MAX);
      k = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k *= 2));
          for (; i < k; ) {
            v = a[i] * 131072 + (a[i + 1] >>> 11);
            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b[0];
              a[i + 1] = b[1];
            } else {
              c.push(v % 1e14);
              i += 2;
            }
          }
          i = k / 2;
        } else if (crypto.randomBytes) {
          a = crypto.randomBytes(k *= 7);
          for (; i < k; ) {
            v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {
              c.push(v % 1e14);
              i += 7;
            }
          }
          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i < k; ) {
          v = random53bitInt();
          if (v < 9e15) c[i++] = v % 1e14;
        }
      }
      k = c[--i];
      dp %= LOG_BASE;
      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v) * v;
      }
      for (; c[i] === 0; c.pop(), i--) ;
      if (i < 0) {
        c = [e = 0];
      } else {
        for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
        for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
        if (i < LOG_BASE) e -= LOG_BASE - i;
      }
      rand.e = e;
      rand.c = c;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i = 1, args = arguments, sum2 = new BigNumber2(args[0]);
    for (; i < args.length; ) sum2 = sum2.plus(args[i++]);
    return sum2;
  };
  convertBase = /* @__PURE__ */ function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j, arr = [0], arrL, i = 0, len = str.length;
      for (; i < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
        arr[0] += alphabet.indexOf(str.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null) arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i >= 0) {
        k = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y = new BigNumber2(baseIn);
        x = y.pow(str.length - i);
        POW_PRECISION = k;
        y.c = toBaseOut(
          toFixedPoint(coeffToString(x.c), x.e, "0"),
          10,
          baseOut,
          decimal
        );
        y.e = y.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
      e = k = xc.length;
      for (; xc[--k] == 0; xc.pop()) ;
      if (!xc[0]) return alphabet.charAt(0);
      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e;
        x.s = sign;
        x = div(x, y, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      }
      d = e + dp + 1;
      i = xc[d];
      k = baseOut / 2;
      r = r || d < 0 || xc[d + 1] != null;
      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
      if (d < 1 || !xc[0]) {
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d;
        if (r) {
          for (--baseOut; ++xc[--d] > baseOut; ) {
            xc[d] = 0;
            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }
        for (k = xc.length; !xc[--k]; ) ;
        for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++])) ;
        str = toFixedPoint(str, e, alphabet.charAt(0));
      }
      return str;
    };
  }();
  div = /* @__PURE__ */ function() {
    function multiply(x, k, base) {
      var m, temp2, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
      for (x = x.slice(); i--; ) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp2 = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp2 / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp2 % base;
      }
      if (carry) x = [carry].concat(x);
      return x;
    }
    function compare2(a, b, aL, bL) {
      var i, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i = cmp = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            cmp = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a, b, aL, base) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
    }
    return function(x, y, dp, rm, base) {
      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
          )
        );
      }
      q = new BigNumber2(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;
      if (!base) {
        base = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }
      for (i = 0; yc[i] == (xc[i] || 0); i++) ;
      if (yc[i] > (xc[i] || 0)) e--;
      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2;
        n = mathfloor(base / (yc[0] + 1));
        if (n > 1) {
          yc = multiply(yc, n, base);
          xc = multiply(xc, n, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0) ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2) yc0++;
        do {
          n = 0;
          cmp = compare2(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
            n = mathfloor(rem0 / yc0);
            if (n > 1) {
              if (n >= base) n = base - 1;
              prod = multiply(yc, n, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n == 0) {
                cmp = n = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL) prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc, rem, yL, remL) < 1) {
                n++;
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          }
          qc[i++] = n;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);
        more = rem[0] != null;
        if (!qc[0]) qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e;
        q.r = +more;
      }
      return q;
    };
  }();
  function format(n, i, rm, id) {
    var c0, e, ne, len, str;
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    if (!n.c) return n.toString();
    c0 = n.c[0];
    ne = n.e;
    if (i == null) {
      str = coeffToString(n.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n = round(new BigNumber2(n), i, rm);
      e = n.e;
      str = coeffToString(n.c);
      len = str.length;
      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
        for (; len < i; str += "0", len++) ;
        str = toExponential(str, e);
      } else {
        i -= ne;
        str = toFixedPoint(str, e, "0");
        if (e + 1 > len) {
          if (--i > 0) for (str += "."; i--; str += "0") ;
        } else {
          i += e - len;
          if (i > 0) {
            if (e + 1 == len) str += ".";
            for (; i--; str += "0") ;
          }
        }
      }
    }
    return n.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, n) {
    var k, y, i = 1, x = new BigNumber2(args[0]);
    for (; i < args.length; i++) {
      y = new BigNumber2(args[i]);
      if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
        x = y;
      }
    }
    return x;
  }
  function normalise(n, c, e) {
    var i = 1, j = c.length;
    for (; !c[--j]; c.pop()) ;
    for (j = c[0]; j >= 10; j /= 10, i++) ;
    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
      n.c = n.e = null;
    } else if (e < MIN_EXP) {
      n.c = [n.e = 0];
    } else {
      n.e = e;
      n.c = c;
    }
    return n;
  }
  parseNumeric = /* @__PURE__ */ function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x, str, isNum, b) {
      var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s = s.replace(basePrefix, function(m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b || b == base ? p1 : m;
          });
          if (b) {
            base = b;
            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s) return new BigNumber2(s, base);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
        }
        x.s = null;
      }
      x.c = x.e = null;
    };
  }();
  function round(x, sd, rm, r) {
    var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
        i = sd - d;
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n = xc[ni = 0];
          rd = mathfloor(n / pows10[d - j - 1] % 10);
        } else {
          ni = mathceil((i + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r) {
              for (; xc.length <= ni; xc.push(0)) ;
              n = rd = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k = xc[ni];
            for (d = 1; k >= 10; k /= 10, d++) ;
            i %= LOG_BASE;
            j = i - LOG_BASE + d;
            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
          }
        }
        r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r) {
            sd -= x.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {
            xc[0] = x.e = 0;
          }
          return x;
        }
        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i];
          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
        }
        if (r) {
          for (; ; ) {
            if (ni == 0) {
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++) ;
              if (i != k) {
                x.e++;
                if (xc[0] == BASE) xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE) break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }
        for (i = xc.length; xc[--i] === 0; xc.pop()) ;
      }
      if (x.e > MAX_EXP) {
        x.c = x.e = null;
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }
    return x;
  }
  function valueOf(n) {
    var str, e = n.e;
    if (e === null) return n.toString();
    str = coeffToString(n.c);
    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
    return n.s < 0 ? "-" + str : str;
  }
  P.absoluteValue = P.abs = function() {
    var x = new BigNumber2(this);
    if (x.s < 0) x.s = 1;
    return x;
  };
  P.comparedTo = function(y, b) {
    return compare(this, new BigNumber2(y, b));
  };
  P.decimalPlaces = P.dp = function(dp, rm) {
    var c, n, v, x = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(new BigNumber2(x), dp + x.e + 1, rm);
    }
    if (!(c = x.c)) return null;
    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
    if (n < 0) n = 0;
    return n;
  };
  P.dividedBy = P.div = function(y, b) {
    return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P.dividedToIntegerBy = P.idiv = function(y, b) {
    return div(this, new BigNumber2(y, b), 0, 1);
  };
  P.exponentiatedBy = P.pow = function(n, m) {
    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
    n = new BigNumber2(n);
    if (n.c && !n.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
    }
    if (m != null) m = new BigNumber2(m);
    nIsBig = n.e > 14;
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
      y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
      return m ? y.mod(m) : y;
    }
    nIsNeg = n.s < 0;
    if (m) {
      if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
      isModExp = !nIsNeg && x.isInteger() && m.isInteger();
      if (isModExp) x = x.mod(m);
    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
      k = x.s < 0 && isOdd(n) ? -0 : 0;
      if (x.e > -1) k = 1 / k;
      return new BigNumber2(nIsNeg ? 1 / k : k);
    } else if (POW_PRECISION) {
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg) n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }
    y = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y = y.times(x);
        if (!y.c) break;
        if (k) {
          if (y.c.length > k) y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m);
        }
      }
      if (i) {
        i = mathfloor(i / 2);
        if (i === 0) break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round(n, n.e + 1, 1);
        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0) break;
          nIsOdd = i % 2;
        }
      }
      x = x.times(x);
      if (k) {
        if (x.c && x.c.length > k) x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m);
      }
    }
    if (isModExp) return y;
    if (nIsNeg) y = ONE.div(y);
    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };
  P.integerValue = function(rm) {
    var n = new BigNumber2(this);
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    return round(n, n.e + 1, rm);
  };
  P.isEqualTo = P.eq = function(y, b) {
    return compare(this, new BigNumber2(y, b)) === 0;
  };
  P.isFinite = function() {
    return !!this.c;
  };
  P.isGreaterThan = P.gt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) > 0;
  };
  P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
  };
  P.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P.isLessThan = P.lt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) < 0;
  };
  P.isLessThanOrEqualTo = P.lte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
  };
  P.isNaN = function() {
    return !this.s;
  };
  P.isNegative = function() {
    return this.s < 0;
  };
  P.isPositive = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P.minus = function(y, b) {
    var i, j, t, xLTy, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b) return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b = a; b--; t.push(0)) ;
      t.reverse();
    } else {
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    }
    if (xLTy) {
      t = xc;
      xc = yc;
      yc = t;
      y.s = -y.s;
    }
    b = (j = yc.length) - (i = xc.length);
    if (b > 0) for (; b--; xc[i++] = 0) ;
    b = BASE - 1;
    for (; j > a; ) {
      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; xc[i] = b) ;
        --xc[i];
        xc[j] += BASE;
      }
      xc[j] -= yc[j];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
    if (!xc[0]) {
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }
    return normalise(y, xc, ye);
  };
  P.modulo = P.mod = function(y, b) {
    var q, s, x = this;
    y = new BigNumber2(y, b);
    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber2(x);
    }
    if (MODULO_MODE == 9) {
      s = y.s;
      y.s = 1;
      q = div(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x, y, 0, MODULO_MODE);
    }
    y = x.minus(q.times(y));
    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
    return y;
  };
  P.multipliedBy = P.times = function(y, b) {
    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s;
        if (!xc || !yc) {
          y.c = y.e = null;
        } else {
          y.c = [0];
          y.e = 0;
        }
      }
      return y;
    }
    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i = xcL;
      xcL = ycL;
      ycL = i;
    }
    for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i = ycL; --i >= 0; ) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;
      for (k = xcL, j = i + k; j > i; ) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }
      zc[j] = c;
    }
    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y, zc, e);
  };
  P.negated = function() {
    var x = new BigNumber2(this);
    x.s = -x.s || null;
    return x;
  };
  P.plus = function(y, b) {
    var t, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b) return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.minus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc) return new BigNumber2(a / 0);
      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }
      t.reverse();
      for (; a--; t.push(0)) ;
      t.reverse();
    }
    a = xc.length;
    b = yc.length;
    if (a - b < 0) {
      t = yc;
      yc = xc;
      xc = t;
      b = a;
    }
    for (a = 0; b; ) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }
    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }
    return normalise(y, xc, ye);
  };
  P.precision = P.sd = function(sd, rm) {
    var c, n, v, x = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(new BigNumber2(x), sd, rm);
    }
    if (!(c = x.c)) return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;
    if (v = c[v]) {
      for (; v % 10 == 0; v /= 10, n--) ;
      for (v = c[0]; v >= 10; v /= 10, n++) ;
    }
    if (sd && x.e + 1 > n) n = x.e + 1;
    return n;
  };
  P.shiftedBy = function(k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k);
  };
  P.squareRoot = P.sqrt = function() {
    var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }
    s = Math.sqrt(+valueOf(x));
    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e) % 2 == 0) n += "0";
      s = Math.sqrt(+n);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new BigNumber2(n);
    } else {
      r = new BigNumber2(s + "");
    }
    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3) s = 0;
      for (; ; ) {
        t = r;
        r = half.times(t.plus(div(x, t, dp, 1)));
        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
          if (r.e < e) --s;
          n = n.slice(s - 3, s + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }
            dp += 4;
            s += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x);
            }
            break;
          }
        }
      }
    }
    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };
  P.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P.toFormat = function(dp, rm, format2) {
    var str, x = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x.toFixed(dp, rm);
    if (x.c) {
      var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2) {
        i = g1;
        g1 = g2;
        g2 = i;
        len -= i;
      }
      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
        if (isNeg) intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g2 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P.toFraction = function(md) {
    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
    if (md != null) {
      n = new BigNumber2(md);
      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
      }
    }
    if (!xc) return new BigNumber2(x);
    d = new BigNumber2(ONE);
    n1 = d0 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s = coeffToString(xc);
    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber2(s);
    n0.c[0] = 0;
    for (; ; ) {
      q = div(n, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1) break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n.minus(q.times(d2 = d));
      n = d2;
    }
    d2 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2;
    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
      div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r;
  };
  P.toNumber = function() {
    return +valueOf(this);
  };
  P.toPrecision = function(sd, rm) {
    if (sd != null) intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P.toString = function(b) {
    var str, n = this, s = n.s, e = n.e;
    if (e === null) {
      if (s) {
        str = "Infinity";
        if (s < 0) str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
      } else if (b === 10 && alphabetHasNormalDecimalDigits) {
        n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n.c), n.e, "0");
      } else {
        intCheck(b, 2, ALPHABET.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
      }
      if (s < 0 && n.c[0]) str = "-" + str;
    }
    return str;
  };
  P.valueOf = P.toJSON = function() {
    return valueOf(this);
  };
  P._isBigNumber = true;
  P[Symbol.toStringTag] = "BigNumber";
  P[Symbol.for("nodejs.util.inspect.custom")] = P.valueOf;
  if (configObject != null) BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
}
function coeffToString(a) {
  var s, z, i = 1, j = a.length, r = a[0] + "";
  for (; i < j; ) {
    s = a[i++] + "";
    z = LOG_BASE - s.length;
    for (; z--; s = "0" + s) ;
    r += s;
  }
  for (j = r.length; r.charCodeAt(--j) === 48; ) ;
  return r.slice(0, j + 1 || 1);
}
function compare(x, y) {
  var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
  if (!i || !j) return null;
  a = xc && !xc[0];
  b = yc && !yc[0];
  if (a || b) return a ? b ? 0 : -j : i;
  if (i != j) return i;
  a = i < 0;
  b = k == l;
  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
  if (!b) return k > l ^ a ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
  return k == l ? 0 : k > l ^ a ? 1 : -1;
}
function intCheck(n, min, max, name) {
  if (n < min || n > max || n !== mathfloor(n)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
  }
}
function isOdd(n) {
  var k = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}
function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
}
function toFixedPoint(str, e, z) {
  var len, zs;
  if (e < 0) {
    for (zs = z + "."; ++e; zs += z) ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e > len) {
      for (zs = z, e -= len; --e; zs += z) ;
      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + "." + str.slice(e);
    }
  }
  return str;
}
var BigNumber = clone();
var SplayTreeNode = class {
  constructor(key) {
    __publicField(this, "key");
    __publicField(this, "left", null);
    __publicField(this, "right", null);
    this.key = key;
  }
};
var SplayTreeSetNode = class extends SplayTreeNode {
  constructor(key) {
    super(key);
  }
};
var SplayTree = class {
  constructor() {
    __publicField(this, "size", 0);
    __publicField(this, "modificationCount", 0);
    __publicField(this, "splayCount", 0);
  }
  splay(key) {
    const root = this.root;
    if (root == null) {
      this.compare(key, key);
      return -1;
    }
    let right = null;
    let newTreeRight = null;
    let left = null;
    let newTreeLeft = null;
    let current = root;
    const compare2 = this.compare;
    let comp;
    while (true) {
      comp = compare2(current.key, key);
      if (comp > 0) {
        let currentLeft = current.left;
        if (currentLeft == null) break;
        comp = compare2(currentLeft.key, key);
        if (comp > 0) {
          current.left = currentLeft.right;
          currentLeft.right = current;
          current = currentLeft;
          currentLeft = current.left;
          if (currentLeft == null) break;
        }
        if (right == null) {
          newTreeRight = current;
        } else {
          right.left = current;
        }
        right = current;
        current = currentLeft;
      } else if (comp < 0) {
        let currentRight = current.right;
        if (currentRight == null) break;
        comp = compare2(currentRight.key, key);
        if (comp < 0) {
          current.right = currentRight.left;
          currentRight.left = current;
          current = currentRight;
          currentRight = current.right;
          if (currentRight == null) break;
        }
        if (left == null) {
          newTreeLeft = current;
        } else {
          left.right = current;
        }
        left = current;
        current = currentRight;
      } else {
        break;
      }
    }
    if (left != null) {
      left.right = current.left;
      current.left = newTreeLeft;
    }
    if (right != null) {
      right.left = current.right;
      current.right = newTreeRight;
    }
    if (this.root !== current) {
      this.root = current;
      this.splayCount++;
    }
    return comp;
  }
  splayMin(node) {
    let current = node;
    let nextLeft = current.left;
    while (nextLeft != null) {
      const left = nextLeft;
      current.left = left.right;
      left.right = current;
      current = left;
      nextLeft = current.left;
    }
    return current;
  }
  splayMax(node) {
    let current = node;
    let nextRight = current.right;
    while (nextRight != null) {
      const right = nextRight;
      current.right = right.left;
      right.left = current;
      current = right;
      nextRight = current.right;
    }
    return current;
  }
  _delete(key) {
    if (this.root == null) return null;
    const comp = this.splay(key);
    if (comp != 0) return null;
    let root = this.root;
    const result = root;
    const left = root.left;
    this.size--;
    if (left == null) {
      this.root = root.right;
    } else {
      const right = root.right;
      root = this.splayMax(left);
      root.right = right;
      this.root = root;
    }
    this.modificationCount++;
    return result;
  }
  addNewRoot(node, comp) {
    this.size++;
    this.modificationCount++;
    const root = this.root;
    if (root == null) {
      this.root = node;
      return;
    }
    if (comp < 0) {
      node.left = root;
      node.right = root.right;
      root.right = null;
    } else {
      node.right = root;
      node.left = root.left;
      root.left = null;
    }
    this.root = node;
  }
  _first() {
    const root = this.root;
    if (root == null) return null;
    this.root = this.splayMin(root);
    return this.root;
  }
  _last() {
    const root = this.root;
    if (root == null) return null;
    this.root = this.splayMax(root);
    return this.root;
  }
  clear() {
    this.root = null;
    this.size = 0;
    this.modificationCount++;
  }
  has(key) {
    return this.validKey(key) && this.splay(key) == 0;
  }
  defaultCompare() {
    return (a, b) => a < b ? -1 : a > b ? 1 : 0;
  }
  wrap() {
    return {
      getRoot: () => {
        return this.root;
      },
      setRoot: (root) => {
        this.root = root;
      },
      getSize: () => {
        return this.size;
      },
      getModificationCount: () => {
        return this.modificationCount;
      },
      getSplayCount: () => {
        return this.splayCount;
      },
      setSplayCount: (count) => {
        this.splayCount = count;
      },
      splay: (key) => {
        return this.splay(key);
      },
      has: (key) => {
        return this.has(key);
      }
    };
  }
};
var SplayTreeSet = class _SplayTreeSet extends SplayTree {
  constructor(compare2, isValidKey) {
    super();
    __publicField(this, "root", null);
    __publicField(this, "compare");
    __publicField(this, "validKey");
    __publicField(this, _a, "[object Set]");
    this.compare = compare2 ?? this.defaultCompare();
    this.validKey = isValidKey ?? ((v) => v != null && v != void 0);
  }
  delete(element) {
    if (!this.validKey(element)) return false;
    return this._delete(element) != null;
  }
  deleteAll(elements) {
    for (const element of elements) {
      this.delete(element);
    }
  }
  forEach(f) {
    const nodes = this[Symbol.iterator]();
    let result;
    while (result = nodes.next(), !result.done) {
      f(result.value, result.value, this);
    }
  }
  add(element) {
    const compare2 = this.splay(element);
    if (compare2 != 0) this.addNewRoot(new SplayTreeSetNode(element), compare2);
    return this;
  }
  addAndReturn(element) {
    const compare2 = this.splay(element);
    if (compare2 != 0) this.addNewRoot(new SplayTreeSetNode(element), compare2);
    return this.root.key;
  }
  addAll(elements) {
    for (const element of elements) {
      this.add(element);
    }
  }
  isEmpty() {
    return this.root == null;
  }
  isNotEmpty() {
    return this.root != null;
  }
  single() {
    if (this.size == 0) throw "Bad state: No element";
    if (this.size > 1) throw "Bad state: Too many element";
    return this.root.key;
  }
  first() {
    if (this.size == 0) throw "Bad state: No element";
    return this._first().key;
  }
  last() {
    if (this.size == 0) throw "Bad state: No element";
    return this._last().key;
  }
  lastBefore(element) {
    if (element == null) throw "Invalid arguments(s)";
    if (this.root == null) return null;
    const comp = this.splay(element);
    if (comp < 0) return this.root.key;
    let node = this.root.left;
    if (node == null) return null;
    let nodeRight = node.right;
    while (nodeRight != null) {
      node = nodeRight;
      nodeRight = node.right;
    }
    return node.key;
  }
  firstAfter(element) {
    if (element == null) throw "Invalid arguments(s)";
    if (this.root == null) return null;
    const comp = this.splay(element);
    if (comp > 0) return this.root.key;
    let node = this.root.right;
    if (node == null) return null;
    let nodeLeft = node.left;
    while (nodeLeft != null) {
      node = nodeLeft;
      nodeLeft = node.left;
    }
    return node.key;
  }
  retainAll(elements) {
    const retainSet = new _SplayTreeSet(this.compare, this.validKey);
    const modificationCount = this.modificationCount;
    for (const object of elements) {
      if (modificationCount != this.modificationCount) {
        throw "Concurrent modification during iteration.";
      }
      if (this.validKey(object) && this.splay(object) == 0) {
        retainSet.add(this.root.key);
      }
    }
    if (retainSet.size != this.size) {
      this.root = retainSet.root;
      this.size = retainSet.size;
      this.modificationCount++;
    }
  }
  lookup(object) {
    if (!this.validKey(object)) return null;
    const comp = this.splay(object);
    if (comp != 0) return null;
    return this.root.key;
  }
  intersection(other) {
    const result = new _SplayTreeSet(this.compare, this.validKey);
    for (const element of this) {
      if (other.has(element)) result.add(element);
    }
    return result;
  }
  difference(other) {
    const result = new _SplayTreeSet(this.compare, this.validKey);
    for (const element of this) {
      if (!other.has(element)) result.add(element);
    }
    return result;
  }
  union(other) {
    const u2 = this.clone();
    u2.addAll(other);
    return u2;
  }
  clone() {
    const set2 = new _SplayTreeSet(this.compare, this.validKey);
    set2.size = this.size;
    set2.root = this.copyNode(this.root);
    return set2;
  }
  copyNode(node) {
    if (node == null) return null;
    function copyChildren(node2, dest) {
      let left;
      let right;
      do {
        left = node2.left;
        right = node2.right;
        if (left != null) {
          const newLeft = new SplayTreeSetNode(left.key);
          dest.left = newLeft;
          copyChildren(left, newLeft);
        }
        if (right != null) {
          const newRight = new SplayTreeSetNode(right.key);
          dest.right = newRight;
          node2 = right;
          dest = newRight;
        }
      } while (right != null);
    }
    const result = new SplayTreeSetNode(node.key);
    copyChildren(node, result);
    return result;
  }
  toSet() {
    return this.clone();
  }
  entries() {
    return new SplayTreeSetEntryIterableIterator(this.wrap());
  }
  keys() {
    return this[Symbol.iterator]();
  }
  values() {
    return this[Symbol.iterator]();
  }
  [(_b = Symbol.iterator, _a = Symbol.toStringTag, _b)]() {
    return new SplayTreeKeyIterableIterator(this.wrap());
  }
};
var SplayTreeIterableIterator = class {
  constructor(tree) {
    __publicField(this, "tree");
    __publicField(this, "path", new Array());
    __publicField(this, "modificationCount", null);
    __publicField(this, "splayCount");
    this.tree = tree;
    this.splayCount = tree.getSplayCount();
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    if (this.moveNext()) return { done: false, value: this.current() };
    return { done: true, value: null };
  }
  current() {
    if (!this.path.length) return null;
    const node = this.path[this.path.length - 1];
    return this.getValue(node);
  }
  rebuildPath(key) {
    this.path.splice(0, this.path.length);
    this.tree.splay(key);
    this.path.push(this.tree.getRoot());
    this.splayCount = this.tree.getSplayCount();
  }
  findLeftMostDescendent(node) {
    while (node != null) {
      this.path.push(node);
      node = node.left;
    }
  }
  moveNext() {
    if (this.modificationCount != this.tree.getModificationCount()) {
      if (this.modificationCount == null) {
        this.modificationCount = this.tree.getModificationCount();
        let node2 = this.tree.getRoot();
        while (node2 != null) {
          this.path.push(node2);
          node2 = node2.left;
        }
        return this.path.length > 0;
      }
      throw "Concurrent modification during iteration.";
    }
    if (!this.path.length) return false;
    if (this.splayCount != this.tree.getSplayCount()) {
      this.rebuildPath(this.path[this.path.length - 1].key);
    }
    let node = this.path[this.path.length - 1];
    let next = node.right;
    if (next != null) {
      while (next != null) {
        this.path.push(next);
        next = next.left;
      }
      return true;
    }
    this.path.pop();
    while (this.path.length && this.path[this.path.length - 1].right === node) {
      node = this.path.pop();
    }
    return this.path.length > 0;
  }
};
var SplayTreeKeyIterableIterator = class extends SplayTreeIterableIterator {
  getValue(node) {
    return node.key;
  }
};
var SplayTreeSetEntryIterableIterator = class extends SplayTreeIterableIterator {
  getValue(node) {
    return [node.key, node.key];
  }
};
var constant_default = (x) => {
  return () => {
    return x;
  };
};
var compare_default = (eps) => {
  const almostEqual = eps ? (a, b) => b.minus(a).abs().isLessThanOrEqualTo(eps) : constant_default(false);
  return (a, b) => {
    if (almostEqual(a, b)) return 0;
    return a.comparedTo(b);
  };
};
function orient_default(eps) {
  const almostCollinear = eps ? (area2, ax, ay, cx, cy) => area2.exponentiatedBy(2).isLessThanOrEqualTo(
    cx.minus(ax).exponentiatedBy(2).plus(cy.minus(ay).exponentiatedBy(2)).times(eps)
  ) : constant_default(false);
  return (a, b, c) => {
    const ax = a.x, ay = a.y, cx = c.x, cy = c.y;
    const area2 = ay.minus(cy).times(b.x.minus(cx)).minus(ax.minus(cx).times(b.y.minus(cy)));
    if (almostCollinear(area2, ax, ay, cx, cy)) return 0;
    return area2.comparedTo(0);
  };
}
var identity_default = (x) => {
  return x;
};
var snap_default = (eps) => {
  if (eps) {
    const xTree = new SplayTreeSet(compare_default(eps));
    const yTree = new SplayTreeSet(compare_default(eps));
    const snapCoord = (coord, tree) => {
      return tree.addAndReturn(coord);
    };
    const snap = (v) => {
      return {
        x: snapCoord(v.x, xTree),
        y: snapCoord(v.y, yTree)
      };
    };
    snap({ x: new BigNumber(0), y: new BigNumber(0) });
    return snap;
  }
  return identity_default;
};
var set = (eps) => {
  return {
    set: (eps2) => {
      precision = set(eps2);
    },
    reset: () => set(eps),
    compare: compare_default(eps),
    snap: snap_default(eps),
    orient: orient_default(eps)
  };
};
var precision = set();
var isInBbox = (bbox2, point2) => {
  return bbox2.ll.x.isLessThanOrEqualTo(point2.x) && point2.x.isLessThanOrEqualTo(bbox2.ur.x) && bbox2.ll.y.isLessThanOrEqualTo(point2.y) && point2.y.isLessThanOrEqualTo(bbox2.ur.y);
};
var getBboxOverlap = (b1, b2) => {
  if (b2.ur.x.isLessThan(b1.ll.x) || b1.ur.x.isLessThan(b2.ll.x) || b2.ur.y.isLessThan(b1.ll.y) || b1.ur.y.isLessThan(b2.ll.y))
    return null;
  const lowerX = b1.ll.x.isLessThan(b2.ll.x) ? b2.ll.x : b1.ll.x;
  const upperX = b1.ur.x.isLessThan(b2.ur.x) ? b1.ur.x : b2.ur.x;
  const lowerY = b1.ll.y.isLessThan(b2.ll.y) ? b2.ll.y : b1.ll.y;
  const upperY = b1.ur.y.isLessThan(b2.ur.y) ? b1.ur.y : b2.ur.y;
  return { ll: { x: lowerX, y: lowerY }, ur: { x: upperX, y: upperY } };
};
var crossProduct = (a, b) => a.x.times(b.y).minus(a.y.times(b.x));
var dotProduct = (a, b) => a.x.times(b.x).plus(a.y.times(b.y));
var length$1 = (v) => dotProduct(v, v).sqrt();
var sineOfAngle = (pShared, pBase, pAngle) => {
  const vBase = { x: pBase.x.minus(pShared.x), y: pBase.y.minus(pShared.y) };
  const vAngle = { x: pAngle.x.minus(pShared.x), y: pAngle.y.minus(pShared.y) };
  return crossProduct(vAngle, vBase).div(length$1(vAngle)).div(length$1(vBase));
};
var cosineOfAngle = (pShared, pBase, pAngle) => {
  const vBase = { x: pBase.x.minus(pShared.x), y: pBase.y.minus(pShared.y) };
  const vAngle = { x: pAngle.x.minus(pShared.x), y: pAngle.y.minus(pShared.y) };
  return dotProduct(vAngle, vBase).div(length$1(vAngle)).div(length$1(vBase));
};
var horizontalIntersection = (pt, v, y) => {
  if (v.y.isZero()) return null;
  return { x: pt.x.plus(v.x.div(v.y).times(y.minus(pt.y))), y };
};
var verticalIntersection = (pt, v, x) => {
  if (v.x.isZero()) return null;
  return { x, y: pt.y.plus(v.y.div(v.x).times(x.minus(pt.x))) };
};
var intersection = (pt1, v1, pt2, v2) => {
  if (v1.x.isZero()) return verticalIntersection(pt2, v2, pt1.x);
  if (v2.x.isZero()) return verticalIntersection(pt1, v1, pt2.x);
  if (v1.y.isZero()) return horizontalIntersection(pt2, v2, pt1.y);
  if (v2.y.isZero()) return horizontalIntersection(pt1, v1, pt2.y);
  const kross = crossProduct(v1, v2);
  if (kross.isZero()) return null;
  const ve = { x: pt2.x.minus(pt1.x), y: pt2.y.minus(pt1.y) };
  const d1 = crossProduct(ve, v1).div(kross);
  const d2 = crossProduct(ve, v2).div(kross);
  const x12 = pt1.x.plus(d2.times(v1.x)), x2 = pt2.x.plus(d1.times(v2.x));
  const y12 = pt1.y.plus(d2.times(v1.y)), y2 = pt2.y.plus(d1.times(v2.y));
  const x = x12.plus(x2).div(2);
  const y = y12.plus(y2).div(2);
  return { x, y };
};
var SweepEvent = class _SweepEvent {
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(point2, isLeft) {
    __publicField(this, "point");
    __publicField(this, "isLeft");
    __publicField(this, "segment");
    __publicField(this, "otherSE");
    __publicField(this, "consumedBy");
    if (point2.events === void 0) point2.events = [this];
    else point2.events.push(this);
    this.point = point2;
    this.isLeft = isLeft;
  }
  // for ordering sweep events in the sweep event queue
  static compare(a, b) {
    const ptCmp = _SweepEvent.comparePoints(a.point, b.point);
    if (ptCmp !== 0) return ptCmp;
    if (a.point !== b.point) a.link(b);
    if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;
    return Segment2.compare(a.segment, b.segment);
  }
  // for ordering points in sweep line order
  static comparePoints(aPt, bPt) {
    if (aPt.x.isLessThan(bPt.x)) return -1;
    if (aPt.x.isGreaterThan(bPt.x)) return 1;
    if (aPt.y.isLessThan(bPt.y)) return -1;
    if (aPt.y.isGreaterThan(bPt.y)) return 1;
    return 0;
  }
  link(other) {
    if (other.point === this.point) {
      throw new Error("Tried to link already linked events");
    }
    const otherEvents = other.point.events;
    for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {
      const evt = otherEvents[i];
      this.point.events.push(evt);
      evt.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const numEvents = this.point.events.length;
    for (let i = 0; i < numEvents; i++) {
      const evt1 = this.point.events[i];
      if (evt1.segment.consumedBy !== void 0) continue;
      for (let j = i + 1; j < numEvents; j++) {
        const evt2 = this.point.events[j];
        if (evt2.consumedBy !== void 0) continue;
        if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;
        evt1.segment.consume(evt2.segment);
      }
    }
  }
  getAvailableLinkedEvents() {
    const events = [];
    for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {
      const evt = this.point.events[i];
      if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
        events.push(evt);
      }
    }
    return events;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(baseEvent) {
    const cache = /* @__PURE__ */ new Map();
    const fillCache = (linkedEvent) => {
      const nextEvent = linkedEvent.otherSE;
      cache.set(linkedEvent, {
        sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),
        cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)
      });
    };
    return (a, b) => {
      if (!cache.has(a)) fillCache(a);
      if (!cache.has(b)) fillCache(b);
      const { sine: asine, cosine: acosine } = cache.get(a);
      const { sine: bsine, cosine: bcosine } = cache.get(b);
      if (asine.isGreaterThanOrEqualTo(0) && bsine.isGreaterThanOrEqualTo(0)) {
        if (acosine.isLessThan(bcosine)) return 1;
        if (acosine.isGreaterThan(bcosine)) return -1;
        return 0;
      }
      if (asine.isLessThan(0) && bsine.isLessThan(0)) {
        if (acosine.isLessThan(bcosine)) return -1;
        if (acosine.isGreaterThan(bcosine)) return 1;
        return 0;
      }
      if (bsine.isLessThan(asine)) return -1;
      if (bsine.isGreaterThan(asine)) return 1;
      return 0;
    };
  }
};
var RingOut = class _RingOut {
  constructor(events) {
    __publicField(this, "events");
    __publicField(this, "poly");
    __publicField(this, "_isExteriorRing");
    __publicField(this, "_enclosingRing");
    this.events = events;
    for (let i = 0, iMax = events.length; i < iMax; i++) {
      events[i].segment.ringOut = this;
    }
    this.poly = null;
  }
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(allSegments) {
    const ringsOut = [];
    for (let i = 0, iMax = allSegments.length; i < iMax; i++) {
      const segment = allSegments[i];
      if (!segment.isInResult() || segment.ringOut) continue;
      let prevEvent = null;
      let event = segment.leftSE;
      let nextEvent = segment.rightSE;
      const events = [event];
      const startingPoint = event.point;
      const intersectionLEs = [];
      while (true) {
        prevEvent = event;
        event = nextEvent;
        events.push(event);
        if (event.point === startingPoint) break;
        while (true) {
          const availableLEs = event.getAvailableLinkedEvents();
          if (availableLEs.length === 0) {
            const firstPt = events[0].point;
            const lastPt = events[events.length - 1].point;
            throw new Error(
              `Unable to complete output ring starting at [${firstPt.x}, ${firstPt.y}]. Last matching segment found ends at [${lastPt.x}, ${lastPt.y}].`
            );
          }
          if (availableLEs.length === 1) {
            nextEvent = availableLEs[0].otherSE;
            break;
          }
          let indexLE = null;
          for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
            if (intersectionLEs[j].point === event.point) {
              indexLE = j;
              break;
            }
          }
          if (indexLE !== null) {
            const intersectionLE = intersectionLEs.splice(indexLE)[0];
            const ringEvents = events.splice(intersectionLE.index);
            ringEvents.unshift(ringEvents[0].otherSE);
            ringsOut.push(new _RingOut(ringEvents.reverse()));
            continue;
          }
          intersectionLEs.push({
            index: events.length,
            point: event.point
          });
          const comparator = event.getLeftmostComparator(prevEvent);
          nextEvent = availableLEs.sort(comparator)[0].otherSE;
          break;
        }
      }
      ringsOut.push(new _RingOut(events));
    }
    return ringsOut;
  }
  getGeom() {
    let prevPt = this.events[0].point;
    const points = [prevPt];
    for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {
      const pt2 = this.events[i].point;
      const nextPt2 = this.events[i + 1].point;
      if (precision.orient(pt2, prevPt, nextPt2) === 0) continue;
      points.push(pt2);
      prevPt = pt2;
    }
    if (points.length === 1) return null;
    const pt = points[0];
    const nextPt = points[1];
    if (precision.orient(pt, prevPt, nextPt) === 0) points.shift();
    points.push(points[0]);
    const step = this.isExteriorRing() ? 1 : -1;
    const iStart = this.isExteriorRing() ? 0 : points.length - 1;
    const iEnd = this.isExteriorRing() ? points.length : -1;
    const orderedPoints = [];
    for (let i = iStart; i != iEnd; i += step)
      orderedPoints.push([points[i].x.toNumber(), points[i].y.toNumber()]);
    return orderedPoints;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const enclosing = this.enclosingRing();
      this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    if (this._enclosingRing === void 0) {
      this._enclosingRing = this._calcEnclosingRing();
    }
    return this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    var _a2, _b2;
    let leftMostEvt = this.events[0];
    for (let i = 1, iMax = this.events.length; i < iMax; i++) {
      const evt = this.events[i];
      if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;
    }
    let prevSeg = leftMostEvt.segment.prevInResult();
    let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
    while (true) {
      if (!prevSeg) return null;
      if (!prevPrevSeg) return prevSeg.ringOut;
      if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
        if (((_a2 = prevPrevSeg.ringOut) == null ? void 0 : _a2.enclosingRing()) !== prevSeg.ringOut) {
          return prevSeg.ringOut;
        } else return (_b2 = prevSeg.ringOut) == null ? void 0 : _b2.enclosingRing();
      }
      prevSeg = prevPrevSeg.prevInResult();
      prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
    }
  }
};
var PolyOut = class {
  constructor(exteriorRing) {
    __publicField(this, "exteriorRing");
    __publicField(this, "interiorRings");
    this.exteriorRing = exteriorRing;
    exteriorRing.poly = this;
    this.interiorRings = [];
  }
  addInterior(ring) {
    this.interiorRings.push(ring);
    ring.poly = this;
  }
  getGeom() {
    const geom0 = this.exteriorRing.getGeom();
    if (geom0 === null) return null;
    const geom = [geom0];
    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
      const ringGeom = this.interiorRings[i].getGeom();
      if (ringGeom === null) continue;
      geom.push(ringGeom);
    }
    return geom;
  }
};
var MultiPolyOut = class {
  constructor(rings) {
    __publicField(this, "rings");
    __publicField(this, "polys");
    this.rings = rings;
    this.polys = this._composePolys(rings);
  }
  getGeom() {
    const geom = [];
    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {
      const polyGeom = this.polys[i].getGeom();
      if (polyGeom === null) continue;
      geom.push(polyGeom);
    }
    return geom;
  }
  _composePolys(rings) {
    var _a2;
    const polys = [];
    for (let i = 0, iMax = rings.length; i < iMax; i++) {
      const ring = rings[i];
      if (ring.poly) continue;
      if (ring.isExteriorRing()) polys.push(new PolyOut(ring));
      else {
        const enclosingRing = ring.enclosingRing();
        if (!(enclosingRing == null ? void 0 : enclosingRing.poly)) polys.push(new PolyOut(enclosingRing));
        (_a2 = enclosingRing == null ? void 0 : enclosingRing.poly) == null ? void 0 : _a2.addInterior(ring);
      }
    }
    return polys;
  }
};
var SweepLine = class {
  constructor(queue, comparator = Segment2.compare) {
    __publicField(this, "queue");
    __publicField(this, "tree");
    __publicField(this, "segments");
    this.queue = queue;
    this.tree = new SplayTreeSet(comparator);
    this.segments = [];
  }
  process(event) {
    const segment = event.segment;
    const newEvents = [];
    if (event.consumedBy) {
      if (event.isLeft) this.queue.delete(event.otherSE);
      else this.tree.delete(segment);
      return newEvents;
    }
    if (event.isLeft) this.tree.add(segment);
    let prevSeg = segment;
    let nextSeg = segment;
    do {
      prevSeg = this.tree.lastBefore(prevSeg);
    } while (prevSeg != null && prevSeg.consumedBy != void 0);
    do {
      nextSeg = this.tree.firstAfter(nextSeg);
    } while (nextSeg != null && nextSeg.consumedBy != void 0);
    if (event.isLeft) {
      let prevMySplitter = null;
      if (prevSeg) {
        const prevInter = prevSeg.getIntersection(segment);
        if (prevInter !== null) {
          if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;
          if (!prevSeg.isAnEndpoint(prevInter)) {
            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
        }
      }
      let nextMySplitter = null;
      if (nextSeg) {
        const nextInter = nextSeg.getIntersection(segment);
        if (nextInter !== null) {
          if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;
          if (!nextSeg.isAnEndpoint(nextInter)) {
            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
        }
      }
      if (prevMySplitter !== null || nextMySplitter !== null) {
        let mySplitter = null;
        if (prevMySplitter === null) mySplitter = nextMySplitter;
        else if (nextMySplitter === null) mySplitter = prevMySplitter;
        else {
          const cmpSplitters = SweepEvent.comparePoints(
            prevMySplitter,
            nextMySplitter
          );
          mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
        }
        this.queue.delete(segment.rightSE);
        newEvents.push(segment.rightSE);
        const newEventsFromSplit = segment.split(mySplitter);
        for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
          newEvents.push(newEventsFromSplit[i]);
        }
      }
      if (newEvents.length > 0) {
        this.tree.delete(segment);
        newEvents.push(event);
      } else {
        this.segments.push(segment);
        segment.prev = prevSeg;
      }
    } else {
      if (prevSeg && nextSeg) {
        const inter = prevSeg.getIntersection(nextSeg);
        if (inter !== null) {
          if (!prevSeg.isAnEndpoint(inter)) {
            const newEventsFromSplit = this._splitSafely(prevSeg, inter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
          if (!nextSeg.isAnEndpoint(inter)) {
            const newEventsFromSplit = this._splitSafely(nextSeg, inter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
        }
      }
      this.tree.delete(segment);
    }
    return newEvents;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(seg, pt) {
    this.tree.delete(seg);
    const rightSE = seg.rightSE;
    this.queue.delete(rightSE);
    const newEvents = seg.split(pt);
    newEvents.push(rightSE);
    if (seg.consumedBy === void 0) this.tree.add(seg);
    return newEvents;
  }
};
var Operation = class {
  constructor() {
    __publicField(this, "type");
    __publicField(this, "numMultiPolys");
  }
  run(type, geom, moreGeoms) {
    operation.type = type;
    const multipolys = [new MultiPolyIn(geom, true)];
    for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {
      multipolys.push(new MultiPolyIn(moreGeoms[i], false));
    }
    operation.numMultiPolys = multipolys.length;
    if (operation.type === "difference") {
      const subject = multipolys[0];
      let i = 1;
      while (i < multipolys.length) {
        if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;
        else multipolys.splice(i, 1);
      }
    }
    if (operation.type === "intersection") {
      for (let i = 0, iMax = multipolys.length; i < iMax; i++) {
        const mpA = multipolys[i];
        for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {
          if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];
        }
      }
    }
    const queue = new SplayTreeSet(SweepEvent.compare);
    for (let i = 0, iMax = multipolys.length; i < iMax; i++) {
      const sweepEvents = multipolys[i].getSweepEvents();
      for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {
        queue.add(sweepEvents[j]);
      }
    }
    const sweepLine = new SweepLine(queue);
    let evt = null;
    if (queue.size != 0) {
      evt = queue.first();
      queue.delete(evt);
    }
    while (evt) {
      const newEvents = sweepLine.process(evt);
      for (let i = 0, iMax = newEvents.length; i < iMax; i++) {
        const evt2 = newEvents[i];
        if (evt2.consumedBy === void 0) queue.add(evt2);
      }
      if (queue.size != 0) {
        evt = queue.first();
        queue.delete(evt);
      } else {
        evt = null;
      }
    }
    precision.reset();
    const ringsOut = RingOut.factory(sweepLine.segments);
    const result = new MultiPolyOut(ringsOut);
    return result.getGeom();
  }
};
var operation = new Operation();
var operation_default = operation;
var segmentId = 0;
var Segment2 = class _Segment {
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(leftSE, rightSE, rings, windings) {
    __publicField(this, "id");
    __publicField(this, "leftSE");
    __publicField(this, "rightSE");
    __publicField(this, "rings");
    __publicField(this, "windings");
    __publicField(this, "ringOut");
    __publicField(this, "consumedBy");
    __publicField(this, "prev");
    __publicField(this, "_prevInResult");
    __publicField(this, "_beforeState");
    __publicField(this, "_afterState");
    __publicField(this, "_isInResult");
    this.id = ++segmentId;
    this.leftSE = leftSE;
    leftSE.segment = this;
    leftSE.otherSE = rightSE;
    this.rightSE = rightSE;
    rightSE.segment = this;
    rightSE.otherSE = leftSE;
    this.rings = rings;
    this.windings = windings;
  }
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(a, b) {
    const alx = a.leftSE.point.x;
    const blx = b.leftSE.point.x;
    const arx = a.rightSE.point.x;
    const brx = b.rightSE.point.x;
    if (brx.isLessThan(alx)) return 1;
    if (arx.isLessThan(blx)) return -1;
    const aly = a.leftSE.point.y;
    const bly = b.leftSE.point.y;
    const ary = a.rightSE.point.y;
    const bry = b.rightSE.point.y;
    if (alx.isLessThan(blx)) {
      if (bly.isLessThan(aly) && bly.isLessThan(ary)) return 1;
      if (bly.isGreaterThan(aly) && bly.isGreaterThan(ary)) return -1;
      const aCmpBLeft = a.comparePoint(b.leftSE.point);
      if (aCmpBLeft < 0) return 1;
      if (aCmpBLeft > 0) return -1;
      const bCmpARight = b.comparePoint(a.rightSE.point);
      if (bCmpARight !== 0) return bCmpARight;
      return -1;
    }
    if (alx.isGreaterThan(blx)) {
      if (aly.isLessThan(bly) && aly.isLessThan(bry)) return -1;
      if (aly.isGreaterThan(bly) && aly.isGreaterThan(bry)) return 1;
      const bCmpALeft = b.comparePoint(a.leftSE.point);
      if (bCmpALeft !== 0) return bCmpALeft;
      const aCmpBRight = a.comparePoint(b.rightSE.point);
      if (aCmpBRight < 0) return 1;
      if (aCmpBRight > 0) return -1;
      return 1;
    }
    if (aly.isLessThan(bly)) return -1;
    if (aly.isGreaterThan(bly)) return 1;
    if (arx.isLessThan(brx)) {
      const bCmpARight = b.comparePoint(a.rightSE.point);
      if (bCmpARight !== 0) return bCmpARight;
    }
    if (arx.isGreaterThan(brx)) {
      const aCmpBRight = a.comparePoint(b.rightSE.point);
      if (aCmpBRight < 0) return 1;
      if (aCmpBRight > 0) return -1;
    }
    if (!arx.eq(brx)) {
      const ay = ary.minus(aly);
      const ax = arx.minus(alx);
      const by = bry.minus(bly);
      const bx = brx.minus(blx);
      if (ay.isGreaterThan(ax) && by.isLessThan(bx)) return 1;
      if (ay.isLessThan(ax) && by.isGreaterThan(bx)) return -1;
    }
    if (arx.isGreaterThan(brx)) return 1;
    if (arx.isLessThan(brx)) return -1;
    if (ary.isLessThan(bry)) return -1;
    if (ary.isGreaterThan(bry)) return 1;
    if (a.id < b.id) return -1;
    if (a.id > b.id) return 1;
    return 0;
  }
  static fromRing(pt1, pt2, ring) {
    let leftPt, rightPt, winding;
    const cmpPts = SweepEvent.comparePoints(pt1, pt2);
    if (cmpPts < 0) {
      leftPt = pt1;
      rightPt = pt2;
      winding = 1;
    } else if (cmpPts > 0) {
      leftPt = pt2;
      rightPt = pt1;
      winding = -1;
    } else
      throw new Error(
        `Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`
      );
    const leftSE = new SweepEvent(leftPt, true);
    const rightSE = new SweepEvent(rightPt, false);
    return new _Segment(leftSE, rightSE, [ring], [winding]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(newRightSE) {
    this.rightSE = newRightSE;
    this.rightSE.segment = this;
    this.rightSE.otherSE = this.leftSE;
    this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const y12 = this.leftSE.point.y;
    const y2 = this.rightSE.point.y;
    return {
      ll: { x: this.leftSE.point.x, y: y12.isLessThan(y2) ? y12 : y2 },
      ur: { x: this.rightSE.point.x, y: y12.isGreaterThan(y2) ? y12 : y2 }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x.minus(this.leftSE.point.x),
      y: this.rightSE.point.y.minus(this.leftSE.point.y)
    };
  }
  isAnEndpoint(pt) {
    return pt.x.eq(this.leftSE.point.x) && pt.y.eq(this.leftSE.point.y) || pt.x.eq(this.rightSE.point.x) && pt.y.eq(this.rightSE.point.y);
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(point2) {
    return precision.orient(this.leftSE.point, point2, this.rightSE.point);
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(other) {
    const tBbox = this.bbox();
    const oBbox = other.bbox();
    const bboxOverlap = getBboxOverlap(tBbox, oBbox);
    if (bboxOverlap === null) return null;
    const tlp = this.leftSE.point;
    const trp = this.rightSE.point;
    const olp = other.leftSE.point;
    const orp = other.rightSE.point;
    const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
    const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
    const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
    const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
    if (touchesThisLSE && touchesOtherLSE) {
      if (touchesThisRSE && !touchesOtherRSE) return trp;
      if (!touchesThisRSE && touchesOtherRSE) return orp;
      return null;
    }
    if (touchesThisLSE) {
      if (touchesOtherRSE) {
        if (tlp.x.eq(orp.x) && tlp.y.eq(orp.y)) return null;
      }
      return tlp;
    }
    if (touchesOtherLSE) {
      if (touchesThisRSE) {
        if (trp.x.eq(olp.x) && trp.y.eq(olp.y)) return null;
      }
      return olp;
    }
    if (touchesThisRSE && touchesOtherRSE) return null;
    if (touchesThisRSE) return trp;
    if (touchesOtherRSE) return orp;
    const pt = intersection(tlp, this.vector(), olp, other.vector());
    if (pt === null) return null;
    if (!isInBbox(bboxOverlap, pt)) return null;
    return precision.snap(pt);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(point2) {
    const newEvents = [];
    const alreadyLinked = point2.events !== void 0;
    const newLeftSE = new SweepEvent(point2, true);
    const newRightSE = new SweepEvent(point2, false);
    const oldRightSE = this.rightSE;
    this.replaceRightSE(newRightSE);
    newEvents.push(newRightSE);
    newEvents.push(newLeftSE);
    const newSeg = new _Segment(
      newLeftSE,
      oldRightSE,
      this.rings.slice(),
      this.windings.slice()
    );
    if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
      newSeg.swapEvents();
    }
    if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
      this.swapEvents();
    }
    if (alreadyLinked) {
      newLeftSE.checkForConsuming();
      newRightSE.checkForConsuming();
    }
    return newEvents;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const tmpEvt = this.rightSE;
    this.rightSE = this.leftSE;
    this.leftSE = tmpEvt;
    this.leftSE.isLeft = true;
    this.rightSE.isLeft = false;
    for (let i = 0, iMax = this.windings.length; i < iMax; i++) {
      this.windings[i] *= -1;
    }
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(other) {
    let consumer = this;
    let consumee = other;
    while (consumer.consumedBy) consumer = consumer.consumedBy;
    while (consumee.consumedBy) consumee = consumee.consumedBy;
    const cmp = _Segment.compare(consumer, consumee);
    if (cmp === 0) return;
    if (cmp > 0) {
      const tmp = consumer;
      consumer = consumee;
      consumee = tmp;
    }
    if (consumer.prev === consumee) {
      const tmp = consumer;
      consumer = consumee;
      consumee = tmp;
    }
    for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {
      const ring = consumee.rings[i];
      const winding = consumee.windings[i];
      const index = consumer.rings.indexOf(ring);
      if (index === -1) {
        consumer.rings.push(ring);
        consumer.windings.push(winding);
      } else consumer.windings[index] += winding;
    }
    consumee.rings = null;
    consumee.windings = null;
    consumee.consumedBy = consumer;
    consumee.leftSE.consumedBy = consumer.leftSE;
    consumee.rightSE.consumedBy = consumer.rightSE;
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    if (this._prevInResult !== void 0) return this._prevInResult;
    if (!this.prev) this._prevInResult = null;
    else if (this.prev.isInResult()) this._prevInResult = this.prev;
    else this._prevInResult = this.prev.prevInResult();
    return this._prevInResult;
  }
  beforeState() {
    if (this._beforeState !== void 0) return this._beforeState;
    if (!this.prev)
      this._beforeState = {
        rings: [],
        windings: [],
        multiPolys: []
      };
    else {
      const seg = this.prev.consumedBy || this.prev;
      this._beforeState = seg.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0) return this._afterState;
    const beforeState = this.beforeState();
    this._afterState = {
      rings: beforeState.rings.slice(0),
      windings: beforeState.windings.slice(0),
      multiPolys: []
    };
    const ringsAfter = this._afterState.rings;
    const windingsAfter = this._afterState.windings;
    const mpsAfter = this._afterState.multiPolys;
    for (let i = 0, iMax = this.rings.length; i < iMax; i++) {
      const ring = this.rings[i];
      const winding = this.windings[i];
      const index = ringsAfter.indexOf(ring);
      if (index === -1) {
        ringsAfter.push(ring);
        windingsAfter.push(winding);
      } else windingsAfter[index] += winding;
    }
    const polysAfter = [];
    const polysExclude = [];
    for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {
      if (windingsAfter[i] === 0) continue;
      const ring = ringsAfter[i];
      const poly = ring.poly;
      if (polysExclude.indexOf(poly) !== -1) continue;
      if (ring.isExterior) polysAfter.push(poly);
      else {
        if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);
        const index = polysAfter.indexOf(ring.poly);
        if (index !== -1) polysAfter.splice(index, 1);
      }
    }
    for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {
      const mp = polysAfter[i].multiPoly;
      if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy) return false;
    if (this._isInResult !== void 0) return this._isInResult;
    const mpsBefore = this.beforeState().multiPolys;
    const mpsAfter = this.afterState().multiPolys;
    switch (operation_default.type) {
      case "union": {
        const noBefores = mpsBefore.length === 0;
        const noAfters = mpsAfter.length === 0;
        this._isInResult = noBefores !== noAfters;
        break;
      }
      case "intersection": {
        let least;
        let most;
        if (mpsBefore.length < mpsAfter.length) {
          least = mpsBefore.length;
          most = mpsAfter.length;
        } else {
          least = mpsAfter.length;
          most = mpsBefore.length;
        }
        this._isInResult = most === operation_default.numMultiPolys && least < most;
        break;
      }
      case "xor": {
        const diff = Math.abs(mpsBefore.length - mpsAfter.length);
        this._isInResult = diff % 2 === 1;
        break;
      }
      case "difference": {
        const isJustSubject = (mps) => mps.length === 1 && mps[0].isSubject;
        this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
        break;
      }
    }
    return this._isInResult;
  }
};
var RingIn = class {
  constructor(geomRing, poly, isExterior) {
    __publicField(this, "poly");
    __publicField(this, "isExterior");
    __publicField(this, "segments");
    __publicField(this, "bbox");
    if (!Array.isArray(geomRing) || geomRing.length === 0) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    this.poly = poly;
    this.isExterior = isExterior;
    this.segments = [];
    if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    const firstPoint = precision.snap({ x: new BigNumber(geomRing[0][0]), y: new BigNumber(geomRing[0][1]) });
    this.bbox = {
      ll: { x: firstPoint.x, y: firstPoint.y },
      ur: { x: firstPoint.x, y: firstPoint.y }
    };
    let prevPoint = firstPoint;
    for (let i = 1, iMax = geomRing.length; i < iMax; i++) {
      if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      }
      const point2 = precision.snap({ x: new BigNumber(geomRing[i][0]), y: new BigNumber(geomRing[i][1]) });
      if (point2.x.eq(prevPoint.x) && point2.y.eq(prevPoint.y)) continue;
      this.segments.push(Segment2.fromRing(prevPoint, point2, this));
      if (point2.x.isLessThan(this.bbox.ll.x)) this.bbox.ll.x = point2.x;
      if (point2.y.isLessThan(this.bbox.ll.y)) this.bbox.ll.y = point2.y;
      if (point2.x.isGreaterThan(this.bbox.ur.x)) this.bbox.ur.x = point2.x;
      if (point2.y.isGreaterThan(this.bbox.ur.y)) this.bbox.ur.y = point2.y;
      prevPoint = point2;
    }
    if (!firstPoint.x.eq(prevPoint.x) || !firstPoint.y.eq(prevPoint.y)) {
      this.segments.push(Segment2.fromRing(prevPoint, firstPoint, this));
    }
  }
  getSweepEvents() {
    const sweepEvents = [];
    for (let i = 0, iMax = this.segments.length; i < iMax; i++) {
      const segment = this.segments[i];
      sweepEvents.push(segment.leftSE);
      sweepEvents.push(segment.rightSE);
    }
    return sweepEvents;
  }
};
var PolyIn = class {
  constructor(geomPoly, multiPoly) {
    __publicField(this, "multiPoly");
    __publicField(this, "exteriorRing");
    __publicField(this, "interiorRings");
    __publicField(this, "bbox");
    if (!Array.isArray(geomPoly)) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    this.exteriorRing = new RingIn(geomPoly[0], this, true);
    this.bbox = {
      ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y },
      ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y }
    };
    this.interiorRings = [];
    for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {
      const ring = new RingIn(geomPoly[i], this, false);
      if (ring.bbox.ll.x.isLessThan(this.bbox.ll.x)) this.bbox.ll.x = ring.bbox.ll.x;
      if (ring.bbox.ll.y.isLessThan(this.bbox.ll.y)) this.bbox.ll.y = ring.bbox.ll.y;
      if (ring.bbox.ur.x.isGreaterThan(this.bbox.ur.x)) this.bbox.ur.x = ring.bbox.ur.x;
      if (ring.bbox.ur.y.isGreaterThan(this.bbox.ur.y)) this.bbox.ur.y = ring.bbox.ur.y;
      this.interiorRings.push(ring);
    }
    this.multiPoly = multiPoly;
  }
  getSweepEvents() {
    const sweepEvents = this.exteriorRing.getSweepEvents();
    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
      const ringSweepEvents = this.interiorRings[i].getSweepEvents();
      for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
        sweepEvents.push(ringSweepEvents[j]);
      }
    }
    return sweepEvents;
  }
};
var MultiPolyIn = class {
  constructor(geom, isSubject) {
    __publicField(this, "isSubject");
    __publicField(this, "polys");
    __publicField(this, "bbox");
    if (!Array.isArray(geom)) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    try {
      if (typeof geom[0][0][0] === "number") geom = [geom];
    } catch (ex) {
    }
    this.polys = [];
    this.bbox = {
      ll: { x: new BigNumber(Number.POSITIVE_INFINITY), y: new BigNumber(Number.POSITIVE_INFINITY) },
      ur: { x: new BigNumber(Number.NEGATIVE_INFINITY), y: new BigNumber(Number.NEGATIVE_INFINITY) }
    };
    for (let i = 0, iMax = geom.length; i < iMax; i++) {
      const poly = new PolyIn(geom[i], this);
      if (poly.bbox.ll.x.isLessThan(this.bbox.ll.x)) this.bbox.ll.x = poly.bbox.ll.x;
      if (poly.bbox.ll.y.isLessThan(this.bbox.ll.y)) this.bbox.ll.y = poly.bbox.ll.y;
      if (poly.bbox.ur.x.isGreaterThan(this.bbox.ur.x)) this.bbox.ur.x = poly.bbox.ur.x;
      if (poly.bbox.ur.y.isGreaterThan(this.bbox.ur.y)) this.bbox.ur.y = poly.bbox.ur.y;
      this.polys.push(poly);
    }
    this.isSubject = isSubject;
  }
  getSweepEvents() {
    const sweepEvents = [];
    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {
      const polySweepEvents = this.polys[i].getSweepEvents();
      for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
        sweepEvents.push(polySweepEvents[j]);
      }
    }
    return sweepEvents;
  }
};
var union = (geom, ...moreGeoms) => operation_default.run("union", geom, moreGeoms);
var intersection2 = (geom, ...moreGeoms) => operation_default.run("intersection", geom, moreGeoms);
var difference = (geom, ...moreGeoms) => operation_default.run("difference", geom, moreGeoms);
precision.set;
function difference2(features) {
  const geoms = [];
  geomEach(features, (geom) => {
    geoms.push(geom.coordinates);
  });
  if (geoms.length < 2) {
    throw new Error("Must have at least two features");
  }
  const properties = features.features[0].properties || {};
  const differenced = difference(geoms[0], ...geoms.slice(1));
  if (differenced.length === 0) return null;
  if (differenced.length === 1) return polygon(differenced[0], properties);
  return multiPolygon(differenced, properties);
}
function explode(geojson) {
  const points = [];
  if (geojson.type === "FeatureCollection") {
    featureEach(geojson, function(feature2) {
      coordEach(feature2, function(coord) {
        points.push(point(coord, feature2.properties));
      });
    });
  } else if (geojson.type === "Feature") {
    coordEach(geojson, function(coord) {
      points.push(point(coord, geojson.properties));
    });
  } else {
    coordEach(geojson, function(coord) {
      points.push(point(coord));
    });
  }
  return featureCollection(points);
}
function intersect$1(features, options = {}) {
  const geoms = [];
  geomEach(features, (geom) => {
    geoms.push(geom.coordinates);
  });
  if (geoms.length < 2) {
    throw new Error("Must specify at least 2 geometries");
  }
  const intersection2$1 = intersection2(geoms[0], ...geoms.slice(1));
  if (intersection2$1.length === 0) return null;
  if (intersection2$1.length === 1)
    return polygon(intersection2$1[0], options.properties);
  return multiPolygon(intersection2$1, options.properties);
}
function kinks(featureIn) {
  let coordinates;
  let feature2;
  const results = {
    type: "FeatureCollection",
    features: []
  };
  if (featureIn.type === "Feature") {
    feature2 = featureIn.geometry;
  } else {
    feature2 = featureIn;
  }
  if (feature2.type === "LineString") {
    coordinates = [feature2.coordinates];
  } else if (feature2.type === "MultiLineString") {
    coordinates = feature2.coordinates;
  } else if (feature2.type === "MultiPolygon") {
    coordinates = [].concat(...feature2.coordinates);
  } else if (feature2.type === "Polygon") {
    coordinates = feature2.coordinates;
  } else {
    throw new Error(
      "Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry"
    );
  }
  coordinates.forEach((line1) => {
    coordinates.forEach((line2) => {
      for (let i = 0; i < line1.length - 1; i++) {
        for (let k = i; k < line2.length - 1; k++) {
          if (line1 === line2) {
            if (Math.abs(i - k) === 1) {
              continue;
            }
            if (
              // segments are first and last segment of lineString
              i === 0 && k === line1.length - 2 && // lineString is closed
              line1[i][0] === line1[line1.length - 1][0] && line1[i][1] === line1[line1.length - 1][1]
            ) {
              continue;
            }
          }
          const intersection3 = lineIntersects(
            line1[i][0],
            line1[i][1],
            line1[i + 1][0],
            line1[i + 1][1],
            line2[k][0],
            line2[k][1],
            line2[k + 1][0],
            line2[k + 1][1]
          );
          if (intersection3) {
            results.features.push(point([intersection3[0], intersection3[1]]));
          }
        }
      }
    });
  });
  return results;
}
function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
  let denominator;
  let a;
  let b;
  let numerator1;
  let numerator2;
  const result = {
    x: null,
    y: null,
    onLine1: false,
    onLine2: false
  };
  denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
  if (denominator === 0) {
    if (result.x !== null && result.y !== null) {
      return result;
    } else {
      return false;
    }
  }
  a = line1StartY - line2StartY;
  b = line1StartX - line2StartX;
  numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
  numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
  a = numerator1 / denominator;
  b = numerator2 / denominator;
  result.x = line1StartX + a * (line1EndX - line1StartX);
  result.y = line1StartY + a * (line1EndY - line1StartY);
  if (a >= 0 && a <= 1) {
    result.onLine1 = true;
  }
  if (b >= 0 && b <= 1) {
    result.onLine2 = true;
  }
  if (result.onLine1 && result.onLine2) {
    return [result.x, result.y];
  } else {
    return false;
  }
}
function length(geojson, options = {}) {
  return segmentReduce(
    geojson,
    (previousValue, segment) => {
      const coords = segment.geometry.coordinates;
      return previousValue + distance(coords[0], coords[1], options);
    },
    0
  );
}
function lineToPolygon(lines, options = {}) {
  var _a2, _b2, _c;
  var properties = options.properties;
  var autoComplete = (_a2 = options.autoComplete) != null ? _a2 : true;
  var orderCoords = (_b2 = options.orderCoords) != null ? _b2 : true;
  var mutate = (_c = options.mutate) != null ? _c : false;
  if (!mutate) {
    lines = clone$1(lines);
  }
  switch (lines.type) {
    case "FeatureCollection":
      var coords = [];
      lines.features.forEach(function(line) {
        coords.push(
          getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords))
        );
      });
      return multiPolygon(coords, properties);
    default:
      return lineStringToPolygon(lines, properties, autoComplete, orderCoords);
  }
}
function lineStringToPolygon(line, properties, autoComplete, orderCoords) {
  properties = properties ? properties : line.type === "Feature" ? line.properties : {};
  var geom = getGeom(line);
  var coords = geom.coordinates;
  var type = geom.type;
  if (!coords.length) throw new Error("line must contain coordinates");
  switch (type) {
    case "LineString":
      if (autoComplete) coords = autoCompleteCoords(coords);
      return polygon([coords], properties);
    case "MultiLineString":
      var multiCoords = [];
      var largestArea = 0;
      coords.forEach(function(coord) {
        if (autoComplete) coord = autoCompleteCoords(coord);
        if (orderCoords) {
          var area2 = calculateArea(bbox(lineString(coord)));
          if (area2 > largestArea) {
            multiCoords.unshift(coord);
            largestArea = area2;
          } else multiCoords.push(coord);
        } else {
          multiCoords.push(coord);
        }
      });
      return polygon(multiCoords, properties);
    default:
      throw new Error("geometry type " + type + " is not supported");
  }
}
function autoCompleteCoords(coords) {
  var first = coords[0];
  var x12 = first[0];
  var y12 = first[1];
  var last = coords[coords.length - 1];
  var x2 = last[0];
  var y2 = last[1];
  if (x12 !== x2 || y12 !== y2) {
    coords.push(first);
  }
  return coords;
}
function calculateArea(bbox2) {
  var west = bbox2[0];
  var south = bbox2[1];
  var east = bbox2[2];
  var north = bbox2[3];
  return Math.abs(west - east) * Math.abs(south - north);
}
function midpoint(point1, point2) {
  const dist = distance(point1, point2);
  const heading = bearing(point1, point2);
  const midpoint2 = destination(point1, dist / 2, heading);
  return midpoint2;
}
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function nearestPoint(targetPoint, points, options = {}) {
  if (!targetPoint) throw new Error("targetPoint is required");
  if (!points) throw new Error("points is required");
  let minDist = Infinity;
  let bestFeatureIndex = 0;
  featureEach(points, (pt, featureIndex) => {
    const distanceToPoint = distance(targetPoint, pt, options);
    if (distanceToPoint < minDist) {
      bestFeatureIndex = featureIndex;
      minDist = distanceToPoint;
    }
  });
  const nearestPoint2 = clone$1(points.features[bestFeatureIndex]);
  return __spreadProps(__spreadValues({}, nearestPoint2), {
    properties: __spreadProps(__spreadValues({}, nearestPoint2.properties), {
      featureIndex: bestFeatureIndex,
      distanceToPoint: minDist
    })
  });
}
function getSqDist(p1, p2) {
  var dx = p1[0] - p2[0], dy = p1[1] - p2[1];
  return dx * dx + dy * dy;
}
function getSqSegDist(p, p1, p2) {
  var x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y;
  if (dx !== 0 || dy !== 0) {
    var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x = p2[0];
      y = p2[1];
    } else if (t > 0) {
      x += dx * t;
      y += dy * t;
    }
  }
  dx = p[0] - x;
  dy = p[1] - y;
  return dx * dx + dy * dy;
}
function simplifyRadialDist(points, sqTolerance) {
  var prevPoint = points[0], newPoints = [prevPoint], point2;
  for (var i = 1, len = points.length; i < len; i++) {
    point2 = points[i];
    if (getSqDist(point2, prevPoint) > sqTolerance) {
      newPoints.push(point2);
      prevPoint = point2;
    }
  }
  if (prevPoint !== point2) newPoints.push(point2);
  return newPoints;
}
function simplifyDPStep(points, first, last, sqTolerance, simplified) {
  var maxSqDist = sqTolerance, index;
  for (var i = first + 1; i < last; i++) {
    var sqDist = getSqSegDist(points[i], points[first], points[last]);
    if (sqDist > maxSqDist) {
      index = i;
      maxSqDist = sqDist;
    }
  }
  if (maxSqDist > sqTolerance) {
    if (index - first > 1)
      simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1)
      simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}
function simplifyDouglasPeucker(points, sqTolerance) {
  var last = points.length - 1;
  var simplified = [points[0]];
  simplifyDPStep(points, 0, last, sqTolerance, simplified);
  simplified.push(points[last]);
  return simplified;
}
function simplify(points, tolerance, highestQuality) {
  if (points.length <= 2) return points;
  var sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;
  points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
  points = simplifyDouglasPeucker(points, sqTolerance);
  return points;
}
function simplify2(geojson, options = {}) {
  var _a2, _b2, _c;
  options = options != null ? options : {};
  if (!isObject$1(options)) throw new Error("options is invalid");
  const tolerance = (_a2 = options.tolerance) != null ? _a2 : 1;
  const highQuality = (_b2 = options.highQuality) != null ? _b2 : false;
  const mutate = (_c = options.mutate) != null ? _c : false;
  if (!geojson) throw new Error("geojson is required");
  if (tolerance && tolerance < 0) throw new Error("invalid tolerance");
  if (mutate !== true) geojson = clone$1(geojson);
  geomEach(geojson, function(geom) {
    simplifyGeom(geom, tolerance, highQuality);
  });
  return geojson;
}
function simplifyGeom(geometry, tolerance, highQuality) {
  const type = geometry.type;
  if (type === "Point" || type === "MultiPoint") return geometry;
  cleanCoords(geometry, { mutate: true });
  if (type !== "GeometryCollection") {
    switch (type) {
      case "LineString":
        geometry.coordinates = simplify(
          geometry.coordinates,
          tolerance,
          highQuality
        );
        break;
      case "MultiLineString":
        geometry.coordinates = geometry.coordinates.map(
          (lines) => simplify(lines, tolerance, highQuality)
        );
        break;
      case "Polygon":
        geometry.coordinates = simplifyPolygon(
          geometry.coordinates,
          tolerance,
          highQuality
        );
        break;
      case "MultiPolygon":
        geometry.coordinates = geometry.coordinates.map(
          (rings) => simplifyPolygon(rings, tolerance, highQuality)
        );
    }
  }
  return geometry;
}
function simplifyPolygon(coordinates, tolerance, highQuality) {
  return coordinates.map(function(ring) {
    if (ring.length < 4) {
      throw new Error("invalid polygon");
    }
    let ringTolerance = tolerance;
    let simpleRing = simplify(ring, ringTolerance, highQuality);
    while (!checkValidity(simpleRing)) {
      ringTolerance -= ringTolerance * 0.01;
      simpleRing = simplify(ring, ringTolerance, highQuality);
    }
    if (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] || simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]) {
      simpleRing.push(simpleRing[0]);
    }
    return simpleRing;
  });
}
function checkValidity(ring) {
  if (ring.length < 3) return false;
  return !(ring.length === 3 && ring[2][0] === ring[0][0] && ring[2][1] === ring[0][1]);
}
function union2(features, options = {}) {
  const geoms = [];
  geomEach(features, (geom) => {
    geoms.push(geom.coordinates);
  });
  if (geoms.length < 2) {
    throw new Error("Must have at least 2 geometries");
  }
  const unioned = union(geoms[0], ...geoms.slice(1));
  if (unioned.length === 0) return null;
  if (unioned.length === 1) return polygon(unioned[0], options.properties);
  else return multiPolygon(unioned, options.properties);
}
function geojsonPolygonSelfIntersections(feature2, filterFn, useSpatialIndex) {
  if (feature2.geometry.type !== "Polygon")
    throw new Error("The input feature must be a Polygon");
  if (useSpatialIndex === void 0) useSpatialIndex = 1;
  var coord = feature2.geometry.coordinates;
  var output = [];
  var seen = {};
  if (useSpatialIndex) {
    var allEdgesAsRbushTreeItems = [];
    for (var ring0 = 0; ring0 < coord.length; ring0++) {
      for (var edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {
        allEdgesAsRbushTreeItems.push(rbushTreeItem(ring0, edge0));
      }
    }
    var tree = new RBush();
    tree.load(allEdgesAsRbushTreeItems);
  }
  for (var ringA = 0; ringA < coord.length; ringA++) {
    for (var edgeA = 0; edgeA < coord[ringA].length - 1; edgeA++) {
      if (useSpatialIndex) {
        var bboxOverlaps = tree.search(rbushTreeItem(ringA, edgeA));
        bboxOverlaps.forEach(function(bboxIsect) {
          var ring12 = bboxIsect.ring;
          var edge12 = bboxIsect.edge;
          ifIsectAddToOutput(ringA, edgeA, ring12, edge12);
        });
      } else {
        for (var ring1 = 0; ring1 < coord.length; ring1++) {
          for (var edge1 = 0; edge1 < coord[ring1].length - 1; edge1++) {
            ifIsectAddToOutput(ringA, edgeA, ring1, edge1);
          }
        }
      }
    }
  }
  if (!filterFn)
    output = {
      type: "Feature",
      geometry: { type: "MultiPoint", coordinates: output }
    };
  return output;
  function ifIsectAddToOutput(ring02, edge02, ring12, edge12) {
    var start0 = coord[ring02][edge02];
    var end0 = coord[ring02][edge02 + 1];
    var start1 = coord[ring12][edge12];
    var end1 = coord[ring12][edge12 + 1];
    var isect = intersect(start0, end0, start1, end1);
    if (isect === null) return;
    var frac0;
    var frac1;
    if (end0[0] !== start0[0]) {
      frac0 = (isect[0] - start0[0]) / (end0[0] - start0[0]);
    } else {
      frac0 = (isect[1] - start0[1]) / (end0[1] - start0[1]);
    }
    if (end1[0] !== start1[0]) {
      frac1 = (isect[0] - start1[0]) / (end1[0] - start1[0]);
    } else {
      frac1 = (isect[1] - start1[1]) / (end1[1] - start1[1]);
    }
    if (frac0 >= 1 || frac0 <= 0 || frac1 >= 1 || frac1 <= 0) return;
    var key = isect;
    var unique = !seen[key];
    if (unique) {
      seen[key] = true;
    }
    if (filterFn) {
      output.push(
        filterFn(
          isect,
          ring02,
          edge02,
          start0,
          end0,
          frac0,
          ring12,
          edge12,
          start1,
          end1,
          frac1,
          unique
        )
      );
    } else {
      output.push(isect);
    }
  }
  function rbushTreeItem(ring, edge) {
    var start = coord[ring][edge];
    var end = coord[ring][edge + 1];
    var minX;
    var maxX;
    var minY;
    var maxY;
    if (start[0] < end[0]) {
      minX = start[0];
      maxX = end[0];
    } else {
      minX = end[0];
      maxX = start[0];
    }
    if (start[1] < end[1]) {
      minY = start[1];
      maxY = end[1];
    } else {
      minY = end[1];
      maxY = start[1];
    }
    return {
      minX,
      minY,
      maxX,
      maxY,
      ring,
      edge
    };
  }
}
function intersect(start0, end0, start1, end1) {
  if (equalArrays(start0, start1) || equalArrays(start0, end1) || equalArrays(end0, start1) || equalArrays(end1, start1))
    return null;
  var x02 = start0[0], y02 = start0[1], x12 = end0[0], y12 = end0[1], x2 = start1[0], y2 = start1[1], x3 = end1[0], y3 = end1[1];
  var denom = (x02 - x12) * (y2 - y3) - (y02 - y12) * (x2 - x3);
  if (denom === 0) return null;
  var x4 = ((x02 * y12 - y02 * x12) * (x2 - x3) - (x02 - x12) * (x2 * y3 - y2 * x3)) / denom;
  var y4 = ((x02 * y12 - y02 * x12) * (y2 - y3) - (y02 - y12) * (x2 * y3 - y2 * x3)) / denom;
  return [x4, y4];
}
function equalArrays(array1, array2) {
  if (!array1 || !array2) return false;
  if (array1.length !== array2.length) return false;
  for (var i = 0, l = array1.length; i < l; i++) {
    if (array1[i] instanceof Array && array2[i] instanceof Array) {
      if (!equalArrays(array1[i], array2[i])) return false;
    } else if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function simplepolygon(feature2) {
  if (feature2.type != "Feature")
    throw new Error("The input must a geojson object of type Feature");
  if (feature2.geometry === void 0 || feature2.geometry == null)
    throw new Error(
      "The input must a geojson object with a non-empty geometry"
    );
  if (feature2.geometry.type != "Polygon")
    throw new Error("The input must be a geojson Polygon");
  var numRings = feature2.geometry.coordinates.length;
  var vertices = [];
  for (var i = 0; i < numRings; i++) {
    var ring = feature2.geometry.coordinates[i];
    if (!equalArrays2(ring[0], ring[ring.length - 1])) {
      ring.push(ring[0]);
    }
    for (var j = 0; j < ring.length - 1; j++) {
      vertices.push(ring[j]);
    }
  }
  if (!isUnique(vertices))
    throw new Error(
      "The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)"
    );
  var numvertices = vertices.length;
  var selfIsectsData = geojsonPolygonSelfIntersections(
    feature2,
    function filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique) {
      return [
        isect,
        ring0,
        edge0,
        start0,
        end0,
        frac0,
        ring1,
        edge1,
        start1,
        end1,
        frac1,
        unique
      ];
    }
  );
  var numSelfIsect = selfIsectsData.length;
  if (numSelfIsect == 0) {
    var outputFeatureArray = [];
    for (var i = 0; i < numRings; i++) {
      outputFeatureArray.push(
        polygon([feature2.geometry.coordinates[i]], {
          parent: -1,
          winding: windingOfRing(feature2.geometry.coordinates[i])
        })
      );
    }
    var output = featureCollection(outputFeatureArray);
    determineParents();
    setNetWinding();
    return output;
  }
  var pseudoVtxListByRingAndEdge = [];
  var isectList = [];
  for (var i = 0; i < numRings; i++) {
    pseudoVtxListByRingAndEdge.push([]);
    for (var j = 0; j < feature2.geometry.coordinates[i].length - 1; j++) {
      pseudoVtxListByRingAndEdge[i].push([
        new PseudoVtx(
          feature2.geometry.coordinates[i][modulo(j + 1, feature2.geometry.coordinates[i].length - 1)],
          1,
          [i, j],
          [i, modulo(j + 1, feature2.geometry.coordinates[i].length - 1)],
          void 0
        )
      ]);
      isectList.push(
        new Isect(
          feature2.geometry.coordinates[i][j],
          [i, modulo(j - 1, feature2.geometry.coordinates[i].length - 1)],
          [i, j],
          void 0,
          void 0,
          false,
          true
        )
      );
    }
  }
  for (var i = 0; i < numSelfIsect; i++) {
    pseudoVtxListByRingAndEdge[selfIsectsData[i][1]][selfIsectsData[i][2]].push(
      new PseudoVtx(
        selfIsectsData[i][0],
        selfIsectsData[i][5],
        [selfIsectsData[i][1], selfIsectsData[i][2]],
        [selfIsectsData[i][6], selfIsectsData[i][7]],
        void 0
      )
    );
    if (selfIsectsData[i][11])
      isectList.push(
        new Isect(
          selfIsectsData[i][0],
          [selfIsectsData[i][1], selfIsectsData[i][2]],
          [selfIsectsData[i][6], selfIsectsData[i][7]],
          void 0,
          void 0,
          true,
          true
        )
      );
  }
  var numIsect = isectList.length;
  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
      pseudoVtxListByRingAndEdge[i][j].sort(function(a, b) {
        return a.param < b.param ? -1 : 1;
      });
    }
  }
  var allIsectsAsIsectRbushTreeItem = [];
  for (var i = 0; i < numIsect; i++) {
    allIsectsAsIsectRbushTreeItem.push({
      minX: isectList[i].coord[0],
      minY: isectList[i].coord[1],
      maxX: isectList[i].coord[0],
      maxY: isectList[i].coord[1],
      index: i
    });
  }
  var isectRbushTree = new RBush();
  isectRbushTree.load(allIsectsAsIsectRbushTreeItem);
  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
      for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {
        var coordToFind;
        if (k == pseudoVtxListByRingAndEdge[i][j].length - 1) {
          coordToFind = pseudoVtxListByRingAndEdge[i][modulo(j + 1, feature2.geometry.coordinates[i].length - 1)][0].coord;
        } else {
          coordToFind = pseudoVtxListByRingAndEdge[i][j][k + 1].coord;
        }
        var IsectRbushTreeItemFound = isectRbushTree.search({
          minX: coordToFind[0],
          minY: coordToFind[1],
          maxX: coordToFind[0],
          maxY: coordToFind[1]
        })[0];
        pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn = IsectRbushTreeItemFound.index;
      }
    }
  }
  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
      for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {
        var coordToFind = pseudoVtxListByRingAndEdge[i][j][k].coord;
        var IsectRbushTreeItemFound = isectRbushTree.search({
          minX: coordToFind[0],
          minY: coordToFind[1],
          maxX: coordToFind[0],
          maxY: coordToFind[1]
        })[0];
        var l = IsectRbushTreeItemFound.index;
        if (l < numvertices) {
          isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
        } else {
          if (equalArrays2(
            isectList[l].ringAndEdge1,
            pseudoVtxListByRingAndEdge[i][j][k].ringAndEdgeIn
          )) {
            isectList[l].nxtIsectAlongRingAndEdge1 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
          } else {
            isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
          }
        }
      }
    }
  }
  var queue = [];
  var i = 0;
  for (var j = 0; j < numRings; j++) {
    var leftIsect = i;
    for (var k = 0; k < feature2.geometry.coordinates[j].length - 1; k++) {
      if (isectList[i].coord[0] < isectList[leftIsect].coord[0]) {
        leftIsect = i;
      }
      i++;
    }
    var isectAfterLeftIsect = isectList[leftIsect].nxtIsectAlongRingAndEdge2;
    for (var k = 0; k < isectList.length; k++) {
      if (isectList[k].nxtIsectAlongRingAndEdge1 == leftIsect || isectList[k].nxtIsectAlongRingAndEdge2 == leftIsect) {
        var isectBeforeLeftIsect = k;
        break;
      }
    }
    var windingAtIsect = isConvex(
      [
        isectList[isectBeforeLeftIsect].coord,
        isectList[leftIsect].coord,
        isectList[isectAfterLeftIsect].coord
      ],
      true
    ) ? 1 : -1;
    queue.push({ isect: leftIsect, parent: -1, winding: windingAtIsect });
  }
  queue.sort(function(a, b) {
    return isectList[a.isect].coord > isectList[b.isect].coord ? -1 : 1;
  });
  var outputFeatureArray = [];
  while (queue.length > 0) {
    var popped = queue.pop();
    var startIsect = popped.isect;
    var currentOutputRingParent = popped.parent;
    var currentOutputRingWinding = popped.winding;
    var currentOutputRing = outputFeatureArray.length;
    var currentOutputRingCoords = [isectList[startIsect].coord];
    var currentIsect = startIsect;
    if (isectList[startIsect].ringAndEdge1Walkable) {
      var walkingRingAndEdge = isectList[startIsect].ringAndEdge1;
      var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge1;
    } else {
      var walkingRingAndEdge = isectList[startIsect].ringAndEdge2;
      var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge2;
    }
    while (!equalArrays2(isectList[startIsect].coord, isectList[nxtIsect].coord)) {
      currentOutputRingCoords.push(isectList[nxtIsect].coord);
      var nxtIsectInQueue = void 0;
      for (var i = 0; i < queue.length; i++) {
        if (queue[i].isect == nxtIsect) {
          nxtIsectInQueue = i;
          break;
        }
      }
      if (nxtIsectInQueue != void 0) {
        queue.splice(nxtIsectInQueue, 1);
      }
      if (equalArrays2(walkingRingAndEdge, isectList[nxtIsect].ringAndEdge1)) {
        walkingRingAndEdge = isectList[nxtIsect].ringAndEdge2;
        isectList[nxtIsect].ringAndEdge2Walkable = false;
        if (isectList[nxtIsect].ringAndEdge1Walkable) {
          var pushing = { isect: nxtIsect };
          if (isConvex(
            [
              isectList[currentIsect].coord,
              isectList[nxtIsect].coord,
              isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge2].coord
            ],
            currentOutputRingWinding == 1
          )) {
            pushing.parent = currentOutputRingParent;
            pushing.winding = -currentOutputRingWinding;
          } else {
            pushing.parent = currentOutputRing;
            pushing.winding = currentOutputRingWinding;
          }
          queue.push(pushing);
        }
        currentIsect = nxtIsect;
        nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge2;
      } else {
        walkingRingAndEdge = isectList[nxtIsect].ringAndEdge1;
        isectList[nxtIsect].ringAndEdge1Walkable = false;
        if (isectList[nxtIsect].ringAndEdge2Walkable) {
          var pushing = { isect: nxtIsect };
          if (isConvex(
            [
              isectList[currentIsect].coord,
              isectList[nxtIsect].coord,
              isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge1].coord
            ],
            currentOutputRingWinding == 1
          )) {
            pushing.parent = currentOutputRingParent;
            pushing.winding = -currentOutputRingWinding;
          } else {
            pushing.parent = currentOutputRing;
            pushing.winding = currentOutputRingWinding;
          }
          queue.push(pushing);
        }
        currentIsect = nxtIsect;
        nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge1;
      }
    }
    currentOutputRingCoords.push(isectList[nxtIsect].coord);
    outputFeatureArray.push(
      polygon([currentOutputRingCoords], {
        index: currentOutputRing,
        parent: currentOutputRingParent,
        winding: currentOutputRingWinding,
        netWinding: void 0
      })
    );
  }
  var output = featureCollection(outputFeatureArray);
  determineParents();
  setNetWinding();
  function determineParents() {
    var featuresWithoutParent = [];
    for (var i2 = 0; i2 < output.features.length; i2++) {
      if (output.features[i2].properties.parent == -1)
        featuresWithoutParent.push(i2);
    }
    if (featuresWithoutParent.length > 1) {
      for (var i2 = 0; i2 < featuresWithoutParent.length; i2++) {
        var parent = -1;
        var parentArea = Infinity;
        for (var j2 = 0; j2 < output.features.length; j2++) {
          if (featuresWithoutParent[i2] == j2) continue;
          if (booleanPointInPolygon(
            output.features[featuresWithoutParent[i2]].geometry.coordinates[0][0],
            output.features[j2],
            { ignoreBoundary: true }
          )) {
            if (area(output.features[j2]) < parentArea) {
              parent = j2;
            }
          }
        }
        output.features[featuresWithoutParent[i2]].properties.parent = parent;
      }
    }
  }
  function setNetWinding() {
    for (var i2 = 0; i2 < output.features.length; i2++) {
      if (output.features[i2].properties.parent == -1) {
        var netWinding = output.features[i2].properties.winding;
        output.features[i2].properties.netWinding = netWinding;
        setNetWindingOfChildren(i2, netWinding);
      }
    }
  }
  function setNetWindingOfChildren(parent, ParentNetWinding) {
    for (var i2 = 0; i2 < output.features.length; i2++) {
      if (output.features[i2].properties.parent == parent) {
        var netWinding = ParentNetWinding + output.features[i2].properties.winding;
        output.features[i2].properties.netWinding = netWinding;
        setNetWindingOfChildren(i2, netWinding);
      }
    }
  }
  return output;
}
var PseudoVtx = function(coord, param, ringAndEdgeIn, ringAndEdgeOut, nxtIsectAlongEdgeIn) {
  this.coord = coord;
  this.param = param;
  this.ringAndEdgeIn = ringAndEdgeIn;
  this.ringAndEdgeOut = ringAndEdgeOut;
  this.nxtIsectAlongEdgeIn = nxtIsectAlongEdgeIn;
};
var Isect = function(coord, ringAndEdge1, ringAndEdge2, nxtIsectAlongRingAndEdge1, nxtIsectAlongRingAndEdge2, ringAndEdge1Walkable, ringAndEdge2Walkable) {
  this.coord = coord;
  this.ringAndEdge1 = ringAndEdge1;
  this.ringAndEdge2 = ringAndEdge2;
  this.nxtIsectAlongRingAndEdge1 = nxtIsectAlongRingAndEdge1;
  this.nxtIsectAlongRingAndEdge2 = nxtIsectAlongRingAndEdge2;
  this.ringAndEdge1Walkable = ringAndEdge1Walkable;
  this.ringAndEdge2Walkable = ringAndEdge2Walkable;
};
function isConvex(pts, righthanded) {
  if (typeof righthanded === "undefined") righthanded = true;
  if (pts.length != 3)
    throw new Error("This function requires an array of three points [x,y]");
  var d = (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) - (pts[1][1] - pts[0][1]) * (pts[2][0] - pts[0][0]);
  return d >= 0 == righthanded;
}
function windingOfRing(ring) {
  var leftVtx = 0;
  for (var i = 0; i < ring.length - 1; i++) {
    if (ring[i][0] < ring[leftVtx][0]) leftVtx = i;
  }
  if (isConvex(
    [
      ring[modulo(leftVtx - 1, ring.length - 1)],
      ring[leftVtx],
      ring[modulo(leftVtx + 1, ring.length - 1)]
    ],
    true
  )) {
    var winding = 1;
  } else {
    var winding = -1;
  }
  return winding;
}
function equalArrays2(array1, array2) {
  if (!array1 || !array2) return false;
  if (array1.length != array2.length) return false;
  for (var i = 0, l = array1.length; i < l; i++) {
    if (array1[i] instanceof Array && array2[i] instanceof Array) {
      if (!equalArrays2(array1[i], array2[i])) return false;
    } else if (array1[i] != array2[i]) {
      return false;
    }
  }
  return true;
}
function modulo(n, m) {
  return (n % m + m) % m;
}
function isUnique(array) {
  var u2 = {};
  var isUnique2 = 1;
  for (var i = 0, l = array.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(u2, array[i])) {
      isUnique2 = 0;
      break;
    }
    u2[array[i]] = 1;
  }
  return isUnique2;
}
function unkinkPolygon(geojson) {
  var features = [];
  flattenEach(geojson, function(feature2) {
    if (feature2.geometry.type !== "Polygon") return;
    featureEach(simplepolygon(feature2), function(poly) {
      features.push(polygon(poly.geometry.coordinates, feature2.properties));
    });
  });
  return featureCollection(features);
}
class TurfHelper {
  constructor(config) {
    __publicField(this, "config", null);
    this.config = { ...defaultConfig, ...config };
  }
  union(poly1, poly2) {
    try {
      const featureCollection$1 = featureCollection([poly1, poly2]);
      const union3 = union2(featureCollection$1);
      return union3 ? this.getTurfPolygon(union3) : null;
    } catch (error) {
      console.warn("Error in union:", error.message);
      return null;
    }
  }
  /**
   * Create polygon from drawing trace using configured method
   */
  createPolygonFromTrace(feature2) {
    var _a2;
    const method = ((_a2 = this.config.polygonCreation) == null ? void 0 : _a2.method) || "concaveman";
    switch (method) {
      case "concaveman":
        return this.turfConcaveman(feature2);
      case "convex":
        return this.createConvexPolygon(feature2);
      case "direct":
        return this.createDirectPolygon(feature2);
      case "buffer":
        return this.createBufferedPolygon(feature2);
      default:
        console.warn(`Unknown polygon creation method: ${method}, falling back to concaveman`);
        return this.turfConcaveman(feature2);
    }
  }
  /**
   * Original concaveman implementation
   */
  turfConcaveman(feature2) {
    const points = explode(feature2);
    const coordinates = points.features.map((f) => f.geometry.coordinates);
    return multiPolygon([[concaveman(coordinates)]]);
  }
  /**
   * Create convex hull polygon (simplest, fewest edges)
   */
  createConvexPolygon(feature2) {
    const points = explode(feature2);
    const convexHull = convex(points);
    if (!convexHull) {
      return this.createDirectPolygon(feature2);
    }
    return this.getTurfPolygon(convexHull);
  }
  /**
   * Create polygon directly from line coordinates (moderate edge count)
   */
  createDirectPolygon(feature2) {
    let coordinates;
    if (feature2.geometry.type === "LineString") {
      coordinates = feature2.geometry.coordinates;
    } else if (feature2.geometry.type === "Polygon") {
      coordinates = feature2.geometry.coordinates[0];
    } else {
      const points = explode(feature2);
      coordinates = points.features.map((f) => f.geometry.coordinates);
    }
    if (coordinates.length > 0) {
      const first = coordinates[0];
      const last = coordinates[coordinates.length - 1];
      if (first[0] !== last[0] || first[1] !== last[1]) {
        coordinates.push([first[0], first[1]]);
      }
    }
    if (coordinates.length < 4) {
      console.warn("Not enough points for direct polygon, falling back to concaveman");
      return this.turfConcaveman(feature2);
    }
    return multiPolygon([[coordinates]]);
  }
  /**
   * Create polygon using buffer method (smooth curves)
   */
  createBufferedPolygon(feature2) {
    try {
      let line;
      if (feature2.geometry.type === "LineString") {
        line = feature2;
      } else {
        const points = explode(feature2);
        const coordinates = points.features.map((f) => f.geometry.coordinates);
        line = lineString(coordinates);
      }
      const buffered = buffer(line, 1e-3, { units: "kilometers" });
      if (!buffered) {
        return this.createDirectPolygon(feature2);
      }
      return this.getTurfPolygon(buffered);
    } catch (error) {
      console.warn("Buffer polygon creation failed:", error.message);
      return this.createDirectPolygon(feature2);
    }
  }
  getSimplified(polygon2, dynamicTolerance = false) {
    var _a2, _b2, _c, _d, _e, _f;
    const simplificationMode = ((_b2 = (_a2 = this.config.polygonCreation) == null ? void 0 : _a2.simplification) == null ? void 0 : _b2.mode) || "simple";
    if (simplificationMode === "simple") {
      const tolerance = {
        tolerance: ((_d = (_c = this.config.polygonCreation) == null ? void 0 : _c.simplification) == null ? void 0 : _d.tolerance) || 1e-4,
        highQuality: ((_f = (_e = this.config.polygonCreation) == null ? void 0 : _e.simplification) == null ? void 0 : _f.highQuality) || false,
        mutate: false
      };
      const simplified = simplify2(polygon2, tolerance);
      return simplified;
    } else if (simplificationMode === "dynamic") {
      const numOfEdges = polygon2.geometry.coordinates[0][0].length;
      const tolerance = this.config.simplification.simplifyTolerance;
      if (!dynamicTolerance) {
        const simplified = simplify2(polygon2, tolerance);
        return simplified;
      } else {
        let simplified = simplify2(polygon2, tolerance);
        const fractionGuard = this.config.simplification.dynamicMode.fractionGuard;
        const multipiler = this.config.simplification.dynamicMode.multipiler;
        while (simplified.geometry.coordinates[0][0].length > 4 && simplified.geometry.coordinates[0][0].length / (numOfEdges + 2) > fractionGuard) {
          tolerance.tolerance = tolerance.tolerance * multipiler;
          simplified = simplify2(polygon2, tolerance);
        }
        return simplified;
      }
    } else if (simplificationMode === "none") {
      return polygon2;
    } else {
      console.warn(`Unknown simplification mode: ${simplificationMode}, falling back to simple`);
      const tolerance = {
        tolerance: 1e-4,
        highQuality: false,
        mutate: false
      };
      return simplify2(polygon2, tolerance);
    }
  }
  getTurfPolygon(polygon2) {
    let turfPolygon;
    if (polygon2.geometry.type === "Polygon") {
      turfPolygon = multiPolygon([polygon2.geometry.coordinates]);
    } else {
      turfPolygon = multiPolygon(polygon2.geometry.coordinates);
    }
    return turfPolygon;
  }
  getMultiPolygon(polygonArray) {
    return multiPolygon(polygonArray);
  }
  getKinks(feature2) {
    try {
      if (!feature2 || !feature2.geometry || !feature2.geometry.coordinates) {
        return [feature2];
      }
      const cleanedFeature = this.removeDuplicateVertices(feature2);
      if (!cleanedFeature || !cleanedFeature.geometry || !cleanedFeature.geometry.coordinates) {
        console.warn("Feature became invalid after cleaning in getKinks");
        return [feature2];
      }
      const hasHoles = this.polygonHasHoles(cleanedFeature);
      if (hasHoles) {
        return this.getKinksWithHolePreservation(cleanedFeature);
      } else {
        const unkink = unkinkPolygon(cleanedFeature);
        const coordinates = [];
        featureEach(unkink, (current) => {
          coordinates.push(current);
        });
        return coordinates;
      }
    } catch (error) {
      console.warn("Error processing kinks:", error.message);
      return [feature2];
    }
  }
  getCoords(feature2) {
    return getCoords(feature2);
  }
  hasKinks(feature2) {
    const kinks$12 = kinks(feature2);
    return kinks$12.features.length > 0;
  }
  /**
   * Get the convex hull of a polygon
   */
  getConvexHull(polygon2) {
    try {
      const featureCollection$1 = featureCollection([polygon2]);
      return convex(featureCollection$1);
    } catch (error) {
      console.warn("Error in getConvexHull:", error.message);
      return null;
    }
  }
  /**
   * Calculate midpoint between two LatLngLiteral points
   */
  getMidpoint(point1, point2) {
    const p1 = point([point1.lng, point1.lat]);
    const p2 = point([point2.lng, point2.lat]);
    const midpoint$1 = midpoint(p1, p2);
    return {
      lat: midpoint$1.geometry.coordinates[1],
      lng: midpoint$1.geometry.coordinates[0]
    };
  }
  polygonIntersect(polygon2, latlngs) {
    try {
      if (!polygon2 || !polygon2.geometry || !polygon2.geometry.coordinates || !latlngs || !latlngs.geometry || !latlngs.geometry.coordinates) {
        console.warn("Invalid features passed to polygonIntersect");
        return false;
      }
      try {
        const featureCollection$1 = featureCollection([polygon2, latlngs]);
        const intersection3 = intersect$1(featureCollection$1);
        if (intersection3 && intersection3.geometry && (intersection3.geometry.type === "Polygon" || intersection3.geometry.type === "MultiPolygon")) {
          const area$1 = area(intersection3);
          if (area$1 > 1e-6) {
            return true;
          }
        }
      } catch (error) {
      }
      try {
        const points1 = explode(polygon2);
        const points2 = explode(latlngs);
        for (const point2 of points2.features) {
          if (booleanPointInPolygon(point2, polygon2)) {
            return true;
          }
        }
        for (const point2 of points1.features) {
          if (booleanPointInPolygon(point2, latlngs)) {
            return true;
          }
        }
      } catch (error) {
      }
      try {
        const coords1 = getCoords(polygon2);
        const coords2 = getCoords(latlngs);
        for (const ring1 of coords1) {
          const outerRing1 = ring1[0];
          for (let i = 0; i < outerRing1.length - 1; i++) {
            const line1 = lineString([outerRing1[i], outerRing1[i + 1]]);
            for (const ring2 of coords2) {
              const outerRing2 = ring2[0];
              for (let j = 0; j < outerRing2.length - 1; j++) {
                const line2 = lineString([outerRing2[j], outerRing2[j + 1]]);
                try {
                  const intersection3 = lineIntersect(line1, line2);
                  if (intersection3 && intersection3.features && intersection3.features.length > 0) {
                    return true;
                  }
                } catch (lineError) {
                }
              }
            }
          }
        }
      } catch (error) {
      }
      try {
      } catch (error) {
        console.warn("Error in bounding box check:", error.message);
      }
      return false;
    } catch (error) {
      console.warn("Error in polygonIntersect:", error.message);
      return false;
    }
  }
  getIntersection(poly1, poly2) {
    try {
      const featureCollection$1 = featureCollection([poly1, poly2]);
      const result = intersect$1(featureCollection$1);
      if (result && result.geometry && (result.geometry.type === "Polygon" || result.geometry.type === "MultiPolygon")) {
        return result;
      }
      return null;
    } catch (error) {
      console.warn("Error in getIntersection:", error.message);
      return null;
    }
  }
  getDistance(point1, point2) {
    return distance(point1, point2);
  }
  isWithin(polygon1, polygon2) {
    return booleanWithin(polygon([polygon1]), polygon([polygon2]));
  }
  /**
   * Check if one polygon is completely within another polygon
   */
  isPolygonCompletelyWithin(innerPolygon, outerPolygon) {
    try {
      return booleanWithin(innerPolygon, outerPolygon);
    } catch (error) {
      const innerCoords = getCoords(innerPolygon);
      const outerCoords = getCoords(outerPolygon);
      for (const innerRing of innerCoords) {
        for (const ring of innerRing) {
          for (const coord of ring) {
            const point$1 = point(coord);
            let isInside = false;
            for (const outerRing of outerCoords) {
              for (const outerRingCoords of outerRing) {
                const outerPoly = polygon([outerRingCoords]);
                if (booleanPointInPolygon(point$1, outerPoly)) {
                  isInside = true;
                  break;
                }
              }
              if (isInside) break;
            }
            if (!isInside) {
              return false;
            }
          }
        }
      }
      return true;
    }
  }
  /**
   * Normalize various point-like inputs into a GeoJSON Feature<Point>.
   * Supports GeoJSON Feature<Point>, Turf Position [lng, lat], and Leaflet LatLngLiteral.
   */
  toPointFeature(point$1) {
    var _a2, _b2;
    if ((point$1 == null ? void 0 : point$1.type) === "Feature" && ((_a2 = point$1.geometry) == null ? void 0 : _a2.type) === "Point") {
      return point$1;
    }
    if (Array.isArray(point$1) && point$1.length >= 2 && typeof point$1[0] === "number" && typeof point$1[1] === "number") {
      return point(point$1);
    }
    if (typeof (point$1 == null ? void 0 : point$1.lat) === "number" && typeof (point$1 == null ? void 0 : point$1.lng) === "number") {
      const p = point$1;
      return point([p.lng, p.lat]);
    }
    if (((_b2 = point$1 == null ? void 0 : point$1.geometry) == null ? void 0 : _b2.coordinates) && Array.isArray(point$1.geometry.coordinates)) {
      return point(point$1.geometry.coordinates);
    }
    throw new Error("Unsupported point format provided to toPointFeature");
  }
  /**
   * Check if a point lies within a polygon.
   * Accepts Feature<Point>, Turf Position [lng, lat], or Leaflet LatLngLiteral.
   * This normalization prevents noisy console warnings in tests.
   */
  isPointInsidePolygon(point2, polygon2) {
    try {
      const pointFeature = this.toPointFeature(point2);
      return booleanPointInPolygon(pointFeature, polygon2);
    } catch (error) {
      return false;
    }
  }
  /**
   * Checks if two polygons are equal.
   * @param polygon1 First polygon.
   * @param polygon2 Second polygon.
   */
  equalPolygons(polygon1, polygon2) {
    return booleanEqual(polygon1, polygon2);
  }
  convertToBoundingBoxPolygon(polygon2) {
    const bbox$1 = bbox(polygon2.geometry);
    const bboxPolygon$1 = bboxPolygon(bbox$1);
    return bboxPolygon$1;
  }
  polygonToMultiPolygon(poly) {
    const multi = multiPolygon([poly.geometry.coordinates]);
    return multi;
  }
  injectPointToPolygon(polygon2, point2, ringIndex) {
    const newPoly = JSON.parse(JSON.stringify(polygon2));
    let targetRing;
    if (newPoly.geometry.type === "MultiPolygon") {
      targetRing = newPoly.geometry.coordinates[0][ringIndex];
    } else if (newPoly.geometry.type === "Polygon") {
      targetRing = newPoly.geometry.coordinates[ringIndex];
    } else {
      return newPoly;
    }
    if (!targetRing) {
      return newPoly;
    }
    let minDistance = Infinity;
    let insertIndex = 0;
    for (let i = 0; i < targetRing.length - 1; i++) {
      const edgeStart = targetRing[i];
      const edgeEnd = targetRing[i + 1];
      const distance2 = this.distanceToLineSegment(point2, edgeStart, edgeEnd);
      if (distance2 < minDistance) {
        minDistance = distance2;
        insertIndex = i + 1;
      }
    }
    targetRing.splice(insertIndex, 0, point2);
    return newPoly;
  }
  distanceToLineSegment(point2, lineStart, lineEnd) {
    const A = point2[0] - lineStart[0];
    const B2 = point2[1] - lineStart[1];
    const C = lineEnd[0] - lineStart[0];
    const D2 = lineEnd[1] - lineStart[1];
    const dot = A * C + B2 * D2;
    const lenSq = C * C + D2 * D2;
    if (lenSq === 0) return Math.sqrt(A * A + B2 * B2);
    const param = dot / lenSq;
    let xx, yy;
    if (param < 0) {
      xx = lineStart[0];
      yy = lineStart[1];
    } else if (param > 1) {
      xx = lineEnd[0];
      yy = lineEnd[1];
    } else {
      xx = lineStart[0] + param * C;
      yy = lineStart[1] + param * D2;
    }
    const dx = point2[0] - xx;
    const dy = point2[1] - yy;
    return Math.sqrt(dx * dx + dy * dy);
  }
  polygonDifference(polygon1, polygon2) {
    try {
      const featureCollection$1 = featureCollection([polygon1, polygon2]);
      const diff = difference2(featureCollection$1);
      const result = diff ? this.getTurfPolygon(diff) : null;
      return result;
    } catch (error) {
      console.warn("Error in polygonDifference:", error.message);
      return null;
    }
  }
  getBoundingBoxCompassPosition(polygon2, MarkerPosition2, useOffset, offsetDirection) {
    return null;
  }
  getNearestPointIndex(targetPoint, points) {
    const index = nearestPoint(targetPoint, points).properties.featureIndex;
    return index;
  }
  /**
   * Convert LatLngLiteral object to Turf.js coordinate array format.
   *
   * This method serves as a semantic interface for coordinate conversion,
   * ensuring consistent lng/lat order when interfacing with Turf.js functions.
   * While simple, it provides a clear contract and future-proofing for any
   * coordinate validation or transformation that might be needed later.
   *
   * @param point - LatLngLiteral object with lat/lng properties
   * @returns Turf.js coordinate array in [lng, lat] format
   */
  getCoord(point2) {
    return [point2.lng, point2.lat];
  }
  getFeaturePointCollection(points) {
    const pts = [];
    points.forEach((v) => {
      const p = point([v.lng, v.lat], {});
      pts.push(p);
    });
    const fc = featureCollection(pts);
    return fc;
  }
  getPolygonArea(poly) {
    const area$1 = area(poly);
    return area$1;
  }
  getPolygonPerimeter(poly) {
    const length$12 = length(poly, { units: "kilometers" });
    return length$12;
  }
  getCenterOfMass(feature2) {
    return centerOfMass(feature2);
  }
  getDoubleElbowLatLngs(points) {
    const doubleized = [];
    const len = points.length;
    const effectiveLen = points[0].lat === points[len - 1].lat && points[0].lng === points[len - 1].lng ? len - 1 : len;
    for (let i = 0; i < effectiveLen; i++) {
      const p1 = points[i];
      const p2 = points[(i + 1) % effectiveLen];
      doubleized.push(new L.LatLng(p1.lat, p1.lng));
      const midPoint = midpoint(point([p1.lng, p1.lat]), point([p2.lng, p2.lat]));
      doubleized.push(
        new L.LatLng(midPoint.geometry.coordinates[1], midPoint.geometry.coordinates[0])
      );
    }
    return doubleized;
  }
  getBezierMultiPolygon(polygonArray) {
    const line = polygonToLine(this.getMultiPolygon(polygonArray));
    line.features[0].geometry.coordinates.push(
      line.features[0].geometry.coordinates[0]
    );
    const bezierLine = bezierSpline(line.features[0], {
      resolution: this.config.bezier.resolution,
      sharpness: this.config.bezier.sharpness
    });
    const bezierPoly = lineToPolygon(bezierLine);
    return bezierPoly;
  }
  /**
   * Check if a polygon has holes (more than one ring)
   */
  polygonHasHoles(feature2) {
    try {
      if (feature2.geometry.type === "Polygon") {
        return feature2.geometry.coordinates.length > 1;
      } else if (feature2.geometry.type === "MultiPolygon") {
        return feature2.geometry.coordinates.some((polygon2) => polygon2.length > 1);
      }
      return false;
    } catch (error) {
      console.warn("Error checking for holes:", error.message);
      return false;
    }
  }
  /**
   * Handle kinks in polygons with holes while preserving hole structure
   */
  getKinksWithHolePreservation(feature2) {
    try {
      if (feature2.geometry.type === "Polygon") {
        const coordinates = feature2.geometry.coordinates;
        const outerRing = coordinates[0];
        const holes = coordinates.slice(1);
        const outerPolygon = {
          type: "Feature",
          geometry: {
            type: "Polygon",
            coordinates: [outerRing]
          },
          properties: feature2.properties || {}
        };
        const outerHasKinks = this.hasKinks(outerPolygon);
        const outerRingIntersectsHoles = this.checkOuterRingHoleIntersection(outerRing, holes);
        if (outerHasKinks || outerRingIntersectsHoles) {
          if (outerHasKinks) {
          } else {
          }
          const dragGoesCompletelyThroughHole = this.checkIfDragCompletelyThroughHole(
            outerRing,
            holes
          );
          if (dragGoesCompletelyThroughHole) {
            return this.handleCompleteHoleTraversal(outerPolygon, holes);
          }
          const unkink = unkinkPolygon(outerPolygon);
          const splitPolygons = [];
          featureEach(unkink, (splitPolygon) => {
            const polygonWithBites = this.subtractIntersectingHoles(splitPolygon, holes);
            splitPolygons.push(polygonWithBites);
          });
          return splitPolygons;
        } else {
          return [feature2];
        }
      } else if (feature2.geometry.type === "MultiPolygon") {
        const allResults = [];
        for (const polygonCoords of feature2.geometry.coordinates) {
          const singlePolygon = {
            type: "Feature",
            geometry: {
              type: "Polygon",
              coordinates: polygonCoords
            },
            properties: feature2.properties || {}
          };
          const results = this.getKinksWithHolePreservation(singlePolygon);
          allResults.push(...results);
        }
        return allResults;
      }
      return [feature2];
    } catch (error) {
      console.warn("Error in getKinksWithHolePreservation:", error.message);
      return [feature2];
    }
  }
  /**
   * Check if the drag line goes completely through a hole (like cutting cake)
   */
  checkIfDragCompletelyThroughHole(outerRing, holes) {
    try {
      const duplicatePoints = this.findDuplicatePoints(outerRing);
      if (duplicatePoints.length > 0) {
        return true;
      }
      const selfIntersectionLine = this.findSelfIntersectionLine(outerRing);
      if (selfIntersectionLine && holes.length > 0) {
        for (const hole of holes) {
          if (this.lineCompletelyTraversesHole(selfIntersectionLine, hole)) {
            return true;
          }
        }
      }
      if (this.hasKinks({
        type: "Feature",
        geometry: { type: "Polygon", coordinates: [outerRing] },
        properties: {}
      })) {
        for (const hole of holes) {
          if (this.holeIsCutByKinks(outerRing, hole)) {
            return true;
          }
        }
      }
      return false;
    } catch (error) {
      console.warn("Error checking complete hole traversal:", error.message);
      return false;
    }
  }
  /**
   * Find the line created by self-intersection in the outer ring
   */
  findSelfIntersectionLine(outerRing) {
    try {
      const pointCounts = /* @__PURE__ */ new Map();
      for (let i = 0; i < outerRing.length - 1; i++) {
        const point2 = outerRing[i];
        const key = `${point2[0]},${point2[1]}`;
        if (!pointCounts.has(key)) {
          pointCounts.set(key, { point: point2, indices: [i] });
        } else {
          pointCounts.get(key).indices.push(i);
        }
      }
      for (const [key, data] of pointCounts) {
        if (data.indices.length >= 2) {
          const startIndex = data.indices[0];
          const endIndex = data.indices[1];
          const line = [];
          for (let i = startIndex; i <= endIndex; i++) {
            line.push(outerRing[i]);
          }
          return line;
        }
      }
      return null;
    } catch (error) {
      console.warn("Error finding self-intersection line:", error.message);
      return null;
    }
  }
  /**
   * Check if a line completely traverses a hole
   */
  lineCompletelyTraversesHole(line, hole) {
    try {
      if (line.length < 2) return false;
      const lineStart = line[0];
      const lineEnd = line[line.length - 1];
      const holePolygon = polygon([hole]);
      const startInHole = booleanPointInPolygon(point(lineStart), holePolygon);
      const endInHole = booleanPointInPolygon(point(lineEnd), holePolygon);
      if (startInHole !== endInHole) {
        return true;
      }
      return false;
    } catch (error) {
      console.warn("Error checking line hole traversal:", error.message);
      return false;
    }
  }
  /**
   * Check if a hole is cut by the kinks in the outer ring
   */
  holeIsCutByKinks(outerRing, hole) {
    try {
      const outerPolygon = polygon([outerRing]);
      const holePolygon = polygon([hole]);
      const kinks$12 = kinks(outerPolygon);
      if (kinks$12.features.length === 0) return false;
      for (const kink of kinks$12.features) {
        const kinkPoint = kink.geometry.coordinates;
        try {
          const distance$1 = distance(point(kinkPoint), centroid(holePolygon));
          if (distance$1 < 0.01) {
            return true;
          }
          if (booleanPointInPolygon(point(kinkPoint), holePolygon)) {
            return true;
          }
        } catch (distanceError) {
          if (booleanPointInPolygon(point(kinkPoint), holePolygon)) {
            return true;
          }
        }
      }
      return false;
    } catch (error) {
      console.warn("Error checking hole cut by kinks:", error.message);
      return false;
    }
  }
  /**
   * Find duplicate points in a ring (excluding first/last which should be the same)
   */
  findDuplicatePoints(ring) {
    const duplicates = [];
    const seen = /* @__PURE__ */ new Set();
    for (let i = 0; i < ring.length - 1; i++) {
      const point2 = ring[i];
      const key = `${point2[0]},${point2[1]}`;
      if (seen.has(key)) {
        duplicates.push(point2);
      } else {
        seen.add(key);
      }
    }
    return duplicates;
  }
  /**
   * Check if outer ring intersects with holes (fallback detection for hole traversal)
   */
  checkOuterRingHoleIntersection(outerRing, holes) {
    try {
      if (holes.length === 0) {
        return false;
      }
      const outerPolygon = polygon([outerRing]);
      for (const hole of holes) {
        const holePolygon = polygon([hole]);
        const intersection3 = this.getIntersection(outerPolygon, holePolygon);
        if (intersection3) {
          return true;
        }
        for (let i = 0; i < outerRing.length - 1; i++) {
          const point$1 = outerRing[i];
          const pointInHole = booleanPointInPolygon(point(point$1), holePolygon);
          if (pointInHole) {
            return true;
          }
        }
      }
      return false;
    } catch (error) {
      return false;
    }
  }
  /**
   * Handle complete hole traversal - create solid polygons (cake cutting)
   */
  handleCompleteHoleTraversal(outerPolygon, holes) {
    try {
      const solidPolygon = {
        type: "Feature",
        geometry: {
          type: "Polygon",
          coordinates: [outerPolygon.geometry.coordinates[0]]
          // ONLY outer ring
        },
        properties: outerPolygon.properties || {}
      };
      const unkink = unkinkPolygon(solidPolygon);
      const resultPolygons = [];
      featureEach(unkink, (splitPolygon) => {
        splitPolygon._polydrawHoleTraversalOccurred = true;
        resultPolygons.push(splitPolygon);
      });
      return resultPolygons;
    } catch (error) {
      console.warn("Error handling complete hole traversal:", error.message);
      try {
        const fallbackPolygon = {
          ...outerPolygon,
          geometry: {
            ...outerPolygon.geometry,
            coordinates: [outerPolygon.geometry.coordinates[0]]
            // Only outer ring
          }
        };
        fallbackPolygon._polydrawHoleTraversalOccurred = true;
        return [fallbackPolygon];
      } catch (fallbackError) {
        return [outerPolygon];
      }
    }
  }
  /**
   * Assign holes to a polygon based on containment and intersection analysis
   */
  assignHolesToPolygon(polygon$1, holes) {
    try {
      const assignedHoles = [];
      for (const hole of holes) {
        const holePolygon = polygon([hole]);
        const intersectionResult = this.analyzeHolePolygonRelationship(holePolygon, polygon$1);
        if (intersectionResult.isCompletelyContained) {
          assignedHoles.push(hole);
        } else if (intersectionResult.hasIntersection) {
        } else {
        }
      }
      return {
        type: "Feature",
        geometry: {
          type: "Polygon",
          coordinates: [polygon$1.geometry.coordinates[0], ...assignedHoles]
        },
        properties: polygon$1.properties || {}
      };
    } catch (error) {
      console.warn("Error assigning holes to polygon:", error.message);
      return polygon$1;
    }
  }
  /**
   * Analyze the relationship between a hole and a polygon
   */
  analyzeHolePolygonRelationship(hole, polygon2) {
    try {
      const isCompletelyContained = booleanWithin(hole, polygon2);
      if (isCompletelyContained) {
        return {
          isCompletelyContained: true,
          hasIntersection: false,
          intersectionArea: 0
        };
      }
      const intersection3 = this.getIntersection(hole, polygon2);
      const hasIntersection = intersection3 !== null;
      let intersectionArea2 = 0;
      if (hasIntersection) {
        intersectionArea2 = area(intersection3);
        const holeArea = area(hole);
        const intersectionRatio = intersectionArea2 / holeArea;
        if (intersectionRatio < 0.1) {
          return {
            isCompletelyContained: false,
            hasIntersection: false,
            intersectionArea: 0
          };
        }
      }
      return {
        isCompletelyContained: false,
        hasIntersection,
        intersectionArea: intersectionArea2
      };
    } catch (error) {
      console.warn("Error analyzing hole-polygon relationship:", error.message);
      return {
        isCompletelyContained: false,
        hasIntersection: false,
        intersectionArea: 0
      };
    }
  }
  /**
   * Subtract intersecting holes from a polygon to create proper "bite" shapes
   */
  subtractIntersectingHoles(polygon$1, holes) {
    try {
      let resultPolygon = polygon$1;
      for (const hole of holes) {
        const holePolygon = polygon([hole]);
        const intersection3 = this.getIntersection(holePolygon, resultPolygon);
        if (intersection3) {
          const difference3 = this.polygonDifference(resultPolygon, holePolygon);
          if (difference3) {
            if (difference3.geometry.type === "Polygon") {
              resultPolygon = difference3;
            } else if (difference3.geometry.type === "MultiPolygon") {
              const multiPoly = difference3;
              let largestArea = 0;
              let largestPolygon = null;
              for (const coords of multiPoly.geometry.coordinates) {
                const poly = {
                  type: "Feature",
                  geometry: { type: "Polygon", coordinates: coords },
                  properties: {}
                };
                const area$1 = area(poly);
                if (area$1 > largestArea) {
                  largestArea = area$1;
                  largestPolygon = poly;
                }
              }
              if (largestPolygon) {
                resultPolygon = largestPolygon;
              }
            }
          } else {
          }
        } else {
        }
      }
      return resultPolygon;
    } catch (error) {
      console.warn("Error subtracting intersecting holes:", error.message);
      return polygon$1;
    }
  }
  /**
   * Calculate the area of a ring using the shoelace formula
   */
  calculateRingArea(ring) {
    let area2 = 0;
    const n = ring.length;
    for (let i = 0; i < n - 1; i++) {
      area2 += ring[i][0] * ring[i + 1][1];
      area2 -= ring[i + 1][0] * ring[i][1];
    }
    return Math.abs(area2) / 2;
  }
  /**
   * Remove duplicate vertices from a polygon to prevent turf errors
   */
  removeDuplicateVertices(feature2) {
    if (!feature2 || !feature2.geometry || !feature2.geometry.coordinates) {
      console.warn("Invalid feature passed to removeDuplicateVertices");
      return feature2;
    }
    const cleanCoordinates = (coords) => {
      if (!coords || coords.length < 3) {
        console.warn("Invalid coordinates array - need at least 3 points for a polygon");
        return coords || [];
      }
      const cleaned = [];
      const tolerance = 1e-6;
      for (let i = 0; i < coords.length; i++) {
        const current = coords[i];
        const next = coords[(i + 1) % coords.length];
        if (!current || !Array.isArray(current) || current.length < 2 || !next || !Array.isArray(next) || next.length < 2) {
          continue;
        }
        const latDiff = Math.abs(current[1] - next[1]);
        const lngDiff = Math.abs(current[0] - next[0]);
        if (latDiff > tolerance || lngDiff > tolerance) {
          cleaned.push(current);
        }
      }
      if (cleaned.length < 3) {
        console.warn("After cleaning, polygon has less than 3 points");
        return coords;
      }
      if (cleaned.length > 0) {
        const first = cleaned[0];
        const last = cleaned[cleaned.length - 1];
        const latDiff = Math.abs(first[1] - last[1]);
        const lngDiff = Math.abs(first[0] - last[0]);
        if (latDiff > tolerance || lngDiff > tolerance) {
          cleaned.push([first[0], first[1]]);
        }
      }
      return cleaned;
    };
    try {
      if (feature2.geometry.type === "Polygon") {
        const cleanedCoords = feature2.geometry.coordinates.map((ring) => cleanCoordinates(ring));
        if (cleanedCoords.some((ring) => ring.length < 4)) {
          console.warn("Cleaned polygon has invalid ring with less than 4 coordinates");
          return feature2;
        }
        return {
          ...feature2,
          geometry: {
            ...feature2.geometry,
            coordinates: cleanedCoords
          }
        };
      } else if (feature2.geometry.type === "MultiPolygon") {
        const cleanedCoords = feature2.geometry.coordinates.map(
          (polygon2) => polygon2.map((ring) => cleanCoordinates(ring))
        );
        if (cleanedCoords.some((polygon2) => polygon2.some((ring) => ring.length < 4))) {
          console.warn("Cleaned multipolygon has invalid ring with less than 4 coordinates");
          return feature2;
        }
        return {
          ...feature2,
          geometry: {
            ...feature2.geometry,
            coordinates: cleanedCoords
          }
        };
      }
    } catch (error) {
      console.warn("Error in removeDuplicateVertices:", error.message);
      return feature2;
    }
    return feature2;
  }
  // ========================================================================
  // POTENTIALLY UNUSED METHODS - TO BE REVIEWED FOR DELETION
  // ========================================================================
  /**
   * Create a "bite" by subtracting the intersected part of the hole from the polygon
   */
  createBiteFromHoleIntersection(polygon2, hole) {
    try {
      const intersection3 = this.getIntersection(hole, polygon2);
      if (!intersection3) {
        return polygon2;
      }
      const result = this.polygonDifference(polygon2, intersection3);
      if (result && result.geometry.type === "Polygon") {
        return result;
      }
      return polygon2;
    } catch (error) {
      console.warn("Error creating bite from hole intersection:", error.message);
      return polygon2;
    }
  }
}
const isTouchDevice = () => "ontouchstart" in window || navigator.maxTouchPoints > 0;
class PolyDrawUtil {
  /**
   * Gets the bounds of the polygon with optional padding.
   * @param polygon Array of LatLng points.
   * @param padding Padding factor.
   * @returns The LatLngBounds.
   */
  static getBounds(polygon2, padding = 0) {
    const tmpLatLng = [];
    polygon2.forEach((ll) => {
      if (isNaN(ll.lat) || isNaN(ll.lng)) ;
      tmpLatLng.push(ll);
    });
    const polyLine = new L.Polyline(tmpLatLng);
    const bounds = polyLine.getBounds();
    if (padding !== 0) {
      return bounds.pad(padding);
    }
    return bounds;
  }
}
class Compass {
  constructor(minLat = 0, minLng = 0, maxLat = 0, maxLng = 0) {
    __publicField(this, "direction", {
      East: new L.LatLng(0, 0),
      North: new L.LatLng(0, 0),
      NorthEast: new L.LatLng(0, 0),
      NorthWest: new L.LatLng(0, 0),
      South: new L.LatLng(0, 0),
      SouthEast: new L.LatLng(0, 0),
      SouthWest: new L.LatLng(0, 0),
      West: new L.LatLng(0, 0)
    });
    this.direction.North = new L.LatLng(maxLat, (minLng + maxLng) / 2);
    this.direction.NorthEast = new L.LatLng(maxLat, maxLng);
    this.direction.East = new L.LatLng((minLat + maxLat) / 2, maxLng);
    this.direction.SouthEast = new L.LatLng(minLat, maxLng);
    this.direction.South = new L.LatLng(minLat, (minLng + maxLng) / 2);
    this.direction.SouthWest = new L.LatLng(minLat, minLng);
    this.direction.West = new L.LatLng((minLat + maxLat) / 2, minLng);
    this.direction.NorthWest = new L.LatLng(maxLat, minLng);
  }
  getDirection(direction) {
    switch (direction) {
      case MarkerPosition.SouthWest:
        return this.direction.SouthWest;
      case MarkerPosition.West:
        return this.direction.West;
      case MarkerPosition.NorthWest:
        return this.direction.NorthWest;
      case MarkerPosition.North:
        return this.direction.North;
      case MarkerPosition.NorthEast:
        return this.direction.NorthEast;
      case MarkerPosition.East:
        return this.direction.East;
      case MarkerPosition.SouthEast:
        return this.direction.SouthEast;
      case MarkerPosition.South:
        return this.direction.South;
      default:
        throw new Error();
    }
  }
  getPositions(startPosition = MarkerPosition.SouthWest, clockwise = false, addClosingNode = true) {
    const positions = [];
    const posArray = this.getPositionAsArray(startPosition, clockwise);
    posArray.forEach((v) => {
      positions.push([v.lng, v.lat]);
    });
    if (addClosingNode) {
      positions.push([posArray[0].lng, posArray[0].lat]);
    }
    return positions;
  }
  getPositionAsArray(startPosition = MarkerPosition.NorthEast, clockwise = false) {
    const positions = [];
    if (clockwise) {
      positions.push(this.direction.SouthWest);
      positions.push(this.direction.West);
      positions.push(this.direction.NorthWest);
      positions.push(this.direction.North);
      positions.push(this.direction.NorthEast);
      positions.push(this.direction.East);
      positions.push(this.direction.SouthEast);
      positions.push(this.direction.South);
    } else {
      positions.push(this.direction.SouthWest);
      positions.push(this.direction.South);
      positions.push(this.direction.SouthEast);
      positions.push(this.direction.East);
      positions.push(this.direction.NorthEast);
      positions.push(this.direction.North);
      positions.push(this.direction.NorthWest);
      positions.push(this.direction.West);
    }
    if (startPosition !== MarkerPosition.SouthWest) {
      const chunk = positions.splice(0, startPosition);
      chunk.forEach((v, i) => {
        positions.splice(startPosition + i, 0, v);
      });
    }
    return positions;
  }
}
class Perimeter {
  constructor(length2, config) {
    __publicField(this, "metricLength", "");
    __publicField(this, "metricUnit", "");
    __publicField(this, "imperialLength", "");
    __publicField(this, "imperialUnit", "");
    if (length2 !== null || length2 !== void 0) {
      if (length2 === 0) {
        if (config.markers.markerInfoIcon.usePerimeterMinValue) {
          this.metricLength = config.markers.markerInfoIcon.values.min.metric;
          this.metricUnit = config.markers.markerInfoIcon.units.metric.perimeter.m;
          this.imperialLength = config.markers.markerInfoIcon.values.min.imperial;
          this.imperialUnit = config.markers.markerInfoIcon.units.imperial.perimeter.feet;
        } else {
          this.metricLength = config.markers.markerInfoIcon.values.unknown.metric;
          this.metricUnit = config.markers.markerInfoIcon.units.unknownUnit;
          this.imperialLength = config.markers.markerInfoIcon.values.unknown.imperial;
          this.imperialUnit = config.markers.markerInfoIcon.units.unknownUnit;
        }
      } else if (length2 < 100) {
        this.metricLength = (Math.ceil(length2 / 10) * 10).toString();
        this.metricUnit = config.markers.markerInfoIcon.units.metric.perimeter.m;
      } else if (length2 < 500) {
        this.metricLength = (Math.ceil(length2 / 50) * 50).toString();
        this.metricUnit = config.markers.markerInfoIcon.units.metric.perimeter.m;
      } else if (length2 < 1e3) {
        this.metricLength = (Math.ceil(length2 / 100) * 100).toString();
        this.metricUnit = config.markers.markerInfoIcon.units.metric.perimeter.m;
      } else if (length2 < 1e4) {
        this.metricLength = (Math.ceil(length2 / 100) * 100 / 1e3).toFixed(1);
        this.metricUnit = config.markers.markerInfoIcon.units.metric.perimeter.km;
      } else {
        this.metricLength = (Math.ceil(length2 / 1e3) * 1e3 / 1e3).toString();
        this.metricUnit = config.markers.markerInfoIcon.units.metric.perimeter.km;
      }
      const inch = length2 / 0.0254;
      const feet = inch / 12;
      const yards = feet / 3;
      const miles = yards / 1760;
      if (length2 < 1e3 / 2.54) {
        this.imperialLength = (Math.ceil(feet / 10) * 10).toString();
        this.imperialUnit = config.markers.markerInfoIcon.units.imperial.perimeter.feet;
      } else if (length2 < 1e3 / 2.54 * 3) {
        this.imperialLength = (Math.ceil(yards / 10) * 10).toString();
        this.imperialUnit = config.markers.markerInfoIcon.units.imperial.perimeter.yards;
      } else if (length2 < 1609) {
        this.imperialLength = miles.toFixed(2);
        this.imperialUnit = config.markers.markerInfoIcon.units.imperial.perimeter.miles;
      } else if (length2 < 16093) {
        this.imperialLength = miles.toFixed(1);
        this.imperialUnit = config.markers.markerInfoIcon.units.imperial.perimeter.miles;
      } else {
        this.imperialLength = miles.toFixed(0);
        this.imperialUnit = config.markers.markerInfoIcon.units.imperial.perimeter.miles;
      }
    }
  }
}
class Area {
  constructor(sqrMeterArea, config) {
    __publicField(this, "metricArea", "");
    __publicField(this, "metricUnit", "");
    __publicField(this, "imperialArea", "");
    __publicField(this, "imperialUnit", "");
    const area2 = sqrMeterArea;
    const onlyMetrics = config.markers.markerInfoIcon.units.metric.onlyMetrics;
    if (area2 !== null || area2 !== void 0) {
      if (area2 === 0) {
        this.metricArea = "-";
        this.metricUnit = config.markers.markerInfoIcon.units.unknownUnit;
        this.imperialArea = "-";
        this.imperialUnit = config.markers.markerInfoIcon.units.unknownUnit;
      } else if (area2 < 1e4) {
        this.metricArea = Math.round(area2).toString();
        this.metricUnit = config.markers.markerInfoIcon.units.metric.area.m2;
      } else if (area2 < 1e5) {
        if (onlyMetrics) {
          this.metricArea = (area2 / 1e6).toFixed(2);
          this.metricUnit = config.markers.markerInfoIcon.units.metric.area.km2;
        } else {
          this.metricArea = (area2 / 1e3).toFixed(1);
          this.metricUnit = config.markers.markerInfoIcon.units.metric.area.daa;
        }
      } else if (area2 < 1e7) {
        if (onlyMetrics) {
          this.metricArea = (area2 / 1e6).toFixed(2);
          this.metricUnit = config.markers.markerInfoIcon.units.metric.area.km2;
        } else {
          this.metricArea = Math.round(area2 / 1e3).toString();
          this.metricUnit = config.markers.markerInfoIcon.units.metric.area.daa;
        }
      } else if (area2 < 1e8) {
        if (onlyMetrics) {
          this.metricArea = (area2 / 1e6).toFixed(1);
          this.metricUnit = config.markers.markerInfoIcon.units.metric.area.km2;
        } else {
          this.metricArea = Math.round(area2 / 1e4).toString();
          this.metricUnit = config.markers.markerInfoIcon.units.metric.area.ha;
        }
      } else {
        this.metricArea = Math.round(area2 / 1e6).toString();
        this.metricUnit = config.markers.markerInfoIcon.units.metric.area.km2;
      }
      const inch2 = area2 * 1550;
      const feet2 = inch2 * 69444e-7;
      const yards2 = feet2 * 0.11111;
      const acres = yards2 * 20661e-8;
      const miles2 = yards2 * 32283e-11;
      if (area2 < 92.9) {
        this.imperialArea = Math.round(feet2).toString();
        this.imperialUnit = config.markers.markerInfoIcon.units.imperial.area.feet2;
      } else if (area2 < 836.14) {
        this.imperialArea = yards2.toFixed(0);
        this.imperialUnit = config.markers.markerInfoIcon.units.imperial.area.yards2;
      } else if (area2 < 40469.6) {
        this.imperialArea = acres.toFixed(2);
        this.imperialUnit = config.markers.markerInfoIcon.units.imperial.area.acres;
      } else if (area2 < 404696) {
        this.imperialArea = acres.toFixed(1);
        this.imperialUnit = config.markers.markerInfoIcon.units.imperial.area.acres;
      } else if (area2 < 4046960) {
        this.imperialArea = acres.toFixed(0);
        this.imperialUnit = config.markers.markerInfoIcon.units.imperial.area.acres;
      } else if (area2 < 25900404) {
        this.imperialArea = miles2.toFixed(2);
        this.imperialUnit = config.markers.markerInfoIcon.units.imperial.area.miles2;
      } else if (area2 < 259004040) {
        this.imperialArea = miles2.toFixed(1);
        this.imperialUnit = config.markers.markerInfoIcon.units.imperial.area.miles2;
      } else {
        this.imperialArea = miles2.toFixed(0);
        this.imperialUnit = config.markers.markerInfoIcon.units.imperial.area.miles2;
      }
    }
  }
}
function createButtons(container, subContainer, config, onActivateToggle, onDrawClick, onSubtractClick, onEraseClick, onPointToPointClick) {
  const activate = L.DomUtil.create("a", "icon-activate", container);
  activate.href = "#";
  activate.title = "Activate";
  activate.innerHTML = '<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M5 17V7M5 17C3.89543 17 3 17.8954 3 19C3 20.1046 3.89543 21 5 21C6.10457 21 7 20.1046 7 19M5 17C6.10457 17 7 17.8954 7 19M5 7C6.10457 7 7 6.10457 7 5M5 7C3.89543 7 3 6.10457 3 5C3 3.89543 3.89543 3 5 3C6.10457 3 7 3.89543 7 5M7 5H17M17 5C17 6.10457 17.8954 7 19 7C20.1046 7 21 6.10457 21 5C21 3.89543 20.1046 3 19 3C17.8954 3 17 3.89543 17 5ZM7 19H17M17 19C17 20.1046 17.8954 21 19 21C20.1046 21 21 20.1046 21 19C21 17.8954 20.1046 17 19 17C17.8954 17 17 17.8954 17 19ZM17.9247 6.6737L15.1955 10.3776M15.1955 13.6223L17.9222 17.3223M16 12C16 13.1046 15.1046 14 14 14C12.8954 14 12 13.1046 12 12C12 10.8954 12.8954 10 14 10C15.1046 10 16 10.8954 16 12Z" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> </g></svg>';
  L.DomEvent.on(activate, "mousedown", L.DomEvent.stopPropagation);
  L.DomEvent.on(activate, "touchstart", L.DomEvent.stopPropagation);
  L.DomEvent.on(activate, "click", L.DomEvent.stop).on(activate, "click", onActivateToggle);
  if (config.modes.draw) {
    const draw = L.DomUtil.create("a", "icon-draw", subContainer);
    draw.href = "#";
    draw.title = "Draw";
    draw.innerHTML = '<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M15 7.49996L17.5 9.99996M7.5 20L19.25 8.24996C19.9404 7.5596 19.9404 6.44032 19.25 5.74996V5.74996C18.5596 5.0596 17.4404 5.05961 16.75 5.74996L5 17.5V20H7.5ZM7.5 20H15.8787C17.0503 20 18 19.0502 18 17.8786V17.8786C18 17.316 17.7765 16.7765 17.3787 16.3786L17 16M4.5 4.99996C6.5 2.99996 10 3.99996 10 5.99996C10 8.5 4 8.5 4 11C4 11.8759 4.53314 12.5256 5.22583 13" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> </g></svg>';
    L.DomEvent.on(draw, "mousedown", L.DomEvent.stopPropagation);
    L.DomEvent.on(draw, "touchstart", L.DomEvent.stopPropagation);
    L.DomEvent.on(draw, "click", L.DomEvent.stop).on(draw, "click", onDrawClick);
  }
  if (config.modes.subtract) {
    const subtract = L.DomUtil.create("a", "icon-subtract", subContainer);
    subtract.href = "#";
    subtract.title = "Subtract";
    subtract.innerHTML = '<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path fill-rule="evenodd" clip-rule="evenodd" d="M15.0722 3.9967L20.7508 9.83395L17.0544 13.5304L13.0758 17.5H21.0041V19H7.93503L4.00195 15.0669L15.0722 3.9967ZM10.952 17.5L15.4628 12.9994L11.8268 9.3634L6.12327 15.0669L8.55635 17.5H10.952Z" fill="#1F2328"></path> </g></svg>';
    L.DomEvent.on(subtract, "mousedown", L.DomEvent.stopPropagation);
    L.DomEvent.on(subtract, "touchstart", L.DomEvent.stopPropagation);
    L.DomEvent.on(subtract, "click", L.DomEvent.stop).on(subtract, "click", onSubtractClick);
  }
  if (config.modes.p2p && !isTouchDevice()) {
    const p2p = L.DomUtil.create("a", "icon-p2p", subContainer);
    p2p.href = "#";
    p2p.title = "Point to Point";
    p2p.innerHTML = '<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M5 17V7M5 17C3.89543 17 3 17.8954 3 19C3 20.1046 3.89543 21 5 21C6.10457 21 7 20.1046 7 19M5 17C6.10457 17 7 17.8954 7 19M5 7C6.10457 7 7 6.10457 7 5M5 7C3.89543 7 3 6.10457 3 5C3 3.89543 3.89543 3 5 3C6.10457 3 7 3.89543 7 5M7 5H17M17 5C17 6.10457 17.8954 7 19 7C20.1046 7 21 6.10457 21 5C21 3.89543 20.1046 3 19 3C17.8954 3 17 3.89543 17 5ZM7 19H17M17 19C17 20.1046 17.8954 21 19 21C20.1046 21 21 20.1046 21 19C21 17.8954 20.1046 17 19 17C17.8954 17 17 17.8954 17 19ZM17.9247 6.6737L15.1955 10.3776M15.1955 13.6223L17.9222 17.3223M16 12C16 13.1046 15.1046 14 14 14C12.8954 14 12 13.1046 12 12C12 10.8954 12.8954 10 14 10C15.1046 10 16 10.8954 16 12Z" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> </g></svg>';
    L.DomEvent.on(p2p, "mousedown", L.DomEvent.stopPropagation);
    L.DomEvent.on(p2p, "touchstart", L.DomEvent.stopPropagation);
    L.DomEvent.on(p2p, "click", L.DomEvent.stop).on(p2p, "click", onPointToPointClick);
  }
  if (config.modes.deleteAll) {
    const erase = L.DomUtil.create("a", "icon-erase", subContainer);
    erase.href = "#";
    erase.title = "Erase All";
    erase.innerHTML = `<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 21.0.2, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 48 48" style="enable-background:new 0 0 48 48;" xml:space="preserve">
<style type="text/css">
	.st0{fill:#000000}
	.st1{fill:#333333;fill-opacity:0;}
</style>
<title>trash</title>
<rect class="st1" width="48" height="48"/>
<polygon class="st0" points="26.6,10 26.6,7.8 21.4,7.8 21.4,10 12.6,10 12.6,12.8 35.4,12.8 35.4,10 "/>
<path class="st0" d="M35.4,15.4H12.6v4.3h1.8V37c0,1.1,0.9,2,2,2h15.2c1.1,0,2-0.9,2-2V19.7h1.8V15.4z M19.7,34.2c0,0.5-0.4,1-1,1
	c-0.5,0-1-0.4-1-1V22.6c0-0.5,0.4-1,1-1c0.5,0,1,0.4,1,1V34.2z M25.3,33.8c0,0.7-0.6,1.3-1.3,1.3c-0.7,0-1.3-0.6-1.3-1.3V23
	c0-0.7,0.6-1.3,1.3-1.3c0.7,0,1.3,0.6,1.3,1.3V33.8z M30.3,34.2c0,0.5-0.4,1-1,1c-0.5,0-1-0.4-1-1V22.6c0-0.5,0.4-1,1-1
	c0.5,0,1,0.4,1,1V34.2z"/>
</svg>`;
    L.DomEvent.on(erase, "mousedown", L.DomEvent.stopPropagation);
    L.DomEvent.on(erase, "touchstart", L.DomEvent.stopPropagation);
    L.DomEvent.on(erase, "click", L.DomEvent.stop).on(erase, "click", onEraseClick);
  }
}
class PolygonUtil {
  /**
   * Calculates the center of the polygon.
   * @param polygon Array of LatLng points.
   * @returns The center LatLng.
   */
  static getCenter(polygon2) {
    const pi2 = Math.PI;
    let x = 0;
    let y = 0;
    let z = 0;
    polygon2.forEach((v) => {
      let lat1 = v.lat;
      let lon1 = v.lng;
      lat1 = lat1 * pi2 / 180;
      lon1 = lon1 * pi2 / 180;
      x += Math.cos(lat1) * Math.cos(lon1);
      y += Math.cos(lat1) * Math.sin(lon1);
      z += Math.sin(lat1);
    });
    let lng = Math.atan2(y, x);
    const hyp = Math.sqrt(x * x + y * y);
    let lat = Math.atan2(z, hyp);
    lat = lat * 180 / pi2;
    lng = lng * 180 / pi2;
    const center2 = { lat, lng };
    return center2;
  }
  /**
   * Gets the southwest point of the polygon bounds.
   * @param polygon Array of LatLng points.
   * @returns The southwest LatLng.
   */
  static getSouthWest(polygon2) {
    const bounds = this.getBounds(polygon2);
    return bounds.getSouthWest();
  }
  static getNorthEast(polygon2) {
    const bounds = this.getBounds(polygon2);
    return bounds.getNorthEast();
  }
  static getNorthWest(polygon2) {
    const bounds = this.getBounds(polygon2);
    return bounds.getNorthWest();
  }
  static getSouthEast(polygon2) {
    const bounds = this.getBounds(polygon2);
    return bounds.getSouthEast();
  }
  static getNorth(polygon2) {
    const bounds = this.getBounds(polygon2);
    return bounds.getNorth();
  }
  static getSouth(polygon2) {
    const bounds = this.getBounds(polygon2);
    return bounds.getSouth();
  }
  static getWest(polygon2) {
    const bounds = this.getBounds(polygon2);
    return bounds.getWest();
  }
  static getEast(polygon2) {
    const bounds = this.getBounds(polygon2);
    return bounds.getEast();
  }
  static getSqmArea(polygon2) {
    const poly = new L.Polygon(polygon2);
    const geoJsonPoly = poly.toGeoJSON();
    const area2 = this.turfHelper.getPolygonArea(geoJsonPoly);
    return area2;
  }
  static getPerimeter(polygon2) {
    const poly = new L.Polygon(polygon2);
    const geoJsonPoly = poly.toGeoJSON();
    const perimeter = this.turfHelper.getPolygonPerimeter(geoJsonPoly);
    return perimeter * 1e3;
  }
  static getPolygonChecksum(polygon2) {
    const uniqueLatLngs = polygon2.filter((v, i, a) => {
      return a.indexOf(a.find((x) => x.lat === v.lat && x.lng === v.lng)) === i;
    });
    return uniqueLatLngs.reduce((a, b) => +a + +b.lat, 0) * uniqueLatLngs.reduce((a, b) => +a + +b.lng, 0);
  }
  static getMidPoint(point1, point2) {
    const midpoint2 = this.turfHelper.getMidpoint(point1, point2);
    const returnPoint = {
      lat: midpoint2.lat,
      lng: midpoint2.lng
    };
    return returnPoint;
  }
  static getBounds(polygon2) {
    const tmpLatLng = [];
    polygon2.forEach((ll) => {
      if (isNaN(ll.lat) || isNaN(ll.lng)) ;
      tmpLatLng.push(ll);
    });
    const polyLine = new L.Polyline(tmpLatLng);
    const bounds = polyLine.getBounds();
    return bounds;
  }
  /**
   * Calculates the center of mass of the polygon.
   * @param polygon A GeoJSON polygon.
   * @returns The center LatLng.
   */
  static getCenterOfMass(polygon2) {
    const centerOfMass2 = this.turfHelper.getCenterOfMass(polygon2);
    return {
      lat: centerOfMass2.geometry.coordinates[1],
      lng: centerOfMass2.geometry.coordinates[0]
    };
  }
}
__publicField(PolygonUtil, "turfHelper", new TurfHelper(defaultConfig));
class PolygonInfo {
  constructor(polygon2) {
    __publicField(this, "polygon", []);
    __publicField(this, "trashcanPoint", []);
    __publicField(this, "sqmArea", []);
    __publicField(this, "perimeter", []);
    if (!Array.isArray(polygon2)) {
      return;
    }
    if (polygon2.length > 0 && Array.isArray(polygon2[0]) && polygon2[0].length > 0 && typeof polygon2[0][0] === "object" && "lat" in polygon2[0][0]) {
      const coordinateArray = polygon2[0];
      this.trashcanPoint[0] = this.getTrashcanPoint(coordinateArray);
      this.sqmArea[0] = this.calculatePolygonArea(coordinateArray);
      this.perimeter[0] = this.calculatePolygonPerimeter(coordinateArray);
      this.polygon[0] = [coordinateArray];
      return;
    }
    if (polygon2.length > 0 && polygon2[0] && typeof polygon2[0] === "object" && "lat" in polygon2[0]) {
      const wrappedPolygon = [[polygon2]];
      this.trashcanPoint[0] = this.getTrashcanPoint(polygon2);
      this.sqmArea[0] = this.calculatePolygonArea(polygon2);
      this.perimeter[0] = this.calculatePolygonPerimeter(polygon2);
      this.polygon[0] = wrappedPolygon[0];
      return;
    }
    polygon2.forEach((polygons, i) => {
      if (!polygons || !Array.isArray(polygons)) {
        return;
      }
      if (!polygons[0] || !Array.isArray(polygons[0])) {
        return;
      }
      this.trashcanPoint[i] = this.getTrashcanPoint(polygons[0]);
      this.sqmArea[i] = this.calculatePolygonArea(polygons[0]);
      this.perimeter[i] = this.calculatePolygonPerimeter(polygons[0]);
      this.polygon[i] = polygons;
    });
  }
  setSqmArea(area2) {
    this.sqmArea[0] = area2;
  }
  getTrashcanPoint(polygon2) {
    if (!Array.isArray(polygon2) || polygon2.length === 0) {
      console.warn("getTrashcanPoint: Invalid polygon array:", polygon2);
      return { lat: 0, lng: 0 };
    }
    const validCoords = polygon2.filter(
      (coord) => coord && typeof coord === "object" && typeof coord.lat === "number" && typeof coord.lng === "number" && !isNaN(coord.lat) && !isNaN(coord.lng)
    );
    if (validCoords.length === 0) {
      console.warn("getTrashcanPoint: No valid coordinates found:", polygon2);
      return { lat: 0, lng: 0 };
    }
    const res = Math.max(...validCoords.map((o) => o.lat));
    const idx = validCoords.findIndex((o) => o.lat === res);
    if (idx === -1) {
      console.warn("getTrashcanPoint: Could not find max lat coordinate");
      return { lat: 0, lng: 0 };
    }
    let previousPoint;
    let nextPoint;
    if (idx > 0) {
      previousPoint = validCoords[idx - 1];
      if (idx < validCoords.length - 1) {
        nextPoint = validCoords[idx + 1];
      } else {
        nextPoint = validCoords[0];
      }
    } else {
      previousPoint = validCoords[validCoords.length - 1];
      nextPoint = validCoords[idx + 1];
    }
    if (!previousPoint || !nextPoint) {
      console.warn("getTrashcanPoint: Could not determine previous/next points");
      return validCoords[idx] || { lat: 0, lng: 0 };
    }
    const secondPoint = previousPoint.lng < nextPoint.lng ? previousPoint : nextPoint;
    const midpoint2 = PolygonUtil.getMidPoint(validCoords[idx], secondPoint);
    return midpoint2;
  }
  calculatePolygonArea(polygon2) {
    const area2 = PolygonUtil.getSqmArea(polygon2);
    return area2;
  }
  calculatePolygonPerimeter(polygon2) {
    const perimeter = PolygonUtil.getPerimeter(polygon2);
    return perimeter;
  }
}
class PolygonInformationService {
  constructor(mapStateService) {
    __publicField(this, "polygonInfoListeners", []);
    __publicField(this, "polygonDrawStateListeners", []);
    __publicField(this, "polygonInformationStorage", []);
    this.mapStateService = mapStateService;
  }
  onPolygonInfoUpdated(callback) {
    this.polygonInfoListeners.push(callback);
  }
  emitPolygonInfoUpdated() {
    for (const cb of this.polygonInfoListeners) {
      cb(this.polygonInformationStorage);
    }
  }
  onPolygonDrawStateUpdated(callback) {
    this.polygonDrawStateListeners.push(callback);
  }
  emitPolygonDrawStateUpdated(state) {
    for (const cb of this.polygonDrawStateListeners) {
      cb(state);
    }
  }
  // === Functions ===
  /**
   * Updates the polygons and notifies the map state service.
   */
  updatePolygons() {
    let newPolygons = null;
    if (this.polygonInformationStorage.length > 0) {
      newPolygons = [];
      this.polygonInformationStorage.forEach((v) => {
        const test = [];
        v.polygon.forEach((poly) => {
          poly.forEach((polygon2) => {
            const closedPolygon = [...polygon2];
            if (polygon2.length > 0 && polygon2[0].toString() !== polygon2[polygon2.length - 1].toString()) {
              closedPolygon.push(polygon2[0]);
            }
            test.push(closedPolygon);
          });
        });
        newPolygons.push(test);
      });
    }
    this.mapStateService.updatePolygons(newPolygons);
    this.saveCurrentState();
  }
  saveCurrentState() {
    this.emitPolygonInfoUpdated();
  }
  deleteTrashcan(polygon2) {
    const idx = this.polygonInformationStorage.findIndex((v) => v.polygon[0] === polygon2);
    if (idx !== -1) {
      this.polygonInformationStorage.splice(idx, 1);
      this.updatePolygons();
    }
  }
  deleteTrashCanOnMulti(polygon2) {
    let index = 0;
    this.polygonInformationStorage.forEach((v, i) => {
      const id = v.polygon.findIndex((poly) => poly.toString() === polygon2.toString());
      if (id >= 0) {
        index = i;
        v.trashcanPoint.splice(id, 1);
        v.sqmArea.splice(id, 1);
        v.perimeter.splice(id, 1);
        v.polygon.splice(id, 1);
      }
    });
    this.updatePolygons();
    if (this.polygonInformationStorage.length > 1) {
      this.polygonInformationStorage.splice(index, 1);
    }
  }
  deletePolygonInformationStorage() {
    this.polygonInformationStorage = [];
  }
  createPolygonInformationStorage(arrayOfFeatureGroups) {
    if (arrayOfFeatureGroups.length > 0) {
      arrayOfFeatureGroups.forEach((featureGroup) => {
        var _a2;
        const layers = (_a2 = featureGroup.getLayers) == null ? void 0 : _a2.call(featureGroup);
        if (layers == null ? void 0 : layers[0]) {
          const latLngs = layers[0].getLatLngs();
          const polyInfo = new PolygonInfo(latLngs);
          this.polygonInformationStorage.push(polyInfo);
        }
      });
      this.updatePolygons();
    }
  }
}
class MapStateService {
  constructor() {
    __publicField(this, "map", null);
    __publicField(this, "mapListeners", []);
  }
  // === Observer-API ===
  onMapUpdated(callback) {
    if (this.map) callback(this.map);
    this.mapListeners.push(callback);
  }
  emitMapUpdated() {
    if (this.map) {
      for (const cb of this.mapListeners) {
        cb(this.map);
      }
    }
  }
  // === Public API ===
  /**
   * Updates the current map state and notifies listeners.
   * @param map The Leaflet map instance.
   */
  updateMapState(map) {
    this.map = map;
    this.emitMapUpdated();
  }
  /**
   * Updates the polygons in the map state.
   * @param polygons Array of polygons.
   */
  updatePolygons(polygons) {
  }
}
class EventManager {
  constructor() {
    __publicField(this, "eventListeners", /* @__PURE__ */ new Map());
  }
  /**
   * Register an event listener.
   * @param event - The event to listen for.
   * @param callback - The callback to execute when the event is emitted.
   */
  on(event, callback) {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, []);
    }
    this.eventListeners.get(event).push(callback);
  }
  /**
   * Unregister an event listener.
   * @param event - The event to stop listening for.
   * @param callback - The specific callback to remove.
   */
  off(event, callback) {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      const index = listeners.indexOf(callback);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
  }
  /**
   * Emit an event.
   * @param event - The event to emit.
   * @param data - The data to pass to the event listeners.
   */
  emit(event, data) {
    var _a2;
    if (this.eventListeners.has(event)) {
      (_a2 = this.eventListeners.get(event)) == null ? void 0 : _a2.forEach((callback) => {
        callback(data);
      });
    }
  }
}
class ModeManager {
  constructor(config, eventManager) {
    __publicField(this, "state");
    __publicField(this, "config");
    __publicField(this, "eventManager");
    this.config = config;
    this.eventManager = eventManager;
    this.state = this.createInitialState();
  }
  /**
   * Create the initial interaction state
   */
  createInitialState() {
    return {
      // Core interactions - initially enabled based on config
      polygonDragging: this.config.modes.dragPolygons ?? false,
      markerDragging: this.config.modes.dragElbow ?? false,
      edgeClicking: true,
      // Generally always available when not drawing
      polygonClicking: true,
      // Drawing capabilities
      canStartDrawing: true,
      canCompletePolygon: false,
      // UI interactions - initially enabled
      mapDragging: true,
      mapZooming: true,
      mapDoubleClickZoom: true,
      // Mode-specific states
      currentMode: DrawMode.Off,
      isDrawingActive: false,
      isModifierKeyHeld: false,
      // Visual feedback
      showCrosshairCursor: false,
      showDragCursor: false
    };
  }
  /**
   * Update the interaction state when the draw mode changes
   */
  updateStateForMode(mode) {
    this.state.currentMode = mode;
    switch (mode) {
      case DrawMode.Off:
        this.setOffModeState();
        break;
      case DrawMode.Add:
        this.setDrawingModeState();
        break;
      case DrawMode.Subtract:
        this.setDrawingModeState();
        break;
      case DrawMode.PointToPoint:
        this.setPointToPointModeState();
        break;
    }
    this.state.isDrawingActive = mode !== DrawMode.Off;
    this.eventManager.emit("polydraw:mode:change", { mode });
  }
  /**
   * Set interaction state for Off mode (normal editing)
   */
  setOffModeState() {
    this.state.polygonDragging = this.config.modes.dragPolygons ?? false;
    this.state.markerDragging = this.config.modes.dragElbow ?? false;
    this.state.edgeClicking = true;
    this.state.polygonClicking = true;
    this.state.canStartDrawing = true;
    this.state.canCompletePolygon = false;
    this.state.mapDragging = true;
    this.state.mapZooming = true;
    this.state.mapDoubleClickZoom = true;
    this.state.showCrosshairCursor = false;
    this.state.showDragCursor = false;
  }
  /**
   * Set interaction state for drawing modes (Add, Subtract)
   */
  setDrawingModeState() {
    this.state.polygonDragging = false;
    this.state.markerDragging = false;
    this.state.edgeClicking = false;
    this.state.polygonClicking = false;
    this.state.canStartDrawing = true;
    this.state.canCompletePolygon = true;
    this.state.mapDragging = false;
    this.state.mapZooming = false;
    this.state.mapDoubleClickZoom = false;
    this.state.showCrosshairCursor = true;
    this.state.showDragCursor = false;
  }
  /**
   * Set interaction state for Point-to-Point mode
   */
  setPointToPointModeState() {
    this.state.polygonDragging = false;
    this.state.markerDragging = false;
    this.state.edgeClicking = false;
    this.state.polygonClicking = false;
    this.state.canStartDrawing = true;
    this.state.canCompletePolygon = true;
    this.state.mapDragging = false;
    this.state.mapZooming = false;
    this.state.mapDoubleClickZoom = false;
    this.state.showCrosshairCursor = true;
    this.state.showDragCursor = false;
  }
  /**
   * Update modifier key state
   */
  setModifierKeyState(isHeld) {
    this.state.isModifierKeyHeld = isHeld;
    if (this.state.currentMode === DrawMode.Off && isHeld) ;
  }
  /**
   * Check if a specific action is currently allowed
   */
  canPerformAction(action) {
    switch (action) {
      case "polygonDrag":
        return this.state.polygonDragging;
      case "markerDrag":
        return this.state.markerDragging;
      case "edgeClick":
        return this.state.edgeClicking;
      case "polygonClick":
        return this.state.polygonClicking;
      case "startDrawing":
        return this.state.canStartDrawing;
      case "completePolygon":
        return this.state.canCompletePolygon;
      case "mapDrag":
        return this.state.mapDragging;
      case "mapZoom":
        return this.state.mapZooming;
      case "mapDoubleClickZoom":
        return this.state.mapDoubleClickZoom;
      default:
        return false;
    }
  }
  /**
   * Check if any drawing mode is active
   */
  isInDrawingMode() {
    return this.state.isDrawingActive;
  }
  /**
   * Check if currently in Off mode (normal editing)
   */
  isInOffMode() {
    return this.state.currentMode === DrawMode.Off;
  }
  /**
   * Get the current draw mode
   */
  getCurrentMode() {
    return this.state.currentMode;
  }
  /**
   * Get read-only access to the current state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Check if crosshair cursor should be shown
   */
  shouldShowCrosshairCursor() {
    return this.state.showCrosshairCursor;
  }
  /**
   * Check if drag cursor should be shown
   */
  shouldShowDragCursor() {
    return this.state.showDragCursor;
  }
  /**
   * Update configuration and recalculate state
   */
  updateConfig(config) {
    this.config = config;
    this.updateStateForMode(this.state.currentMode);
  }
}
class PolygonDrawManager {
  constructor(dependencies) {
    __publicField(this, "turfHelper");
    __publicField(this, "map");
    __publicField(this, "config");
    __publicField(this, "modeManager");
    __publicField(this, "eventManager");
    __publicField(this, "tracer");
    // Point-to-Point drawing state
    __publicField(this, "p2pMarkers", []);
    __publicField(this, "isModifierKeyHeld", false);
    __publicField(this, "markerModifierHandlers", /* @__PURE__ */ new WeakMap());
    this.turfHelper = dependencies.turfHelper;
    this.map = dependencies.map;
    this.config = dependencies.config;
    this.modeManager = dependencies.modeManager;
    this.eventManager = dependencies.eventManager;
    this.tracer = dependencies.tracer;
  }
  /**
   * Handle mouse move during freehand drawing
   */
  mouseMove(event) {
    if ("latlng" in event && event.latlng) {
      this.tracer.addLatLng(event.latlng);
    } else if ("touches" in event && event.touches && event.touches.length > 0) {
      const latlng = this.map.containerPointToLatLng([
        event.touches[0].clientX,
        event.touches[0].clientY
      ]);
      this.tracer.addLatLng(latlng);
    }
  }
  /**
   * Handle mouse up/leave to complete freehand drawing
   */
  async mouseUpLeave(event) {
    const tracerGeoJSON = this.tracer.toGeoJSON();
    if (!tracerGeoJSON || !tracerGeoJSON.geometry || !tracerGeoJSON.geometry.coordinates || tracerGeoJSON.geometry.coordinates.length < 3) {
      return {
        success: false,
        error: "Not enough points to form a valid polygon. Event: " + JSON.stringify(event)
      };
    }
    let geoPos;
    try {
      geoPos = this.turfHelper.createPolygonFromTrace(tracerGeoJSON);
    } catch (error) {
      return {
        success: false,
        error: (error instanceof Error ? error.message : "Failed to create polygon from trace") + ". Event: " + JSON.stringify(event)
      };
    }
    if (!geoPos || !geoPos.geometry || !geoPos.geometry.coordinates || geoPos.geometry.coordinates.length === 0) {
      return {
        success: false,
        error: "Invalid polygon created from trace. Event: " + JSON.stringify(event)
      };
    }
    this.eventManager.emit("polydraw:polygon:created", {
      polygon: geoPos,
      mode: this.modeManager.getCurrentMode()
    });
    return {
      success: true,
      polygon: geoPos
    };
  }
  /**
   * Handle point-to-point click
   */
  /**
   * Set the modifier key status
   * @param isHeld - Whether the modifier key is held down
   */
  setModifierKey(isHeld) {
    this.isModifierKeyHeld = isHeld;
  }
  /**
   * Handle point-to-point click
   */
  handlePointToPointClick(clickLatLng) {
    if (!clickLatLng) {
      return;
    }
    if (this.p2pMarkers.length >= 3) {
      const firstPoint = this.p2pMarkers[0].getLatLng();
      const isClickingFirst = this.isClickingFirstPoint(clickLatLng, firstPoint);
      if (isClickingFirst) {
        this.completePointToPointPolygon();
        return;
      }
    }
    try {
      const isFirstMarker = this.p2pMarkers.length === 0;
      const markerClassName = isFirstMarker ? "leaflet-polydraw-p2p-marker leaflet-polydraw-p2p-first-marker" : "leaflet-polydraw-p2p-marker";
      const pointMarker = new L.Marker(clickLatLng, {
        icon: L.divIcon({
          className: markerClassName,
          iconSize: isFirstMarker ? [20, 20] : [16, 16]
        }),
        draggable: this.config.modes.dragElbow
      }).addTo(this.map);
      pointMarker.on("mousedown", (e) => {
        L.DomEvent.stopPropagation(e);
      });
      pointMarker.on("drag", () => {
        this.updateP2PTracer();
      });
      pointMarker.on("click", (e) => {
        if (this.isModifierKeyHeld && this.config.modes.edgeDeletion) {
          this.deleteP2PMarker(pointMarker);
          L.DomEvent.stopPropagation(e);
        }
      });
      pointMarker.on("mouseover", () => this.onMarkerHoverForEdgeDeletion(pointMarker, true));
      pointMarker.on("mouseout", () => this.onMarkerHoverForEdgeDeletion(pointMarker, false));
      if (isFirstMarker) {
        pointMarker.on("mouseover", () => {
          if (this.p2pMarkers.length >= 3) {
            const element = pointMarker.getElement();
            if (element) {
              element.style.backgroundColor = this.config.colors.p2p.closingMarker;
              element.style.borderColor = this.config.colors.p2p.closingMarker;
              element.style.cursor = "pointer";
              element.title = "Click to close polygon";
            }
          }
        });
        pointMarker.on("mouseout", () => {
          const element = pointMarker.getElement();
          if (element) {
            element.style.backgroundColor = "";
            element.style.borderColor = "";
            element.style.cursor = "";
            element.title = "";
          }
        });
        pointMarker.on("click", (e) => {
          if (this.isModifierKeyHeld && this.config.modes.edgeDeletion) {
            this.deleteP2PMarker(pointMarker);
            L.DomEvent.stopPropagation(e);
            return;
          }
          if (this.p2pMarkers.length >= 3) {
            L.DomEvent.stopPropagation(e);
            this.completePointToPointPolygon();
          }
        });
      }
      this.p2pMarkers.push(pointMarker);
      this.updateP2PTracer();
    } catch (error) {
    }
  }
  /**
   * Handle double-click to complete point-to-point polygon
   */
  handleDoubleClick(e) {
    if (this.modeManager.getCurrentMode() !== DrawMode.PointToPoint) {
      return;
    }
    if (this.p2pMarkers.length >= 3) {
      this.completePointToPointPolygon();
    }
  }
  /**
   * Complete point-to-point polygon drawing
   */
  completePointToPointPolygon() {
    const points = this.p2pMarkers.map((marker) => marker.getLatLng());
    if (points.length < 3) {
      return;
    }
    const closedPoints = [...points];
    const firstPoint = points[0];
    const lastPoint = points[points.length - 1];
    if (firstPoint.lat !== lastPoint.lat || firstPoint.lng !== lastPoint.lng) {
      closedPoints.push(firstPoint);
    }
    try {
      const coordinates = closedPoints.map((point2) => [point2.lng, point2.lat]);
      const geoPos = this.turfHelper.getMultiPolygon([[coordinates]]);
      this.clearP2pMarkers();
      this.resetTracer();
      this.eventManager.emit("polydraw:polygon:created", {
        polygon: geoPos,
        mode: DrawMode.PointToPoint,
        isPointToPoint: true
      });
    } catch (error) {
      console.warn("Error completing point-to-point polygon:", error);
      this.clearP2pMarkers();
      this.resetTracer();
    }
  }
  /**
   * Cancel point-to-point drawing
   */
  cancelPointToPointDrawing() {
    this.clearP2pMarkers();
    this.resetTracer();
    this.eventManager.emit("polydraw:draw:cancel", {
      mode: DrawMode.PointToPoint
    });
  }
  /**
   * Clear all P2P markers
   */
  clearP2pMarkers() {
    this.p2pMarkers.forEach((marker) => this.map.removeLayer(marker));
    this.p2pMarkers = [];
  }
  /**
   * Reset the tracer
   */
  resetTracer() {
    this.tracer.setLatLngs([]);
    try {
      this.tracer.setStyle({
        dashArray: null
      });
    } catch (error) {
    }
  }
  /**
   * Check if clicking on the first point to close polygon
   */
  isClickingFirstPoint(clickLatLng, firstPoint) {
    if (!firstPoint) return false;
    const zoom = this.map.getZoom();
    const baseTolerance = 5e-4;
    const tolerance = baseTolerance / Math.pow(2, Math.max(0, zoom - 10));
    const latDiff = Math.abs(clickLatLng.lat - firstPoint.lat);
    const lngDiff = Math.abs(clickLatLng.lng - firstPoint.lng);
    const isClicking = latDiff < tolerance && lngDiff < tolerance;
    return isClicking;
  }
  /**
   * Update the tracer polyline based on P2P markers
   */
  updateP2PTracer() {
    const latlngs = this.p2pMarkers.map((marker) => marker.getLatLng());
    this.tracer.setLatLngs(latlngs);
    if (this.p2pMarkers.length >= 2) {
      try {
        this.tracer.setStyle({
          color: this.config.colors.polyline,
          dashArray: "5, 5"
        });
      } catch (error) {
      }
    } else {
      try {
        this.tracer.setStyle({
          dashArray: null
        });
      } catch (error) {
      }
    }
  }
  /**
   * Delete a P2P marker
   */
  deleteP2PMarker(markerToDelete) {
    const markerIndex = this.p2pMarkers.findIndex((marker) => marker === markerToDelete);
    if (markerIndex > -1) {
      this.p2pMarkers.splice(markerIndex, 1);
      this.map.removeLayer(markerToDelete);
      this.updateP2PTracer();
      if (markerIndex === 0 && this.p2pMarkers.length > 0) {
        this.setupFirstMarker();
      }
    }
  }
  /**
   * Get current P2P markers (for external access)
   */
  getP2pMarkers() {
    return [...this.p2pMarkers];
  }
  /**
   * Check if currently in point-to-point drawing mode
   */
  isInPointToPointMode() {
    return this.modeManager.getCurrentMode() === DrawMode.PointToPoint;
  }
  /**
   * Get current tracer points count
   */
  getTracerPointsCount() {
    const points = this.tracer.getLatLngs();
    return points.length;
  }
  /**
   * Set up the first marker with special properties
   */
  setupFirstMarker() {
    if (this.p2pMarkers.length === 0) return;
    const firstMarker = this.p2pMarkers[0];
    const element = firstMarker.getElement();
    if (element) {
      element.classList.add("leaflet-polydraw-p2p-first-marker");
      firstMarker.setIcon(
        L.divIcon({
          className: "leaflet-polydraw-p2p-marker leaflet-polydraw-p2p-first-marker",
          iconSize: [20, 20]
        })
      );
    }
    firstMarker.off("mouseover");
    firstMarker.off("mouseout");
    firstMarker.off("click");
    firstMarker.on("mouseover", () => {
      if (this.p2pMarkers.length >= 3) {
        const element2 = firstMarker.getElement();
        if (element2) {
          element2.style.backgroundColor = this.config.colors.p2p.closingMarker;
          element2.style.borderColor = this.config.colors.p2p.closingMarker;
          element2.style.cursor = "pointer";
          element2.title = "Click to close polygon";
        }
      }
    });
    firstMarker.on("mouseout", () => {
      const element2 = firstMarker.getElement();
      if (element2) {
        element2.style.backgroundColor = "";
        element2.style.borderColor = "";
        element2.style.cursor = "";
        element2.title = "";
      }
    });
    firstMarker.on("click", (e) => {
      if (this.isModifierKeyHeld && this.config.modes.edgeDeletion) {
        this.deleteP2PMarker(firstMarker);
        L.DomEvent.stopPropagation(e);
        return;
      }
      if (this.p2pMarkers.length >= 3) {
        L.DomEvent.stopPropagation(e);
        this.completePointToPointPolygon();
      }
    });
  }
  /**
   * Handle marker hover for edge deletion feedback
   */
  onMarkerHoverForEdgeDeletion(marker, isHovering) {
    const element = marker.getElement();
    if (!element) return;
    if (isHovering) {
      const checkModifierAndUpdate = (e) => {
        if (this.isModifierKeyHeld && this.config.modes.edgeDeletion) {
          element.classList.add("edge-deletion-hover");
          try {
            const container = this.map.getContainer();
            container.style.cursor = "pointer";
          } catch (error) {
          }
        } else {
          element.classList.remove("edge-deletion-hover");
          try {
            const container = this.map.getContainer();
            container.style.cursor = "";
          } catch (error) {
          }
        }
      };
      this.markerModifierHandlers.set(marker, checkModifierAndUpdate);
      document.addEventListener("keydown", checkModifierAndUpdate);
      document.addEventListener("keyup", checkModifierAndUpdate);
      element.addEventListener("mousemove", checkModifierAndUpdate);
    } else {
      element.classList.remove("edge-deletion-hover");
      try {
        const container = this.map.getContainer();
        container.style.cursor = "";
      } catch (error) {
      }
      const handler = this.markerModifierHandlers.get(marker);
      if (handler) {
        document.removeEventListener("keydown", handler);
        document.removeEventListener("keyup", handler);
        element.removeEventListener("mousemove", handler);
        this.markerModifierHandlers.delete(marker);
      }
    }
  }
}
class PolygonGeometryManager {
  constructor(dependencies) {
    __publicField(this, "turfHelper");
    __publicField(this, "config");
    this.turfHelper = dependencies.turfHelper;
    this.config = dependencies.config;
  }
  /**
   * Check if two polygons intersect using multiple detection methods
   */
  checkPolygonIntersection(polygon1, polygon2) {
    try {
      const poly1WithinPoly2 = this.turfHelper.isPolygonCompletelyWithin(polygon1, polygon2);
      const poly2WithinPoly1 = this.turfHelper.isPolygonCompletelyWithin(polygon2, polygon1);
      if (poly1WithinPoly2 || poly2WithinPoly1) {
        return true;
      }
    } catch (error) {
    }
    try {
      const result = this.turfHelper.polygonIntersect(polygon1, polygon2);
      if (result) {
        return true;
      }
    } catch (error) {
    }
    try {
      const intersection3 = this.turfHelper.getIntersection(polygon1, polygon2);
      if (intersection3 && intersection3.geometry && (intersection3.geometry.type === "Polygon" || intersection3.geometry.type === "MultiPolygon")) {
        const intersectionArea2 = this.turfHelper.getPolygonArea(intersection3);
        if (intersectionArea2 > 1e-6) {
          return true;
        }
      }
    } catch (error) {
    }
    try {
      const coords1 = this.turfHelper.getCoords(polygon1);
      const coords2 = this.turfHelper.getCoords(polygon2);
      for (const ring2 of coords2) {
        for (const coord of ring2[0]) {
          const point2 = {
            type: "Feature",
            geometry: { type: "Point", coordinates: coord },
            properties: {}
          };
          if (this.turfHelper.isPointInsidePolygon(point2, polygon1)) {
            return true;
          }
        }
      }
      for (const ring1 of coords1) {
        for (const coord of ring1[0]) {
          const point2 = {
            type: "Feature",
            geometry: { type: "Point", coordinates: coord },
            properties: {}
          };
          if (this.turfHelper.isPointInsidePolygon(point2, polygon2)) {
            return true;
          }
        }
      }
    } catch (error) {
    }
    return false;
  }
  /**
   * Perform union operation on multiple polygons
   */
  unionPolygons(polygons, newPolygon) {
    try {
      let result = newPolygon;
      for (const polygon2 of polygons) {
        const union3 = this.turfHelper.union(result, polygon2);
        result = union3;
      }
      return {
        success: true,
        result
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error in unionPolygons"
      };
    }
  }
  /**
   * Perform subtraction operation
   */
  subtractPolygon(existingPolygon, subtractPolygon) {
    try {
      const result = this.turfHelper.polygonDifference(existingPolygon, subtractPolygon);
      if (result) {
        const coords = this.turfHelper.getCoords(result);
        const results = [];
        for (const value of coords) {
          results.push(this.turfHelper.getMultiPolygon([value]));
        }
        return {
          success: true,
          results
        };
      } else {
        return {
          success: true,
          results: []
        };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error in subtractPolygon"
      };
    }
  }
  /**
   * Simplify a polygon by removing every other point
   */
  simplifyPolygon(polygon2) {
    var _a2, _b2;
    try {
      const coords = this.turfHelper.getCoords(polygon2);
      if (!coords || coords.length === 0) {
        return { success: false, error: "Invalid polygon coordinates" };
      }
      const processHoles = ((_b2 = (_a2 = this.config.menuOperations) == null ? void 0 : _a2.simplify) == null ? void 0 : _b2.processHoles) ?? true;
      const simplifiedCoords = coords.map((ring) => {
        const simplifiedRings = [];
        for (let ringIndex = 0; ringIndex < ring.length; ringIndex++) {
          const currentRing = ring[ringIndex];
          const isOuterRing = ringIndex === 0;
          if (isOuterRing || processHoles) {
            if (currentRing.length <= 4) {
              simplifiedRings.push(currentRing);
              continue;
            }
            const simplified = [];
            for (let i = 0; i < currentRing.length; i += 2) {
              simplified.push(currentRing[i]);
            }
            const firstPoint = simplified[0];
            const lastPoint = simplified[simplified.length - 1];
            if (firstPoint[0] !== lastPoint[0] || firstPoint[1] !== lastPoint[1]) {
              simplified.push(firstPoint);
            }
            if (simplified.length < 4) {
              simplifiedRings.push(currentRing);
            } else {
              simplifiedRings.push(simplified);
            }
          } else {
            simplifiedRings.push(currentRing);
          }
        }
        return simplifiedRings;
      });
      const result = this.turfHelper.getMultiPolygon(simplifiedCoords);
      return {
        success: true,
        result: this.turfHelper.getTurfPolygon(result)
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error in simplifyPolygon"
      };
    }
  }
  /**
   * Convert polygon to bounding box
   */
  convertToBoundingBox(polygon2) {
    var _a2, _b2;
    try {
      const coords = this.turfHelper.getCoords(polygon2);
      if (!coords || coords.length === 0) {
        return { success: false, error: "Invalid polygon coordinates" };
      }
      const processHoles = ((_b2 = (_a2 = this.config.menuOperations) == null ? void 0 : _a2.bbox) == null ? void 0 : _b2.processHoles) ?? true;
      if (!processHoles) {
        const result2 = this.turfHelper.convertToBoundingBoxPolygon(polygon2);
        return {
          success: true,
          result: this.turfHelper.getTurfPolygon(result2)
        };
      }
      const bboxCoords = coords.map((ring) => {
        const bboxRings = [];
        for (let ringIndex = 0; ringIndex < ring.length; ringIndex++) {
          const currentRing = ring[ringIndex];
          let minLat = Infinity;
          let maxLat = -Infinity;
          let minLng = Infinity;
          let maxLng = -Infinity;
          for (const coord of currentRing) {
            if (Array.isArray(coord) && coord.length >= 2) {
              const lng = coord[0];
              const lat = coord[1];
              if (typeof lng === "number" && typeof lat === "number" && !isNaN(lng) && !isNaN(lat)) {
                minLng = Math.min(minLng, lng);
                maxLng = Math.max(maxLng, lng);
                minLat = Math.min(minLat, lat);
                maxLat = Math.max(maxLat, lat);
              }
            }
          }
          if (minLat !== Infinity && maxLat !== -Infinity && minLng !== Infinity && maxLng !== -Infinity) {
            const rectangularRing = [
              [minLng, minLat],
              // Bottom-left
              [minLng, maxLat],
              // Top-left
              [maxLng, maxLat],
              // Top-right
              [maxLng, minLat],
              // Bottom-right
              [minLng, minLat]
              // Close the ring
            ];
            bboxRings.push(rectangularRing);
          } else {
            bboxRings.push(currentRing);
          }
        }
        return bboxRings;
      });
      const result = this.turfHelper.getMultiPolygon(bboxCoords);
      return {
        success: true,
        result: this.turfHelper.getTurfPolygon(result)
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error in convertToBoundingBox"
      };
    }
  }
  /**
   * Apply bezier curve to polygon
   */
  bezierifyPolygon(polygon2) {
    try {
      const coords = this.turfHelper.getCoords(polygon2);
      const result = this.turfHelper.getBezierMultiPolygon(coords);
      return {
        success: true,
        result: this.turfHelper.getTurfPolygon(result)
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error in bezierifyPolygon"
      };
    }
  }
  /**
   * Double the elbows of a polygon
   */
  doubleElbowsPolygon(polygon2) {
    var _a2, _b2;
    try {
      const coords = this.turfHelper.getCoords(polygon2);
      if (!coords || coords.length === 0) {
        return { success: false, error: "Invalid polygon coordinates" };
      }
      const processHoles = ((_b2 = (_a2 = this.config.menuOperations) == null ? void 0 : _a2.doubleElbows) == null ? void 0 : _b2.processHoles) ?? true;
      const doubleElbowCoords = coords.map((ring) => {
        const processedRings = [];
        for (let ringIndex = 0; ringIndex < ring.length; ringIndex++) {
          const currentRing = ring[ringIndex];
          const isOuterRing = ringIndex === 0;
          if (isOuterRing || processHoles) {
            const latlngs = currentRing.map((coord) => ({ lat: coord[1], lng: coord[0] }));
            const doubleLatLngs = this.turfHelper.getDoubleElbowLatLngs(latlngs);
            const doubledCoords = doubleLatLngs.map(
              (latlng) => [latlng.lng, latlng.lat]
            );
            processedRings.push(doubledCoords);
          } else {
            processedRings.push(currentRing);
          }
        }
        return processedRings;
      });
      const result = this.turfHelper.getMultiPolygon(doubleElbowCoords);
      return {
        success: true,
        result: this.turfHelper.getTurfPolygon(result)
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error in doubleElbowsPolygon"
      };
    }
  }
  /**
   * Helper method to get polygon center
   */
  getPolygonCenter(polygon2) {
    try {
      if (!polygon2 || !polygon2.geometry || !polygon2.geometry.coordinates) {
        return null;
      }
      let coordinates;
      if (polygon2.geometry.type === "Polygon") {
        coordinates = polygon2.geometry.coordinates[0];
      } else if (polygon2.geometry.type === "MultiPolygon") {
        coordinates = polygon2.geometry.coordinates[0][0];
      } else {
        return null;
      }
      if (!Array.isArray(coordinates) || coordinates.length === 0) {
        return null;
      }
      let latSum = 0;
      let lngSum = 0;
      let count = 0;
      for (const coord of coordinates) {
        if (Array.isArray(coord) && coord.length >= 2) {
          const lng = coord[0];
          const lat = coord[1];
          if (typeof lng === "number" && typeof lat === "number" && !isNaN(lng) && !isNaN(lat)) {
            lngSum += lng;
            latSum += lat;
            count++;
          }
        }
      }
      if (count === 0) {
        return null;
      }
      return {
        lat: latSum / count,
        lng: lngSum / count
      };
    } catch (error) {
      return null;
    }
  }
  /**
   * Helper method to get bounding box from polygon
   */
  getBoundingBox(polygon2) {
    try {
      if (!polygon2 || !polygon2.geometry || !polygon2.geometry.coordinates) {
        return null;
      }
      let coordinates;
      if (polygon2.geometry.type === "Polygon") {
        coordinates = polygon2.geometry.coordinates[0];
      } else if (polygon2.geometry.type === "MultiPolygon") {
        coordinates = polygon2.geometry.coordinates[0][0];
      } else {
        return null;
      }
      if (!Array.isArray(coordinates) || coordinates.length === 0) {
        return null;
      }
      let minLat = Infinity;
      let maxLat = -Infinity;
      let minLng = Infinity;
      let maxLng = -Infinity;
      for (const coord of coordinates) {
        if (Array.isArray(coord) && coord.length >= 2) {
          const lng = coord[0];
          const lat = coord[1];
          if (typeof lng === "number" && typeof lat === "number" && !isNaN(lng) && !isNaN(lat)) {
            minLng = Math.min(minLng, lng);
            maxLng = Math.max(maxLng, lng);
            minLat = Math.min(minLat, lat);
            maxLat = Math.max(maxLat, lat);
          }
        }
      }
      if (minLat === Infinity || maxLat === -Infinity || minLng === Infinity || maxLng === -Infinity) {
        return null;
      }
      return { minLat, maxLat, minLng, maxLng };
    } catch (error) {
      return null;
    }
  }
}
class IconFactory {
  /**
   * Creates a DivIcon with the given class names.
   * @param classNames Array of class names to apply.
   * @returns A Leaflet DivIcon.
   */
  static createDivIcon(classNames) {
    const classes = classNames.join(" ");
    return L.divIcon({ className: classes });
  }
}
class PolygonInteractionManager {
  constructor(dependencies, featureGroupAccess) {
    __publicField(this, "markerFeatureGroupMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "markerModifierHandlers", /* @__PURE__ */ new WeakMap());
    __publicField(this, "_activeMarker", null);
    __publicField(this, "isDraggingMarker", false);
    __publicField(this, "turfHelper");
    __publicField(this, "polygonInformation");
    __publicField(this, "map");
    __publicField(this, "config");
    __publicField(this, "modeManager");
    __publicField(this, "eventManager");
    // Polygon drag state
    __publicField(this, "currentDragPolygon", null);
    __publicField(this, "currentModifierDragMode", false);
    __publicField(this, "isModifierKeyHeld", false);
    __publicField(this, "_openMenuPopup", null);
    // Read-only access to feature groups
    __publicField(this, "getFeatureGroups");
    __publicField(this, "addFeatureGroup");
    __publicField(this, "removeFeatureGroup");
    // Polygon dragging methods
    __publicField(this, "onPolygonMouseMove", (e) => {
      if (!this.currentDragPolygon || !this.currentDragPolygon._polydrawDragData.isDragging) return;
      const polygon2 = this.currentDragPolygon;
      const dragData = polygon2._polydrawDragData;
      const eventToCheck = e.originalEvent && "metaKey" in e.originalEvent ? e.originalEvent : e;
      const currentModifierState = this.detectDragSubtractModifierKey(eventToCheck);
      if (currentModifierState !== this.currentModifierDragMode) {
        this.handleModifierToggleDuringDrag(eventToCheck);
      }
      const startPos = dragData.startPosition;
      const currentPos = e.latlng;
      const offsetLat = currentPos.lat - startPos.lat;
      const offsetLng = currentPos.lng - startPos.lng;
      const newLatLngs = this.offsetPolygonCoordinates(dragData.startLatLngs, offsetLat, offsetLng);
      polygon2.setLatLngs(newLatLngs);
      this.updateMarkersAndHoleLinesDuringDrag(polygon2, offsetLat, offsetLng);
    });
    __publicField(this, "onPolygonMouseUp", (e) => {
      if (!this.currentDragPolygon || !this.currentDragPolygon._polydrawDragData.isDragging) return;
      const polygon2 = this.currentDragPolygon;
      const dragData = polygon2._polydrawDragData;
      dragData.isDragging = false;
      this.map.off("mousemove", this.onPolygonMouseMove, this);
      this.map.off("mouseup", this.onPolygonMouseUp, this);
      if (this.map.dragging) {
        this.map.dragging.enable();
      }
      try {
        const container = this.map.getContainer();
        container.style.cursor = "";
      } catch (error) {
      }
      this.updatePolygonAfterDrag(polygon2);
      if (polygon2._polydrawOriginalMarkerPositions) {
        polygon2._polydrawOriginalMarkerPositions.clear();
        delete polygon2._polydrawOriginalMarkerPositions;
      }
      if (polygon2._polydrawOriginalHoleLinePositions) {
        polygon2._polydrawOriginalHoleLinePositions.clear();
        delete polygon2._polydrawOriginalHoleLinePositions;
      }
      if (polygon2._polydrawCurrentDragSession) {
        delete polygon2._polydrawCurrentDragSession;
      }
      this.currentDragPolygon = null;
    });
    __publicField(this, "onMarkerHoverForEdgeDeletionEvent", (e) => {
      if (!this.isModifierKeyHeld) return;
      const element = e.target;
      if (element) {
        element.style.backgroundColor = this.config.colors.edgeDeletion.hover;
        element.style.borderColor = this.config.colors.edgeDeletion.hover;
        element.classList.add("edge-deletion-hover");
      }
    });
    __publicField(this, "onMarkerLeaveForEdgeDeletionEvent", (e) => {
      const element = e.target;
      if (element) {
        element.style.backgroundColor = "";
        element.style.borderColor = "";
        element.classList.remove("edge-deletion-hover");
      }
    });
    this.turfHelper = dependencies.turfHelper;
    this.polygonInformation = dependencies.polygonInformation;
    this.map = dependencies.map;
    this.config = dependencies.config;
    this.modeManager = dependencies.modeManager;
    this.eventManager = dependencies.eventManager;
    this.getFeatureGroups = featureGroupAccess.getFeatureGroups;
    this.addFeatureGroup = featureGroupAccess.addFeatureGroup;
    this.removeFeatureGroup = featureGroupAccess.removeFeatureGroup;
  }
  /**
   * Add markers to a polygon feature group
   */
  addMarkers(latlngs, featureGroup) {
    let menuMarkerIdx = this.getMarkerIndex(latlngs, this.config.markers.markerMenuIcon.position);
    let deleteMarkerIdx = this.getMarkerIndex(
      latlngs,
      this.config.markers.markerDeleteIcon.position
    );
    let infoMarkerIdx = this.getMarkerIndex(latlngs, this.config.markers.markerInfoIcon.position);
    const separatedIndices = this.ensureMarkerSeparation(latlngs.length, {
      menu: { index: menuMarkerIdx, enabled: this.config.markers.menuMarker },
      delete: { index: deleteMarkerIdx, enabled: this.config.markers.deleteMarker },
      info: { index: infoMarkerIdx, enabled: this.config.markers.infoMarker }
    });
    menuMarkerIdx = separatedIndices.menu;
    deleteMarkerIdx = separatedIndices.delete;
    infoMarkerIdx = separatedIndices.info;
    latlngs.forEach((latlng, i) => {
      let iconClasses = this.config.markers.markerIcon.styleClasses;
      if (i === menuMarkerIdx && this.config.markers.menuMarker) {
        iconClasses = this.config.markers.markerMenuIcon.styleClasses;
      }
      if (i === deleteMarkerIdx && this.config.markers.deleteMarker) {
        iconClasses = this.config.markers.markerDeleteIcon.styleClasses;
      }
      if (i === infoMarkerIdx && this.config.markers.infoMarker) {
        iconClasses = this.config.markers.markerInfoIcon.styleClasses;
      }
      const processedClasses = Array.isArray(iconClasses) ? iconClasses : [iconClasses];
      const isSpecialMarker = i === menuMarkerIdx && this.config.markers.menuMarker || i === deleteMarkerIdx && this.config.markers.deleteMarker || i === infoMarkerIdx && this.config.markers.infoMarker;
      const marker = new L.Marker(latlng, {
        icon: this.createDivIcon(processedClasses),
        draggable: this.config.modes.dragElbow,
        title: this.config.markers.coordsTitle ? this.getLatLngInfoString(latlng) : "",
        zIndexOffset: this.config.markers.markerIcon.zIndexOffset ?? this.config.markers.zIndexOffset
      });
      featureGroup.addLayer(marker).addTo(this.map);
      this.markerFeatureGroupMap.set(marker, featureGroup);
      marker.on("add", () => {
        const el2 = marker.getElement();
        if (el2) el2.style.pointerEvents = "auto";
      });
      marker.on("click", (e) => {
        var _a2, _b2;
        if (this.isDraggingMarker) {
          (_b2 = (_a2 = e.originalEvent) == null ? void 0 : _a2.stopPropagation) == null ? void 0 : _b2.call(_a2);
          L.DomEvent.stopPropagation(e);
        }
      });
      marker.on("dragstart", () => {
        this.isDraggingMarker = true;
        this._activeMarker = marker;
      });
      marker.on("dragend", (e) => {
        const fg = this.markerFeatureGroupMap.get(marker);
        if (this.modeManager.canPerformAction("markerDrag") && fg) {
          this.markerDragEnd(fg);
        }
        this._activeMarker = null;
        L.DomEvent.stopPropagation(e);
        setTimeout(() => {
          this.isDraggingMarker = false;
        }, 10);
      });
      const el = marker.getElement();
      if (el) {
        el.addEventListener(
          "touchstart",
          (e) => {
            e.stopPropagation();
          },
          { passive: true }
        );
        el.addEventListener("touchend", (e) => {
          e.preventDefault();
          e.stopPropagation();
          marker.fire("click");
          if (this.isDraggingMarker && !isSpecialMarker) {
            const fg = this.markerFeatureGroupMap.get(marker);
            if (this.modeManager.canPerformAction("markerDrag") && fg) {
              this.markerDragEnd(fg);
            }
          }
          this._activeMarker = null;
        });
      }
      if (i === menuMarkerIdx || i === deleteMarkerIdx || i === infoMarkerIdx) {
        const element = marker.getElement();
        if (element) {
          element.style.zIndex = "10000";
        }
      }
      if (this.config.modes.dragElbow) {
        const createDragHandler = (fg) => () => {
          if (this.modeManager.canPerformAction("markerDrag")) {
            this.markerDrag(fg);
          }
        };
        marker.on("drag", createDragHandler(featureGroup));
      }
      if (i === menuMarkerIdx && this.config.markers.menuMarker) {
        marker.options.zIndexOffset = this.config.markers.markerMenuIcon.zIndexOffset ?? this.config.markers.zIndexOffset;
        marker.on("click", () => {
          const polygonGeoJSON = this.getPolygonGeoJSONFromFeatureGroup(featureGroup);
          const centerOfMass2 = PolygonUtil.getCenterOfMass(polygonGeoJSON);
          const menuPopup = this.generateMenuMarkerPopup(latlngs, featureGroup);
          menuPopup.setLatLng(centerOfMass2).openOn(this.map);
        });
        marker.on("popupopen", (e) => {
          const popup = e.popup;
          const popupContent = popup.getElement();
          if (!popupContent) return;
          setTimeout(() => {
            const mapContainer = this.map.getContainer();
            const mapBounds = mapContainer.getBoundingClientRect();
            const popupBounds = popupContent.getBoundingClientRect();
            if (popupBounds.left < mapBounds.left) {
              popupContent.style.transform = `translateX(${mapBounds.left - popupBounds.left}px)`;
            } else if (popupBounds.right > mapBounds.right) {
              popupContent.style.transform = `translateX(${mapBounds.right - popupBounds.right}px)`;
            }
          }, 0);
          const container2 = this.map.getContainer();
          if (container2) {
            container2.style.touchAction = "manipulation";
          }
        });
        marker.on("popupclose", () => {
          const container2 = this.map.getContainer();
          if (container2) {
            container2.style.touchAction = "";
          }
        });
      }
      if (i === infoMarkerIdx && this.config.markers.infoMarker) {
        const polygonGeoJSON = this.getPolygonGeoJSONFromFeatureGroup(featureGroup);
        const area2 = this.turfHelper.getPolygonArea(polygonGeoJSON);
        const perimeter = this.getTotalPolygonPerimeter(polygonGeoJSON);
        marker.options.zIndexOffset = this.config.markers.markerInfoIcon.zIndexOffset ?? this.config.markers.zIndexOffset;
        marker.on("click", () => {
          const infoPopup = this.generateInfoMarkerPopup(area2, perimeter);
          const centerOfMass2 = PolygonUtil.getCenterOfMass(polygonGeoJSON);
          infoPopup.setLatLng(centerOfMass2).openOn(this.map);
        });
        marker.on("popupopen", (e) => {
          const popup = e.popup;
          const popupContent = popup.getElement();
          if (!popupContent) return;
          setTimeout(() => {
            const mapContainer = this.map.getContainer();
            const mapBounds = mapContainer.getBoundingClientRect();
            const popupBounds = popupContent.getBoundingClientRect();
            if (popupBounds.left < mapBounds.left) {
              popupContent.style.transform = `translateX(${mapBounds.left - popupBounds.left}px)`;
            } else if (popupBounds.right > mapBounds.right) {
              popupContent.style.transform = `translateX(${mapBounds.right - popupBounds.right}px)`;
            }
          }, 0);
          const container2 = this.map.getContainer();
          if (container2) {
            container2.style.touchAction = "manipulation";
          }
        });
        marker.on("popupclose", () => {
          const container2 = this.map.getContainer();
          if (container2) {
            container2.style.touchAction = "";
          }
        });
      }
      marker.on("mousedown", (e) => {
        if (!this.modeManager.isInOffMode()) {
          L.DomEvent.stopPropagation(e);
          this.map.fire("mousedown", e);
        }
        this._activeMarker = marker;
      });
      marker.on("click", (e) => {
        if (this.modeManager.isInOffMode()) {
          if (this.isEdgeDeletionModifierKeyPressed(e.originalEvent)) {
            const polygonLayer = featureGroup.getLayers().find((layer) => layer instanceof L.Polygon);
            if (polygonLayer) {
              this.elbowClicked(e, polygonLayer, marker.getLatLng());
            }
          } else {
            if (i === deleteMarkerIdx && this.config.markers.deleteMarker) {
              this.map.closePopup();
              this.removeFeatureGroup(featureGroup);
              this.polygonInformation.createPolygonInformationStorage(this.getFeatureGroups());
              this.eventManager.emit("polydraw:polygon:deleted", void 0);
            }
          }
        }
      });
      marker.on("mouseover", () => this.onMarkerHoverForEdgeDeletion(marker, true));
      marker.on("mouseout", () => this.onMarkerHoverForEdgeDeletion(marker, false));
    });
    const container = this.map.getContainer();
    if (container) {
      container.style.touchAction = "manipulation";
    }
  }
  /**
   * Add hole markers to a polygon feature group, with configurable special markers.
   */
  addHoleMarkers(latlngs, featureGroup) {
    var _a2, _b2, _c;
    const holeMenuEnabled = ((_a2 = this.config.markers.holeMarkers) == null ? void 0 : _a2.menuMarker) ?? false;
    const holeDeleteEnabled = ((_b2 = this.config.markers.holeMarkers) == null ? void 0 : _b2.deleteMarker) ?? false;
    const holeInfoEnabled = ((_c = this.config.markers.holeMarkers) == null ? void 0 : _c.infoMarker) ?? false;
    let menuMarkerIdx = this.getMarkerIndex(latlngs, this.config.markers.markerMenuIcon.position);
    let deleteMarkerIdx = this.getMarkerIndex(
      latlngs,
      this.config.markers.markerDeleteIcon.position
    );
    let infoMarkerIdx = this.getMarkerIndex(latlngs, this.config.markers.markerInfoIcon.position);
    const separatedIndices = this.ensureMarkerSeparation(latlngs.length, {
      menu: { index: menuMarkerIdx, enabled: holeMenuEnabled },
      delete: { index: deleteMarkerIdx, enabled: holeDeleteEnabled },
      info: { index: infoMarkerIdx, enabled: holeInfoEnabled }
    });
    menuMarkerIdx = separatedIndices.menu;
    deleteMarkerIdx = separatedIndices.delete;
    infoMarkerIdx = separatedIndices.info;
    latlngs.forEach((latlng, i) => {
      let iconClasses = this.config.markers.holeIcon.styleClasses;
      if (i === menuMarkerIdx && holeMenuEnabled) {
        iconClasses = this.config.markers.markerMenuIcon.styleClasses;
      }
      if (i === deleteMarkerIdx && holeDeleteEnabled) {
        iconClasses = this.config.markers.markerDeleteIcon.styleClasses;
      }
      if (i === infoMarkerIdx && holeInfoEnabled) {
        iconClasses = this.config.markers.markerInfoIcon.styleClasses;
      }
      const processedClasses = Array.isArray(iconClasses) ? iconClasses : [iconClasses];
      const isSpecialMarker = i === menuMarkerIdx && holeMenuEnabled || i === deleteMarkerIdx && holeDeleteEnabled || i === infoMarkerIdx && holeInfoEnabled;
      const marker = new L.Marker(latlng, {
        icon: this.createDivIcon(processedClasses),
        draggable: this.config.modes.dragElbow,
        title: this.config.markers.coordsTitle ? this.getLatLngInfoString(latlng) : "",
        zIndexOffset: this.config.markers.holeIcon.zIndexOffset ?? this.config.markers.zIndexOffset
      });
      featureGroup.addLayer(marker).addTo(this.map);
      this.markerFeatureGroupMap.set(marker, featureGroup);
      marker.on("add", () => {
        const el2 = marker.getElement();
        if (el2) el2.style.pointerEvents = "auto";
      });
      marker.on("click", (e) => {
        var _a3, _b3;
        if (this.isDraggingMarker) {
          (_b3 = (_a3 = e.originalEvent) == null ? void 0 : _a3.stopPropagation) == null ? void 0 : _b3.call(_a3);
          L.DomEvent.stopPropagation(e);
        }
      });
      marker.on("dragstart", () => {
        this.isDraggingMarker = true;
        this._activeMarker = marker;
      });
      marker.on("dragend", (e) => {
        const fg = this.markerFeatureGroupMap.get(marker);
        if (this.modeManager.canPerformAction("markerDrag") && fg) {
          this.markerDragEnd(fg);
        }
        this._activeMarker = null;
        L.DomEvent.stopPropagation(e);
        setTimeout(() => {
          this.isDraggingMarker = false;
        }, 10);
      });
      const el = marker.getElement();
      if (el) {
        el.addEventListener(
          "touchstart",
          (e) => {
            e.stopPropagation();
          },
          { passive: true }
        );
        el.addEventListener("touchend", (e) => {
          e.preventDefault();
          e.stopPropagation();
          marker.fire("click");
          if (this.isDraggingMarker && !isSpecialMarker) {
            const fg = this.markerFeatureGroupMap.get(marker);
            if (this.modeManager.canPerformAction("markerDrag") && fg) {
              this.markerDragEnd(fg);
            }
          }
          this._activeMarker = null;
        });
      }
      if (i === menuMarkerIdx || i === deleteMarkerIdx || i === infoMarkerIdx) {
        const element = marker.getElement();
        if (element) {
          element.style.zIndex = "10000";
        }
      }
      if (this.config.modes.dragElbow) {
        const createDragHandler = (fg) => () => {
          if (this.modeManager.canPerformAction("markerDrag")) {
            this.markerDrag(fg);
          }
        };
        marker.on("drag", createDragHandler(featureGroup));
      }
      if (i === menuMarkerIdx && holeMenuEnabled) {
        marker.options.zIndexOffset = this.config.markers.markerMenuIcon.zIndexOffset ?? this.config.markers.zIndexOffset;
        marker.on("click", () => {
          const ring = latlngs.map((pt) => [pt.lng, pt.lat]);
          ring.push(ring[0]);
          const holePolygon = {
            type: "Feature",
            properties: {},
            geometry: {
              type: "Polygon",
              coordinates: [ring]
            }
          };
          const centerOfMass2 = PolygonUtil.getCenterOfMass(holePolygon);
          const menuPopup = this.generateMenuMarkerPopup(latlngs, featureGroup);
          menuPopup.setLatLng(centerOfMass2).openOn(this.map);
        });
        marker.on("popupopen", (e) => {
          const popup = e.popup;
          const popupContent = popup.getElement();
          if (!popupContent) return;
          setTimeout(() => {
            const mapContainer = this.map.getContainer();
            const mapBounds = mapContainer.getBoundingClientRect();
            const popupBounds = popupContent.getBoundingClientRect();
            if (popupBounds.left < mapBounds.left) {
              popupContent.style.transform = `translateX(${mapBounds.left - popupBounds.left}px)`;
            } else if (popupBounds.right > mapBounds.right) {
              popupContent.style.transform = `translateX(${mapBounds.right - popupBounds.right}px)`;
            }
          }, 0);
          const container = this.map.getContainer();
          if (container) {
            container.style.touchAction = "manipulation";
          }
        });
        marker.on("popupclose", () => {
          const container = this.map.getContainer();
          if (container) {
            container.style.touchAction = "";
          }
        });
      }
      if (i === infoMarkerIdx && holeInfoEnabled) {
        const ring = latlngs.map((latlng2) => [latlng2.lng, latlng2.lat]);
        ring.push(ring[0]);
        const holePolygon = {
          type: "Feature",
          properties: {},
          geometry: {
            type: "Polygon",
            coordinates: [ring]
          }
        };
        const area2 = this.turfHelper.getPolygonArea(holePolygon);
        const perimeter = this.turfHelper.getPolygonPerimeter(holePolygon) * 1e3;
        marker.options.zIndexOffset = this.config.markers.markerInfoIcon.zIndexOffset ?? this.config.markers.zIndexOffset;
        marker.on("click", () => {
          const infoPopup = this.generateInfoMarkerPopup(area2, perimeter);
          infoPopup.setLatLng(latlng).openOn(this.map);
        });
      }
      marker.on("mousedown", (e) => {
        if (!this.modeManager.isInOffMode()) {
          L.DomEvent.stopPropagation(e);
          this.map.fire("mousedown", e);
        }
        this._activeMarker = marker;
      });
      marker.on("click", (e) => {
        if (this.modeManager.isInOffMode()) {
          if (this.isEdgeDeletionModifierKeyPressed(e.originalEvent)) {
            const polygonLayer = featureGroup.getLayers().find((layer) => layer instanceof L.Polygon);
            if (polygonLayer) {
              this.elbowClicked(e, polygonLayer, marker.getLatLng());
            }
          } else {
            if (i === deleteMarkerIdx && holeDeleteEnabled) {
              this.map.closePopup();
              const parentPolygon = featureGroup.getLayers().find((layer) => layer instanceof L.Polygon);
              if (parentPolygon) {
                const rawLatLngs = parentPolygon.getLatLngs();
                let rings = [];
                if (Array.isArray(rawLatLngs) && rawLatLngs.length > 0) {
                  if (Array.isArray(rawLatLngs[0])) {
                    const first = rawLatLngs[0];
                    if (Array.isArray(first) && Array.isArray(first[0])) {
                      rings = rawLatLngs[0];
                    } else {
                      rings = rawLatLngs;
                    }
                  } else {
                    rings = [rawLatLngs];
                  }
                }
                const target = marker.getLatLng();
                let holeIndex = -1;
                for (let r = 1; r < rings.length; r++) {
                  if (rings[r].some((p) => p.lat === target.lat && p.lng === target.lng)) {
                    holeIndex = r;
                    break;
                  }
                }
                if (holeIndex > 0) {
                  const newRings = rings.filter((_, idx) => idx !== holeIndex);
                  const coords = newRings.map((ring) => {
                    const arr = ring.map((ll) => [ll.lng, ll.lat]);
                    if (arr.length > 0) {
                      const firstPt = arr[0];
                      const lastPt = arr[arr.length - 1];
                      if (firstPt[0] !== lastPt[0] || firstPt[1] !== lastPt[1]) {
                        arr.push([firstPt[0], firstPt[1]]);
                      }
                    }
                    return arr;
                  });
                  const newPolygon = this.turfHelper.getMultiPolygon([coords]);
                  this.removeFeatureGroup(featureGroup);
                  this.eventManager.emit("polydraw:polygon:updated", {
                    operation: "removeHole",
                    polygon: newPolygon
                  });
                }
              }
            }
          }
        }
      });
      marker.on("mouseover", () => this.onMarkerHoverForEdgeDeletion(marker, true));
      marker.on("mouseout", () => this.onMarkerHoverForEdgeDeletion(marker, false));
    });
  }
  /**
   * Add edge click listeners to a polygon
   */
  addEdgeClickListeners(polygon2, featureGroup) {
    const rawLatLngs = polygon2.getLatLngs();
    let processedRings;
    if (Array.isArray(rawLatLngs) && rawLatLngs.length > 0) {
      if (Array.isArray(rawLatLngs[0])) {
        if (Array.isArray(rawLatLngs[0][0]) && rawLatLngs[0][0].length > 0) {
          const firstCoord = rawLatLngs[0][0][0];
          if (firstCoord && typeof firstCoord === "object" && "lat" in firstCoord) {
            processedRings = rawLatLngs[0];
          } else {
            processedRings = rawLatLngs[0];
          }
        } else if (rawLatLngs[0][0] && typeof rawLatLngs[0][0] === "object" && "lat" in rawLatLngs[0][0]) {
          processedRings = rawLatLngs;
        } else {
          processedRings = rawLatLngs[0];
        }
      } else if (rawLatLngs[0] && typeof rawLatLngs[0] === "object" && "lat" in rawLatLngs[0]) {
        processedRings = [rawLatLngs];
      } else {
        processedRings = [rawLatLngs];
      }
    } else {
      return;
    }
    processedRings.forEach((ring, ringIndex) => {
      for (let i = 0; i < ring.length; i++) {
        const edgeStart = ring[i];
        const edgeEnd = ring[(i + 1) % ring.length];
        if (edgeStart.lat === edgeEnd.lat && edgeStart.lng === edgeEnd.lng) {
          continue;
        }
        const edgePolyline = L.polyline([edgeStart, edgeEnd], {
          color: "transparent",
          weight: 10,
          opacity: 0,
          interactive: true
        });
        edgePolyline._polydrawEdgeInfo = {
          ringIndex,
          edgeIndex: i,
          startPoint: edgeStart,
          endPoint: edgeEnd,
          parentPolygon: polygon2,
          parentFeatureGroup: featureGroup
        };
        edgePolyline.on("click", (e) => {
          this.onEdgeClick(e, edgePolyline);
        });
        edgePolyline.on("mouseover", () => {
          this.highlightEdgeOnHover(edgePolyline, true);
        });
        edgePolyline.on("mouseout", () => {
          this.highlightEdgeOnHover(edgePolyline, false);
        });
        featureGroup.addLayer(edgePolyline);
      }
    });
  }
  /**
   * Enable polygon dragging functionality
   */
  enablePolygonDragging(polygon2, latlngs) {
    if (!this.config.modes.dragPolygons) return;
    polygon2._polydrawOriginalLatLngs = latlngs;
    polygon2._polydrawDragData = {
      isDragging: false,
      startPosition: null,
      startLatLngs: null
    };
    polygon2.on("mousedown", (e) => {
      if (!this.modeManager.isInOffMode()) {
        L.DomEvent.stopPropagation(e);
        this.map.fire("mousedown", e);
        return;
      }
      if (!this.modeManager.canPerformAction("polygonDrag")) {
        return;
      }
      L.DomEvent.stopPropagation(e.originalEvent);
      L.DomEvent.preventDefault(e.originalEvent);
      const isModifierPressed = this.detectDragSubtractModifierKey(e.originalEvent);
      this.currentModifierDragMode = isModifierPressed;
      this.isModifierKeyHeld = isModifierPressed;
      polygon2._polydrawDragData.isDragging = true;
      polygon2._polydrawDragData.startPosition = e.latlng;
      polygon2._polydrawDragData.startLatLngs = polygon2.getLatLngs();
      if (this.map.dragging) {
        this.map.dragging.disable();
      }
      this.setSubtractVisualMode(polygon2, isModifierPressed);
      try {
        const container = this.map.getContainer();
        container.style.cursor = this.config.dragPolygons.dragCursor || "move";
      } catch (error) {
      }
      this.map.on("mousemove", this.onPolygonMouseMove, this);
      this.map.on("mouseup", this.onPolygonMouseUp, this);
      this.currentDragPolygon = polygon2;
    });
    polygon2.on("mouseover", () => {
      if (!polygon2._polydrawDragData.isDragging) {
        try {
          const container = this.map.getContainer();
          container.style.cursor = this.config.dragPolygons.hoverCursor || "grab";
        } catch (error) {
        }
      }
    });
    polygon2.on("mouseout", () => {
      if (!polygon2._polydrawDragData.isDragging) {
        try {
          const container = this.map.getContainer();
          container.style.cursor = "";
        } catch (error) {
        }
      }
    });
  }
  /**
   * Update marker draggable state based on current mode
   */
  updateMarkerDraggableState() {
    const shouldBeDraggable = this.modeManager.canPerformAction("markerDrag");
    this.getFeatureGroups().forEach((featureGroup) => {
      featureGroup.eachLayer((layer) => {
        if (layer instanceof L.Marker) {
          const marker = layer;
          try {
            marker.options.draggable = shouldBeDraggable;
            if (marker.dragging) {
              if (shouldBeDraggable) {
                marker.dragging.enable();
              } else {
                marker.dragging.disable();
              }
            }
          } catch (error) {
          }
        }
      });
    });
  }
  /**
   * Update all markers for edge deletion visual feedback
   */
  updateAllMarkersForEdgeDeletion(showFeedback) {
    this.getFeatureGroups().forEach((featureGroup) => {
      featureGroup.eachLayer((layer) => {
        if (layer instanceof L.Marker) {
          this.updateMarkerForEdgeDeletion(layer, showFeedback);
        }
      });
    });
  }
  /**
   * Update individual marker for edge deletion visual feedback
   */
  updateMarkerForEdgeDeletion(marker, showFeedback) {
    const element = marker.getElement();
    if (!element) return;
    if (showFeedback) {
      element.addEventListener("mouseenter", this.onMarkerHoverForEdgeDeletionEvent);
      element.addEventListener("mouseleave", this.onMarkerLeaveForEdgeDeletionEvent);
    } else {
      element.removeEventListener("mouseenter", this.onMarkerHoverForEdgeDeletionEvent);
      element.removeEventListener("mouseleave", this.onMarkerLeaveForEdgeDeletionEvent);
      element.style.backgroundColor = "";
      element.style.borderColor = "";
    }
  }
  /**
   * Set modifier key held state
   */
  setModifierKeyHeld(isHeld) {
    this.isModifierKeyHeld = isHeld;
  }
  // Private methods
  onEdgeClick(e, edgePolyline) {
    if (!this.config.modes.attachElbow) {
      return;
    }
    if (!this.modeManager.isInOffMode()) {
      return;
    }
    const edgeInfo = edgePolyline._polydrawEdgeInfo;
    if (!edgeInfo) return;
    const newPoint = e.latlng;
    const parentPolygon = edgeInfo.parentPolygon;
    const parentFeatureGroup = edgeInfo.parentFeatureGroup;
    if (parentPolygon && parentFeatureGroup) {
      try {
        if (typeof parentPolygon.toGeoJSON !== "function") {
          return;
        }
        const poly = parentPolygon.toGeoJSON();
        if (poly.geometry.type === "MultiPolygon" || poly.geometry.type === "Polygon") {
          const newPolygon = this.turfHelper.injectPointToPolygon(
            poly,
            [newPoint.lng, newPoint.lat],
            edgeInfo.ringIndex
          );
          if (newPolygon) {
            const polydrawPolygon = parentPolygon;
            const optimizationLevel = polydrawPolygon._polydrawOptimizationLevel || 0;
            this.removeFeatureGroup(parentFeatureGroup);
            this.eventManager.emit("polydraw:polygon:updated", {
              operation: "addVertex",
              polygon: newPolygon,
              optimizationLevel
            });
          }
        }
      } catch (error) {
      }
    }
    L.DomEvent.stopPropagation(e);
  }
  highlightEdgeOnHover(edgePolyline, isHovering) {
    if (isHovering) {
      edgePolyline.setStyle({
        color: this.config.colors.edgeHover,
        weight: 4,
        opacity: 1
      });
    } else {
      edgePolyline.setStyle({
        color: "transparent",
        weight: 10,
        opacity: 0
      });
    }
  }
  elbowClicked(e, polygonLayer, forcedLatLng) {
    if (!this.config.modes.edgeDeletion) return;
    if (!this.isEdgeDeletionModifierKeyPressed(e.originalEvent)) return;
    const clickedLatLng = forcedLatLng ?? e.latlng;
    const rawLatLngs = polygonLayer.getLatLngs();
    let rings = [];
    if (Array.isArray(rawLatLngs) && rawLatLngs.length > 0) {
      if (Array.isArray(rawLatLngs[0])) {
        const first = rawLatLngs[0];
        if (Array.isArray(first) && Array.isArray(first[0])) {
          rings = rawLatLngs[0];
        } else {
          rings = rawLatLngs;
        }
      } else {
        rings = [rawLatLngs];
      }
    } else {
      return;
    }
    let targetRingIndex = -1;
    let targetVertexIndex = -1;
    for (let r = 0; r < rings.length; r++) {
      const ring = rings[r];
      for (let v = 0; v < ring.length; v++) {
        const p = ring[v];
        if (p.lat === clickedLatLng.lat && p.lng === clickedLatLng.lng) {
          targetRingIndex = r;
          targetVertexIndex = v;
          break;
        }
      }
      if (targetRingIndex !== -1) break;
    }
    if (targetRingIndex === -1 || targetVertexIndex === -1) {
      return;
    }
    const targetRing = rings[targetRingIndex];
    if (targetRing.length <= 3) {
      return;
    }
    const newRings = rings.map((ring, idx) => {
      if (idx !== targetRingIndex) return ring.slice();
      const nr = ring.slice();
      nr.splice(targetVertexIndex, 1);
      return nr;
    });
    const coords = newRings.map((ring) => {
      const arr = ring.map((ll) => [ll.lng, ll.lat]);
      if (arr.length > 0) {
        const first = arr[0];
        const last = arr[arr.length - 1];
        if (first[0] !== last[0] || first[1] !== last[1]) {
          arr.push([first[0], first[1]]);
        }
      }
      return arr;
    });
    let currentFeatureGroup = null;
    for (const fg of this.getFeatureGroups()) {
      let found = false;
      fg.eachLayer((layer) => {
        if (layer === polygonLayer) found = true;
      });
      if (found) {
        currentFeatureGroup = fg;
        break;
      }
    }
    if (currentFeatureGroup) {
      this.removeFeatureGroup(currentFeatureGroup);
    }
    const newPolygon = this.turfHelper.getMultiPolygon([coords]);
    this.eventManager.emit("polydraw:polygon:updated", {
      operation: "removeVertex",
      polygon: newPolygon
    });
  }
  findFeatureGroupForPoly(poly) {
    for (const featureGroup of this.getFeatureGroups()) {
      const featureCollection2 = featureGroup.toGeoJSON();
      if (featureCollection2 && featureCollection2.features && featureCollection2.features[0]) {
        const feature2 = featureCollection2.features[0];
        if (this.turfHelper.equalPolygons(feature2, poly)) {
          return featureGroup;
        }
      }
    }
    return null;
  }
  markerDrag(featureGroup) {
    if (!this._activeMarker) {
      console.warn("No active marker set for dragging.");
      return;
    }
    const newPos = [];
    let testarray = [];
    let hole = [];
    const layers = featureGroup.getLayers();
    const polygonLayer = layers.find((l) => l instanceof L.Polygon);
    const posarrays = polygonLayer.getLatLngs();
    let length2 = 0;
    const markers2 = layers.filter((layer) => layer instanceof L.Marker);
    if (posarrays.length > 1) {
      for (let index = 0; index < posarrays.length; index++) {
        testarray = [];
        hole = [];
        if (index === 0) {
          if (posarrays[0].length > 1) {
            for (let i = 0; i < posarrays[0].length; i++) {
              for (let j = 0; j < posarrays[0][i].length; j++) {
                if (markers2[j]) {
                  testarray.push(markers2[j].getLatLng());
                }
              }
              hole.push(testarray);
            }
          } else {
            for (let j = 0; j < posarrays[0][0].length; j++) {
              if (markers2[j]) {
                testarray.push(markers2[j].getLatLng());
              }
            }
            hole.push(testarray);
          }
          newPos.push(hole);
        } else {
          length2 += posarrays[index - 1].length;
          for (let j = length2; j < posarrays[index][0].length + length2; j++) {
            if (markers2[j]) {
              testarray.push(markers2[j].getLatLng());
            }
          }
          hole.push(testarray);
          newPos.push(hole);
        }
      }
    } else {
      hole = [];
      let length22 = 0;
      for (let index = 0; index < posarrays[0].length; index++) {
        testarray = [];
        if (index === 0) {
          if (posarrays[0][index].length > 1) {
            for (let j = 0; j < posarrays[0][index].length; j++) {
              if (markers2[j]) {
                testarray.push(markers2[j].getLatLng());
              }
            }
          } else {
            for (let j = 0; j < posarrays[0][0].length; j++) {
              if (markers2[j]) {
                testarray.push(markers2[j].getLatLng());
              }
            }
          }
        } else {
          length22 += posarrays[0][index - 1].length;
          for (let j = length22; j < posarrays[0][index].length + length22; j++) {
            if (markers2[j]) {
              testarray.push(markers2[j].getLatLng());
            }
          }
        }
        hole.push(testarray);
      }
      newPos.push(hole);
    }
    polygonLayer.setLatLngs(newPos);
  }
  async markerDragEnd(featureGroup) {
    this.polygonInformation.deletePolygonInformationStorage();
    const featureCollection2 = featureGroup.toGeoJSON();
    if (!featureCollection2.features || featureCollection2.features.length === 0) {
      return;
    }
    this.removeFeatureGroup(featureGroup);
    if (featureCollection2.features[0].geometry.type === "MultiPolygon") {
      for (const element of featureCollection2.features[0].geometry.coordinates) {
        const feature2 = this.turfHelper.getMultiPolygon([element]);
        if (this.turfHelper.hasKinks(feature2)) {
          const unkink = this.turfHelper.getKinks(feature2);
          for (const polygon2 of unkink) {
            this.eventManager.emit("polydraw:polygon:updated", {
              operation: "markerDrag",
              polygon: this.turfHelper.getTurfPolygon(polygon2),
              allowMerge: true
            });
          }
        } else {
          this.eventManager.emit("polydraw:polygon:updated", {
            operation: "markerDrag",
            polygon: feature2,
            allowMerge: true
          });
        }
      }
    } else {
      const feature2 = this.turfHelper.getMultiPolygon([
        featureCollection2.features[0].geometry.coordinates
      ]);
      if (this.turfHelper.hasKinks(feature2)) {
        const unkink = this.turfHelper.getKinks(feature2);
        for (const polygon2 of unkink) {
          this.eventManager.emit("polydraw:polygon:updated", {
            operation: "markerDrag",
            polygon: this.turfHelper.getTurfPolygon(polygon2),
            allowMerge: true
          });
        }
      } else {
        this.eventManager.emit("polydraw:polygon:updated", {
          operation: "markerDrag",
          polygon: feature2,
          allowMerge: true
        });
      }
    }
    this.polygonInformation.createPolygonInformationStorage(this.getFeatureGroups());
  }
  offsetPolygonCoordinates(latLngs, offsetLat, offsetLng) {
    if (!latLngs) return latLngs;
    if (Array.isArray(latLngs[0])) {
      return latLngs.map(
        (ring) => this.offsetPolygonCoordinates(ring, offsetLat, offsetLng)
      );
    }
    return latLngs.map((p) => L.latLng(p.lat + offsetLat, p.lng + offsetLng));
  }
  updateMarkersAndHoleLinesDuringDrag(polygon2, offsetLat, offsetLng) {
    try {
      let featureGroup = null;
      for (const fg of this.getFeatureGroups()) {
        let foundPolygon = false;
        fg.eachLayer((layer) => {
          if (layer === polygon2) {
            foundPolygon = true;
          }
        });
        if (foundPolygon) {
          featureGroup = fg;
          break;
        }
      }
      if (!featureGroup) {
        return;
      }
      const dragSessionKey = "_polydrawDragSession_" + Date.now() + "_" + L.Util.stamp(polygon2);
      if (!polygon2._polydrawCurrentDragSession) {
        polygon2._polydrawCurrentDragSession = dragSessionKey;
        polygon2._polydrawOriginalMarkerPositions = /* @__PURE__ */ new Map();
        polygon2._polydrawOriginalHoleLinePositions = /* @__PURE__ */ new Map();
        featureGroup.eachLayer((layer) => {
          if (layer instanceof L.Marker) {
            polygon2._polydrawOriginalMarkerPositions.set(layer, layer.getLatLng());
          } else if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
            const latLngs = layer.getLatLngs();
            polygon2._polydrawOriginalHoleLinePositions.set(layer, latLngs);
          }
        });
      }
      featureGroup.eachLayer((layer) => {
        if (layer instanceof L.Marker) {
          const originalPos = polygon2._polydrawOriginalMarkerPositions.get(layer);
          if (originalPos) {
            const newLatLng = {
              lat: originalPos.lat + offsetLat,
              lng: originalPos.lng + offsetLng
            };
            layer.setLatLng(newLatLng);
          }
        } else if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
          const originalPositions = polygon2._polydrawOriginalHoleLinePositions.get(layer);
          if (originalPositions) {
            let newLatLngs;
            if (Array.isArray(originalPositions[0])) {
              newLatLngs = originalPositions.map(
                (ring) => ring.map((latlng) => L.latLng(latlng.lat + offsetLat, latlng.lng + offsetLng))
              );
            } else {
              newLatLngs = originalPositions.map(
                (latlng) => L.latLng(latlng.lat + offsetLat, latlng.lng + offsetLng)
              );
            }
            layer.setLatLngs(newLatLngs);
          }
        }
      });
    } catch (error) {
      console.warn("Error updating markers during drag:", error);
    }
  }
  async updatePolygonAfterDrag(polygon2) {
    try {
      let featureGroup = null;
      for (const fg of this.getFeatureGroups()) {
        fg.eachLayer((layer) => {
          if (layer === polygon2) {
            featureGroup = fg;
          }
        });
        if (featureGroup) break;
      }
      if (!featureGroup) {
        return;
      }
      const newGeoJSON = polygon2.toGeoJSON();
      if (this.isModifierDragActive()) {
        this.performModifierSubtract(newGeoJSON, featureGroup);
        this.currentModifierDragMode = false;
        this.isModifierKeyHeld = false;
        return;
      }
      this.removeFeatureGroup(featureGroup);
      const feature2 = this.turfHelper.getTurfPolygon(newGeoJSON);
      this.eventManager.emit("polydraw:polygon:updated", {
        operation: "polygonDrag",
        polygon: feature2,
        allowMerge: true
      });
      this.polygonInformation.createPolygonInformationStorage(this.getFeatureGroups());
    } catch (error) {
    }
  }
  getDragSubtractModifierKey() {
    const { keys } = this.config.dragPolygons.modifierSubtract;
    const userAgent = navigator.userAgent.toLowerCase();
    const isMac = userAgent.includes("mac");
    const isWindows = userAgent.includes("windows");
    if (isMac && keys.mac) return keys.mac;
    if (isWindows && keys.windows) return keys.windows;
    if (keys.linux) return keys.linux;
    return isMac ? "metaKey" : "ctrlKey";
  }
  detectDragSubtractModifierKey(event) {
    var _a2, _b2;
    if (!((_b2 = (_a2 = this.config.dragPolygons) == null ? void 0 : _a2.modifierSubtract) == null ? void 0 : _b2.enabled)) {
      return false;
    }
    if (isTouchDevice()) {
      return false;
    }
    const modifierKey = this.getDragSubtractModifierKey();
    return !!event[modifierKey];
  }
  setSubtractVisualMode(polygon2, enabled) {
    if (!polygon2 || !polygon2.setStyle) {
      return;
    }
    try {
      if (enabled) {
        polygon2.setStyle({
          color: this.config.colors.dragPolygons.subtract
        });
      } else {
        polygon2.setStyle({
          color: this.config.colors.polygon.border
        });
      }
      this.updateMarkerColorsForSubtractMode(polygon2, enabled);
    } catch (error) {
    }
  }
  updateMarkerColorsForSubtractMode(polygon2, subtractMode) {
    var _a2, _b2;
    try {
      let featureGroup = null;
      for (const fg of this.getFeatureGroups()) {
        fg.eachLayer((layer) => {
          if (layer === polygon2) {
            featureGroup = fg;
          }
        });
        if (featureGroup) break;
      }
      if (!featureGroup) {
        return;
      }
      const hideMarkersOnDrag = ((_b2 = (_a2 = this.config.dragPolygons) == null ? void 0 : _a2.modifierSubtract) == null ? void 0 : _b2.hideMarkersOnDrag) ?? false;
      featureGroup.eachLayer((layer) => {
        if (layer instanceof L.Marker) {
          const marker = layer;
          const element = marker.getElement();
          if (element) {
            if (subtractMode) {
              if (hideMarkersOnDrag) {
                element.style.display = "none";
                element.classList.add("subtract-mode-hidden");
              } else {
                element.style.backgroundColor = this.config.colors.dragPolygons.subtract;
                element.style.borderColor = this.config.colors.dragPolygons.subtract;
                element.classList.add("subtract-mode");
              }
            } else {
              if (hideMarkersOnDrag) {
                element.style.display = "";
                element.classList.remove("subtract-mode-hidden");
              } else {
                element.style.backgroundColor = "";
                element.style.borderColor = "";
                element.classList.remove("subtract-mode");
              }
            }
          }
        }
      });
    } catch (error) {
    }
  }
  handleModifierToggleDuringDrag(event) {
    const isModifierPressed = this.detectDragSubtractModifierKey(event);
    this.currentModifierDragMode = isModifierPressed;
    this.isModifierKeyHeld = isModifierPressed;
    if (this.currentDragPolygon) {
      this.setSubtractVisualMode(this.currentDragPolygon, isModifierPressed);
    }
  }
  isModifierDragActive() {
    return this.currentModifierDragMode;
  }
  performModifierSubtract(draggedGeoJSON, originalFeatureGroup) {
    try {
      const draggedPolygon = this.turfHelper.getTurfPolygon(draggedGeoJSON);
      const intersectingFeatureGroups = [];
      this.getFeatureGroups().forEach((featureGroup) => {
        if (featureGroup === originalFeatureGroup) {
          return;
        }
        try {
          const featureCollection2 = featureGroup.toGeoJSON();
          if (!featureCollection2 || !featureCollection2.features || !featureCollection2.features[0]) {
            return;
          }
          const firstFeature = featureCollection2.features[0];
          if (!firstFeature.geometry || !firstFeature.geometry.coordinates) {
            return;
          }
          const existingPolygon = this.turfHelper.getTurfPolygon(firstFeature);
          try {
            const intersection3 = this.turfHelper.getIntersection(existingPolygon, draggedPolygon);
            if (intersection3 && intersection3.geometry && "coordinates" in intersection3.geometry) {
              const coords = intersection3.geometry.coordinates;
              if (coords.length > 0) {
                intersectingFeatureGroups.push(featureGroup);
              }
            }
          } catch (intersectError) {
            try {
              const hasIntersection = this.turfHelper.polygonIntersect(
                existingPolygon,
                draggedPolygon
              );
              if (hasIntersection) {
                intersectingFeatureGroups.push(featureGroup);
              }
            } catch (polygonIntersectError) {
            }
          }
        } catch (error) {
        }
      });
      this.removeFeatureGroup(originalFeatureGroup);
      intersectingFeatureGroups.forEach((featureGroup) => {
        try {
          const featureCollection2 = featureGroup.toGeoJSON();
          const existingPolygon = this.turfHelper.getTurfPolygon(featureCollection2.features[0]);
          this.removeFeatureGroup(featureGroup);
          try {
            const difference3 = this.turfHelper.polygonDifference(existingPolygon, draggedPolygon);
            if (difference3 && difference3.geometry) {
              const coords = this.turfHelper.getCoords(difference3);
              for (const coordSet of coords) {
                const individualPolygon = this.turfHelper.getMultiPolygon([coordSet]);
                this.eventManager.emit("polydraw:polygon:updated", {
                  operation: "modifierSubtract",
                  polygon: this.turfHelper.getTurfPolygon(individualPolygon),
                  allowMerge: false
                  // Don't merge the result of subtract operations
                });
              }
            }
          } catch (differenceError) {
            console.warn("Failed to perform difference operation:", differenceError);
            this.eventManager.emit("polydraw:polygon:updated", {
              operation: "modifierSubtractFallback",
              polygon: existingPolygon,
              allowMerge: false
            });
          }
        } catch (error) {
          console.warn("Error in modifier subtract operation:", error);
        }
      });
      this.polygonInformation.createPolygonInformationStorage(this.getFeatureGroups());
    } catch (error) {
      console.warn("Error in performModifierSubtract:", error);
    }
  }
  /**
   * Check if two bounding boxes overlap
   */
  boundingBoxesOverlap(bbox1, bbox2) {
    return !(bbox1[2] < bbox2[0] || bbox2[2] < bbox1[0] || bbox1[3] < bbox2[1] || bbox2[3] < bbox1[1]);
  }
  isDragSubtractModifierKeyPressed(event) {
    if (isTouchDevice()) {
      return false;
    }
    const modifierKey = this.getDragSubtractModifierKey();
    return !!event[modifierKey];
  }
  getEdgeDeletionModifierKey() {
    const { keys } = this.config.edgeDeletion;
    const userAgent = navigator.userAgent.toLowerCase();
    const isMac = userAgent.includes("mac");
    const isWindows = userAgent.includes("windows");
    if (isMac && keys.mac) return keys.mac;
    if (isWindows && keys.windows) return keys.windows;
    if (keys.linux) return keys.linux;
    return isMac ? "metaKey" : "ctrlKey";
  }
  isEdgeDeletionModifierKeyPressed(event) {
    if (isTouchDevice()) {
      return false;
    }
    const modifierKey = this.getEdgeDeletionModifierKey();
    return !!event[modifierKey];
  }
  onMarkerHoverForEdgeDeletion(marker, isHovering) {
    const element = marker.getElement();
    if (!element) return;
    if (isHovering) {
      const checkModifierAndUpdate = (e) => {
        const isModifierPressed = this.isEdgeDeletionModifierKeyPressed(e);
        if (isModifierPressed) {
          element.style.backgroundColor = this.config.colors.edgeDeletion.hover;
          element.style.borderColor = this.config.colors.edgeDeletion.hover;
          element.classList.add("edge-deletion-hover");
          try {
            const container = this.map.getContainer();
            container.style.cursor = "pointer";
          } catch (error) {
          }
        } else {
          element.style.backgroundColor = "";
          element.style.borderColor = "";
          element.classList.remove("edge-deletion-hover");
          try {
            const container = this.map.getContainer();
            container.style.cursor = "";
          } catch (error) {
          }
        }
      };
      const initialEvent = new MouseEvent("mouseover");
      checkModifierAndUpdate(initialEvent);
      this.markerModifierHandlers.set(marker, checkModifierAndUpdate);
      document.addEventListener("keydown", checkModifierAndUpdate);
      document.addEventListener("keyup", checkModifierAndUpdate);
      element.addEventListener("mousemove", checkModifierAndUpdate);
    } else {
      element.style.backgroundColor = "";
      element.style.borderColor = "";
      element.classList.remove("edge-deletion-hover");
      try {
        const container = this.map.getContainer();
        container.style.cursor = "";
      } catch (error) {
      }
      const handler = this.markerModifierHandlers.get(marker);
      if (handler) {
        document.removeEventListener("keydown", handler);
        document.removeEventListener("keyup", handler);
        element.removeEventListener("mousemove", handler);
        this.markerModifierHandlers.delete(marker);
      }
    }
  }
  // Helper methods
  getMarkerIndex(latlngs, position) {
    const bounds = PolyDrawUtil.getBounds(latlngs, Math.sqrt(2) / 2);
    const compass = new Compass(
      bounds.getSouth(),
      bounds.getWest(),
      bounds.getNorth(),
      bounds.getEast()
    );
    const compassDirection = compass.getDirection(position);
    const latLngPoint = {
      lat: compassDirection.lat,
      lng: compassDirection.lng
    };
    const targetPoint = this.turfHelper.getCoord(latLngPoint);
    const fc = this.turfHelper.getFeaturePointCollection(latlngs);
    const nearestPointIdx = this.turfHelper.getNearestPointIndex(
      targetPoint,
      fc
    );
    return nearestPointIdx;
  }
  ensureMarkerSeparation(polygonLength, markers2) {
    const enabledMarkers = [];
    if (markers2.menu.enabled) {
      enabledMarkers.push({ type: "menu", index: markers2.menu.index });
    }
    if (markers2.delete.enabled) {
      enabledMarkers.push({ type: "delete", index: markers2.delete.index });
    }
    if (markers2.info.enabled) {
      enabledMarkers.push({ type: "info", index: markers2.info.index });
    }
    if (enabledMarkers.length < 2) {
      return {
        menu: markers2.menu.index,
        delete: markers2.delete.index,
        info: markers2.info.index
      };
    }
    const resolvedIndices = { ...markers2 };
    const usedIndices = /* @__PURE__ */ new Set();
    const processingOrder = ["info", "delete", "menu"];
    for (const markerType of processingOrder) {
      const marker = resolvedIndices[markerType];
      if (!marker.enabled) continue;
      if (usedIndices.has(marker.index)) {
        const newIndex = this.findAlternativeMarkerPosition(
          polygonLength,
          marker.index,
          usedIndices
        );
        resolvedIndices[markerType].index = newIndex;
        usedIndices.add(newIndex);
      } else {
        usedIndices.add(marker.index);
      }
    }
    return {
      menu: resolvedIndices.menu.index,
      delete: resolvedIndices.delete.index,
      info: resolvedIndices.info.index
    };
  }
  findAlternativeMarkerPosition(polygonLength, originalIndex, usedIndices) {
    const maxAttempts = polygonLength;
    const step = Math.max(1, Math.floor(polygonLength / 8));
    for (let attempt = 1; attempt < maxAttempts; attempt++) {
      const candidates = [
        (originalIndex + attempt * step) % polygonLength,
        (originalIndex - attempt * step + polygonLength) % polygonLength
      ];
      for (const candidate of candidates) {
        if (!usedIndices.has(candidate)) {
          return candidate;
        }
      }
    }
    for (let i = 0; i < polygonLength; i++) {
      if (!usedIndices.has(i)) {
        return i;
      }
    }
    return originalIndex;
  }
  createDivIcon(processedClasses) {
    return IconFactory.createDivIcon(processedClasses);
  }
  getLatLngInfoString(latlng) {
    return "Latitude: " + latlng.lat + " Longitude: " + latlng.lng;
  }
  generateMenuMarkerPopup(latLngs, featureGroup) {
    const outerWrapper = document.createElement("div");
    outerWrapper.classList.add("alter-marker-outer-wrapper");
    const wrapper = document.createElement("div");
    wrapper.classList.add("alter-marker-wrapper");
    const markerContent = document.createElement("div");
    markerContent.classList.add("content");
    const markerContentWrapper = document.createElement("div");
    markerContentWrapper.classList.add("marker-menu-content");
    const simplify3 = document.createElement("div");
    simplify3.classList.add("marker-menu-button", "simplify");
    simplify3.title = "Simplify";
    const doubleElbows = document.createElement("div");
    doubleElbows.classList.add("marker-menu-button", "double-elbows");
    doubleElbows.title = "DoubleElbows";
    const bbox2 = document.createElement("div");
    bbox2.classList.add("marker-menu-button", "bbox");
    bbox2.title = "Bounding box";
    const bezier2 = document.createElement("div");
    bezier2.classList.add("marker-menu-button", "bezier");
    bezier2.title = "Curve";
    const alphaBanner = document.createElement("span");
    alphaBanner.classList.add("alpha-banner");
    alphaBanner.textContent = "ALPHA";
    bezier2.appendChild(alphaBanner);
    const separator = document.createElement("div");
    separator.classList.add("separator");
    outerWrapper.appendChild(wrapper);
    wrapper.appendChild(markerContent);
    markerContent.appendChild(markerContentWrapper);
    markerContentWrapper.appendChild(simplify3);
    markerContentWrapper.appendChild(separator.cloneNode());
    markerContentWrapper.appendChild(doubleElbows);
    markerContentWrapper.appendChild(separator.cloneNode());
    markerContentWrapper.appendChild(bbox2);
    markerContentWrapper.appendChild(separator.cloneNode());
    markerContentWrapper.appendChild(bezier2);
    const closePopupIfOpen = () => {
      if (this._openMenuPopup) {
        this.map.closePopup(this._openMenuPopup);
        this._openMenuPopup = null;
      }
    };
    simplify3.addEventListener("touchend", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.eventManager.emit("polydraw:menu:action", {
        action: "simplify",
        latLngs,
        featureGroup
      });
      closePopupIfOpen();
    });
    simplify3.onclick = () => {
      this.eventManager.emit("polydraw:menu:action", {
        action: "simplify",
        latLngs,
        featureGroup
      });
      closePopupIfOpen();
    };
    bbox2.addEventListener("touchend", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.eventManager.emit("polydraw:menu:action", {
        action: "bbox",
        latLngs,
        featureGroup
      });
      closePopupIfOpen();
    });
    bbox2.onclick = () => {
      this.eventManager.emit("polydraw:menu:action", {
        action: "bbox",
        latLngs,
        featureGroup
      });
      closePopupIfOpen();
    };
    doubleElbows.addEventListener("touchend", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.eventManager.emit("polydraw:menu:action", {
        action: "doubleElbows",
        latLngs,
        featureGroup
      });
      closePopupIfOpen();
    });
    doubleElbows.onclick = () => {
      this.eventManager.emit("polydraw:menu:action", {
        action: "doubleElbows",
        latLngs,
        featureGroup
      });
      closePopupIfOpen();
    };
    bezier2.addEventListener("touchend", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.eventManager.emit("polydraw:menu:action", {
        action: "bezier",
        latLngs,
        featureGroup
      });
      closePopupIfOpen();
    });
    bezier2.onclick = () => {
      this.eventManager.emit("polydraw:menu:action", {
        action: "bezier",
        latLngs,
        featureGroup
      });
      closePopupIfOpen();
    };
    L.DomEvent.disableClickPropagation(outerWrapper);
    outerWrapper.style.pointerEvents = "auto";
    outerWrapper.querySelectorAll(".marker-menu-button").forEach((btn) => {
      btn.style.pointerEvents = "auto";
      btn.addEventListener("click", (e) => e.stopPropagation());
    });
    const isMobile = window.innerWidth <= 600;
    const popup = L.popup({
      closeButton: true,
      autoClose: true,
      className: `menu-popup${isMobile ? " mobile-popup" : ""}`
    }).setContent(outerWrapper);
    this._openMenuPopup = popup;
    return popup;
  }
  getPolygonGeoJSONFromFeatureGroup(featureGroup) {
    try {
      let polygon2 = null;
      featureGroup.eachLayer((layer) => {
        if (layer instanceof L.Polygon) {
          polygon2 = layer;
        }
      });
      if (!polygon2) {
        throw new Error("No polygon found in feature group");
      }
      return polygon2.toGeoJSON();
    } catch (error) {
      if (error instanceof Error) {
        console.warn("Error getting polygon GeoJSON from feature group:", error.message);
      } else {
        console.warn("Error getting polygon GeoJSON from feature group:", error);
      }
      return {
        type: "Feature",
        geometry: {
          type: "Polygon",
          coordinates: [
            [
              [0, 0],
              [0, 1],
              [1, 1],
              [1, 0],
              [0, 0]
            ]
          ]
        },
        properties: {}
      };
    }
  }
  getTotalPolygonPerimeter(polygonGeoJSON) {
    try {
      if (!polygonGeoJSON || !polygonGeoJSON.geometry) {
        return 0;
      }
      let totalPerimeter = 0;
      if (polygonGeoJSON.geometry.type === "Polygon") {
        const coordinates = polygonGeoJSON.geometry.coordinates;
        for (const ring of coordinates) {
          const ringPolygon = {
            type: "Feature",
            geometry: {
              type: "Polygon",
              coordinates: [ring]
            },
            properties: {}
          };
          const ringPerimeter = this.turfHelper.getPolygonPerimeter(ringPolygon);
          totalPerimeter += ringPerimeter;
        }
      } else if (polygonGeoJSON.geometry.type === "MultiPolygon") {
        const coordinates = polygonGeoJSON.geometry.coordinates;
        for (const polygonCoords of coordinates) {
          for (const ring of polygonCoords) {
            const ringPolygon = {
              type: "Feature",
              geometry: {
                type: "Polygon",
                coordinates: [ring]
              },
              properties: {}
            };
            const ringPerimeter = this.turfHelper.getPolygonPerimeter(ringPolygon);
            totalPerimeter += ringPerimeter;
          }
        }
      }
      return totalPerimeter * 1e3;
    } catch (error) {
      if (error instanceof Error) {
        console.warn("Error calculating total polygon perimeter:", error.message);
      } else {
        console.warn("Error calculating total polygon perimeter:", error);
      }
      return this.turfHelper.getPolygonPerimeter(polygonGeoJSON) * 1e3;
    }
  }
  generateInfoMarkerPopup(area2, perimeter) {
    const _perimeter = new Perimeter(perimeter, this.config);
    const _area = new Area(area2, this.config);
    const outerWrapper = document.createElement("div");
    outerWrapper.classList.add("info-marker-outer-wrapper");
    const wrapper = document.createElement("div");
    wrapper.classList.add("info-marker-wrapper");
    const markerContent = document.createElement("div");
    markerContent.classList.add("content");
    const infoContentWrapper = document.createElement("div");
    infoContentWrapper.classList.add("info-marker-content");
    const areaDiv = document.createElement("div");
    areaDiv.classList.add("info-item", "area");
    areaDiv.innerHTML = `<strong>Area:</strong> ${_area.metricArea} ${_area.metricUnit}`;
    const perimeterDiv = document.createElement("div");
    perimeterDiv.classList.add("info-item", "perimeter");
    perimeterDiv.innerHTML = `<strong>Perimeter:</strong> ${_perimeter.metricLength} ${_perimeter.metricUnit}`;
    infoContentWrapper.appendChild(areaDiv);
    infoContentWrapper.appendChild(perimeterDiv);
    markerContent.appendChild(infoContentWrapper);
    outerWrapper.appendChild(wrapper);
    wrapper.appendChild(markerContent);
    L.DomEvent.disableClickPropagation(outerWrapper);
    outerWrapper.style.pointerEvents = "auto";
    outerWrapper.querySelectorAll("button").forEach((btn) => {
      btn.style.pointerEvents = "auto";
      btn.addEventListener("click", (e) => e.stopPropagation());
    });
    const isMobile = window.innerWidth <= 600;
    const popup = L.popup({
      closeButton: true,
      autoClose: true,
      className: `info-popup${isMobile ? " mobile-popup" : ""}`
    }).setContent(outerWrapper);
    return popup;
  }
}
class PolygonMutationManager {
  constructor(dependencies) {
    __publicField(this, "turfHelper");
    __publicField(this, "polygonInformation");
    __publicField(this, "map");
    __publicField(this, "config");
    __publicField(this, "modeManager");
    __publicField(this, "eventManager");
    __publicField(this, "getFeatureGroups");
    // Specialized managers
    __publicField(this, "geometryManager");
    __publicField(this, "drawManager");
    __publicField(this, "interactionManager");
    this.turfHelper = dependencies.turfHelper;
    this.polygonInformation = dependencies.polygonInformation;
    this.map = dependencies.map;
    this.config = dependencies.config;
    this.modeManager = dependencies.modeManager;
    this.eventManager = dependencies.eventManager;
    this.getFeatureGroups = dependencies.getFeatureGroups;
    this.initializeSpecializedManagers(dependencies);
  }
  /**
   * Initialize the three specialized managers
   */
  initializeSpecializedManagers(dependencies) {
    this.geometryManager = new PolygonGeometryManager({
      turfHelper: dependencies.turfHelper,
      config: dependencies.config
    });
    const placeholderTracer = L.polyline([], this.config.polyLineOptions);
    this.drawManager = new PolygonDrawManager({
      turfHelper: dependencies.turfHelper,
      map: dependencies.map,
      config: dependencies.config,
      modeManager: dependencies.modeManager,
      eventManager: this.eventManager,
      tracer: placeholderTracer
    });
    this.interactionManager = new PolygonInteractionManager(
      {
        turfHelper: dependencies.turfHelper,
        polygonInformation: dependencies.polygonInformation,
        map: dependencies.map,
        config: dependencies.config,
        modeManager: dependencies.modeManager,
        eventManager: this.eventManager
      },
      {
        getFeatureGroups: this.getFeatureGroups,
        addFeatureGroup: (fg) => this.addFeatureGroupInternal(fg),
        removeFeatureGroup: (fg) => this.removeFeatureGroupInternal(fg)
      }
    );
    this.setupEventForwarding();
  }
  /**
   * Set up event forwarding from specialized managers to facade
   */
  setupEventForwarding() {
    this.eventManager.on("polydraw:draw:cancel", (data) => {
      this.emit("drawCancelled", data);
    });
    this.eventManager.on("polydraw:polygon:updated", (data) => {
      this.handlePolygonModified(data);
    });
    this.eventManager.on("polydraw:menu:action", (data) => {
      this.handleMenuAction(data);
    });
    this.eventManager.on("polydraw:check:intersection", (data) => {
      const hasIntersection = this.geometryManager.checkPolygonIntersection(
        data.polygon1,
        data.polygon2
      );
      data.callback(hasIntersection);
    });
    this.eventManager.on("polydraw:subtract", (data) => {
      this.subtractPolygon(data.subtractPolygon);
    });
    this.eventManager.on("polydraw:polygon:deleted", () => {
      this.emit("polygonDeleted", void 0);
    });
  }
  /**
   * Handle polygon modification from interaction manager
   */
  async handlePolygonModified(data) {
    const shouldSimplify = data.operation !== "addVertex" && data.operation !== "markerDrag" && data.operation !== "polygonDrag";
    const options = {
      simplify: shouldSimplify,
      noMerge: !data.allowMerge,
      visualOptimizationLevel: data.optimizationLevel || 0
    };
    await this.addPolygon(data.polygon, options);
  }
  /**
   * Handle menu actions from interaction manager
   */
  async handleMenuAction(data) {
    const completePolygonGeoJSON = this.getCompletePolygonFromFeatureGroup(data.featureGroup);
    this.removeFeatureGroupInternal(data.featureGroup);
    let result;
    switch (data.action) {
      case "simplify": {
        result = this.geometryManager.simplifyPolygon(completePolygonGeoJSON);
        break;
      }
      case "bbox": {
        result = this.geometryManager.convertToBoundingBox(completePolygonGeoJSON);
        break;
      }
      case "doubleElbows": {
        result = this.geometryManager.doubleElbowsPolygon(completePolygonGeoJSON);
        break;
      }
      case "bezier": {
        result = this.geometryManager.bezierifyPolygon(completePolygonGeoJSON);
        break;
      }
      default:
        return;
    }
    if (result.success && result.result) {
      await this.addPolygon(result.result, { simplify: false });
    }
  }
  /**
   * Get the polygon interaction manager (for testing)
   */
  get polygonInteractionManager() {
    return this.interactionManager;
  }
  /**
   * Add event listener
   */
  on(event, callback) {
    this.eventManager.on(event, callback);
  }
  /**
   * Emit event to all listeners
   */
  emit(event, data) {
    this.eventManager.emit(event, data);
  }
  /**
   * Add a polygon with optional merging logic
   */
  async addPolygon(latlngs, options = {}) {
    const { noMerge = false } = options;
    const { simplify: simplify3 = true } = options;
    try {
      if (this.config.mergePolygons && !noMerge && this.getFeatureGroups().length > 0 && !this.config.kinks) {
        return await this.mergePolygon(latlngs, options);
      } else {
        return await this.addPolygonLayer(latlngs, options);
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error in addPolygon"
      };
    }
  }
  /**
   * Subtract a polygon from existing polygons
   */
  async subtractPolygon(latlngs) {
    try {
      const intersectingFeatureGroups = [];
      this.getFeatureGroups().forEach((featureGroup) => {
        try {
          const featureCollection2 = featureGroup.toGeoJSON();
          if (!featureCollection2 || !featureCollection2.features || !featureCollection2.features[0]) {
            return;
          }
          const firstFeature = featureCollection2.features[0];
          if (!firstFeature.geometry || !firstFeature.geometry.coordinates) {
            return;
          }
          const existingPolygon = this.turfHelper.getTurfPolygon(firstFeature);
          const hasIntersection = this.geometryManager.checkPolygonIntersection(
            existingPolygon,
            latlngs
          );
          if (hasIntersection) {
            intersectingFeatureGroups.push(featureGroup);
          }
        } catch (error) {
        }
      });
      const resultFeatureGroups = [];
      for (const featureGroup of intersectingFeatureGroups) {
        try {
          const featureCollection2 = featureGroup.toGeoJSON();
          const feature2 = this.turfHelper.getTurfPolygon(featureCollection2.features[0]);
          const result = this.geometryManager.subtractPolygon(feature2, latlngs);
          this.removeFeatureGroupInternal(featureGroup);
          if (result.success && result.results) {
            for (const resultPolygon of result.results) {
              const addResult = await this.addPolygonLayer(resultPolygon, { simplify: true });
              if (addResult.success && addResult.featureGroups) {
                resultFeatureGroups.push(...addResult.featureGroups);
              }
            }
          }
        } catch (error) {
        }
      }
      this.emit("polygonSubtracted", {
        subtractedPolygon: latlngs,
        affectedFeatureGroups: intersectingFeatureGroups,
        resultFeatureGroups
      });
      this.emit("polygonOperationComplete", {
        operation: "subtract",
        polygon: latlngs,
        resultFeatureGroups
      });
      return {
        success: true,
        featureGroups: resultFeatureGroups
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error in subtractPolygon"
      };
    }
  }
  /**
   * Create and add a polygon layer with all markers and interactions
   */
  async addPolygonLayer(latlngs, options = {}) {
    const { simplify: simplify3 = true, dynamicTolerance = false, visualOptimizationLevel = 0 } = options;
    try {
      if (!latlngs || !latlngs.geometry || !latlngs.geometry.coordinates) {
        return { success: false, error: "Invalid polygon data" };
      }
      const featureGroup = new L.FeatureGroup();
      const latLngs = simplify3 ? this.turfHelper.getSimplified(latlngs, dynamicTolerance) : latlngs;
      let polygon2;
      try {
        polygon2 = this.getPolygon(latLngs);
        if (!polygon2) {
          return { success: false, error: "Failed to create polygon" };
        }
        polygon2._polydrawOptimizationLevel = visualOptimizationLevel;
        featureGroup.addLayer(polygon2);
      } catch (error) {
        return { success: false, error: "Failed to create polygon layer" };
      }
      let markerLatlngs;
      try {
        markerLatlngs = polygon2.getLatLngs();
        if (!markerLatlngs || !Array.isArray(markerLatlngs)) {
          markerLatlngs = [];
        }
      } catch (error) {
        markerLatlngs = [];
      }
      try {
        markerLatlngs.forEach((polygon22) => {
          if (!polygon22 || !Array.isArray(polygon22)) {
            return;
          }
          polygon22.forEach((polyElement, i) => {
            if (!polyElement || !Array.isArray(polyElement) || polyElement.length === 0) {
              return;
            }
            try {
              if (i === 0) {
                this.interactionManager.addMarkers(polyElement, featureGroup);
              } else {
                const holePolyline = L.polyline(polyElement, {
                  color: this.config.colors.hole.border,
                  weight: this.config.holeOptions.weight || 2,
                  opacity: this.config.holeOptions.opacity || 1,
                  fillColor: this.config.colors.hole.fill,
                  fillOpacity: this.config.holeOptions.fillOpacity || 0.5
                });
                featureGroup.addLayer(holePolyline);
                this.interactionManager.addHoleMarkers(polyElement, featureGroup);
              }
            } catch (markerError) {
            }
          });
        });
      } catch (error) {
      }
      try {
        this.interactionManager.addEdgeClickListeners(polygon2, featureGroup);
      } catch (error) {
      }
      this.getFeatureGroups().push(featureGroup);
      try {
        featureGroup.addTo(this.map);
      } catch (error) {
      }
      this.emit("polygonAdded", { polygon: latLngs, featureGroup });
      this.emit("polygonOperationComplete", { operation: "add", polygon: latLngs, featureGroup });
      return {
        success: true,
        featureGroups: [featureGroup]
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error in addPolygonLayer"
      };
    }
  }
  /**
   * Merge a polygon with existing intersecting polygons
   */
  async mergePolygon(latlngs, options = {}) {
    try {
      const polygonFeature = [];
      const intersectingFeatureGroups = [];
      let polyIntersection = false;
      this.getFeatureGroups().forEach((featureGroup) => {
        try {
          const featureCollection2 = featureGroup.toGeoJSON();
          if (!featureCollection2 || !featureCollection2.features || !featureCollection2.features[0]) {
            return;
          }
          const firstFeature = featureCollection2.features[0];
          if (!firstFeature.geometry || !firstFeature.geometry.coordinates) {
            return;
          }
          if (this.isPositionArrayofArrays(firstFeature.geometry.coordinates)) {
            firstFeature.geometry.coordinates.forEach(
              (element) => {
                try {
                  const feature2 = this.turfHelper.getMultiPolygon([element]);
                  polyIntersection = this.geometryManager.checkPolygonIntersection(
                    feature2,
                    latlngs
                  );
                  if (polyIntersection) {
                    intersectingFeatureGroups.push(featureGroup);
                    polygonFeature.push(feature2);
                  }
                } catch (error) {
                }
              }
            );
          } else {
            try {
              const feature2 = this.turfHelper.getTurfPolygon(firstFeature);
              polyIntersection = this.geometryManager.checkPolygonIntersection(feature2, latlngs);
              if (polyIntersection) {
                intersectingFeatureGroups.push(featureGroup);
                polygonFeature.push(feature2);
              }
            } catch (error) {
            }
          }
        } catch (error) {
        }
      });
      if (intersectingFeatureGroups.length > 0) {
        return await this.unionPolygons(
          intersectingFeatureGroups,
          latlngs,
          polygonFeature,
          options
        );
      } else {
        return await this.addPolygonLayer(latlngs, options);
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error in mergePolygon"
      };
    }
  }
  /**
   * Union multiple polygons together using geometry manager
   */
  async unionPolygons(layers, latlngs, polygonFeature, options = {}) {
    try {
      layers.forEach((featureGroup) => {
        this.removeFeatureGroupInternal(featureGroup);
      });
      const result = this.geometryManager.unionPolygons(polygonFeature, latlngs);
      if (result.success && result.result) {
        const addResult = await this.addPolygonLayer(result.result, options);
        this.emit("polygonsUnioned", {
          originalPolygons: polygonFeature,
          resultPolygon: result.result,
          featureGroups: addResult.featureGroups
        });
        return addResult;
      } else {
        return {
          success: false,
          error: result.error || "Failed to union polygons"
        };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error in unionPolygons"
      };
    }
  }
  /**
   * Create a polygon from GeoJSON feature
   */
  isPositionArrayofArrays(arr) {
    if (!Array.isArray(arr) || arr.length === 0) return false;
    const first = arr[0];
    if (!Array.isArray(first) || first.length === 0) return false;
    const second = first[0];
    if (!Array.isArray(second) || second.length === 0) return false;
    const leaf = second[0];
    return this.isPosition(leaf);
  }
  isPosition(val) {
    return Array.isArray(val) && val.length >= 2 && val.every((n) => typeof n === "number");
  }
  /**
   * Create a polygon from GeoJSON feature
   */
  getPolygon(latlngs) {
    const polygon2 = L.GeoJSON.geometryToLayer(latlngs);
    polygon2.setStyle({
      ...this.config.polygonOptions,
      color: this.config.colors.polygon.border,
      fillColor: this.config.colors.polygon.fill
    });
    polygon2._polydrawUniqueId = L.Util.stamp(polygon2) + "_" + Date.now();
    delete polygon2._polydrawDragData;
    delete polygon2._polydrawOriginalLatLngs;
    delete polygon2._polydrawCurrentDragSession;
    delete polygon2._polydrawOriginalMarkerPositions;
    delete polygon2._polydrawOriginalHoleLinePositions;
    if (this.config.modes.dragPolygons) {
      this.interactionManager.enablePolygonDragging(polygon2, latlngs);
    }
    return polygon2;
  }
  /**
   * Internal method to add feature group to array
   */
  addFeatureGroupInternal(featureGroup) {
    this.getFeatureGroups().push(featureGroup);
  }
  /**
   * Internal method to remove feature group from array and map
   */
  removeFeatureGroupInternal(featureGroup) {
    featureGroup.clearLayers();
    const featureGroups = this.getFeatureGroups();
    const index = featureGroups.indexOf(featureGroup);
    if (index > -1) {
      featureGroups.splice(index, 1);
    }
    this.map.removeLayer(featureGroup);
  }
  /**
   * Get complete polygon GeoJSON including holes from a feature group
   */
  getCompletePolygonFromFeatureGroup(featureGroup) {
    try {
      let polygon2 = null;
      featureGroup.eachLayer((layer) => {
        if (layer instanceof L.Polygon) {
          polygon2 = layer;
        }
      });
      if (!polygon2) {
        throw new Error("No polygon found in feature group");
      }
      return polygon2.toGeoJSON();
    } catch (error) {
      console.warn("Error getting complete polygon GeoJSON from feature group:", error.message);
      return {
        type: "Feature",
        geometry: {
          type: "Polygon",
          coordinates: [
            [
              [0, 0],
              [0, 1],
              [1, 1],
              [1, 0],
              [0, 0]
            ]
          ]
        },
        properties: {}
      };
    }
  }
  // Public methods that delegate to interaction manager
  /**
   * Update marker draggable state
   */
  updateMarkerDraggableState() {
    this.interactionManager.updateMarkerDraggableState();
  }
  /**
   * Update all markers for edge deletion visual feedback
   */
  updateAllMarkersForEdgeDeletion(showFeedback) {
    this.interactionManager.updateAllMarkersForEdgeDeletion(showFeedback);
  }
  /**
   * Set modifier key held state
   */
  setModifierKeyHeld(isHeld) {
    this.interactionManager.setModifierKeyHeld(isHeld);
  }
  // Legacy methods for backward compatibility (delegate to appropriate managers)
  /**
   * Check if two polygons intersect (delegates to geometry manager)
   */
  checkPolygonIntersection(polygon1, polygon2) {
    return this.geometryManager.checkPolygonIntersection(polygon1, polygon2);
  }
  /**
   * Get polygon center (delegates to geometry manager)
   */
  getPolygonCenter(polygon2) {
    try {
      if (!polygon2 || !polygon2.geometry || !polygon2.geometry.coordinates) {
        return null;
      }
      let coordinates;
      if (polygon2.geometry.type === "Polygon") {
        coordinates = polygon2.geometry.coordinates[0];
      } else if (polygon2.geometry.type === "MultiPolygon") {
        coordinates = polygon2.geometry.coordinates[0][0];
      } else {
        return null;
      }
      if (!Array.isArray(coordinates) || coordinates.length === 0) {
        return null;
      }
      let latSum = 0;
      let lngSum = 0;
      let count = 0;
      for (const coord of coordinates) {
        if (Array.isArray(coord) && coord.length >= 2) {
          const lng = coord[0];
          const lat = coord[1];
          if (typeof lng === "number" && typeof lat === "number" && !isNaN(lng) && !isNaN(lat)) {
            lngSum += lng;
            latSum += lat;
            count++;
          }
        }
      }
      if (count === 0) {
        return null;
      }
      return {
        lat: latSum / count,
        lng: lngSum / count
      };
    } catch (error) {
      return null;
    }
  }
  /**
   * Get bounding box from polygon (delegates to geometry manager)
   */
  getBoundingBox(polygon2) {
    try {
      if (!polygon2 || !polygon2.geometry || !polygon2.geometry.coordinates) {
        return null;
      }
      let coordinates;
      if (polygon2.geometry.type === "Polygon") {
        coordinates = polygon2.geometry.coordinates[0];
      } else if (polygon2.geometry.type === "MultiPolygon") {
        coordinates = polygon2.geometry.coordinates[0][0];
      } else {
        return null;
      }
      if (!Array.isArray(coordinates) || coordinates.length === 0) {
        return null;
      }
      let minLat = Infinity;
      let maxLat = -Infinity;
      let minLng = Infinity;
      let maxLng = -Infinity;
      for (const coord of coordinates) {
        if (Array.isArray(coord) && coord.length >= 2) {
          const lng = coord[0];
          const lat = coord[1];
          if (typeof lng === "number" && typeof lat === "number" && !isNaN(lng) && !isNaN(lat)) {
            minLng = Math.min(minLng, lng);
            maxLng = Math.max(maxLng, lng);
            minLat = Math.min(minLat, lat);
            maxLat = Math.max(maxLat, lat);
          }
        }
      }
      if (minLat === Infinity || maxLat === -Infinity || minLng === Infinity || maxLng === -Infinity) {
        return null;
      }
      return { minLat, maxLat, minLng, maxLng };
    } catch (error) {
      return null;
    }
  }
  // Legacy methods that are now handled by specialized managers but kept for compatibility
  addMarker(latlngs, featureGroup) {
    this.interactionManager.addMarkers(latlngs, featureGroup);
  }
  addHoleMarker(latlngs, featureGroup) {
    this.interactionManager.addHoleMarkers(latlngs, featureGroup);
  }
  addEdgeClickListeners(polygon2, featureGroup) {
    this.interactionManager.addEdgeClickListeners(polygon2, featureGroup);
  }
  enablePolygonDragging(polygon2, latlngs) {
    this.interactionManager.enablePolygonDragging(polygon2, latlngs);
  }
  // Helper methods for backward compatibility
  getMarkerIndex(latlngs, position) {
    return 0;
  }
  ensureMarkerSeparation(polygonLength, markers2) {
    var _a2, _b2, _c;
    return {
      menu: ((_a2 = markers2.menu) == null ? void 0 : _a2.index) ?? 0,
      delete: ((_b2 = markers2.delete) == null ? void 0 : _b2.index) ?? 1,
      info: ((_c = markers2.info) == null ? void 0 : _c.index) ?? 2
    };
  }
  findAlternativeMarkerPosition(polygonLength, originalIndex, usedIndices) {
    return (originalIndex + 1) % polygonLength;
  }
  createDivIcon(processedClasses) {
    return L.divIcon({ className: processedClasses.join(" ") });
  }
  getLatLngInfoString(latlng) {
    return "Latitude: " + latlng.lat + " Longitude: " + latlng.lng;
  }
  generateMenuMarkerPopup(latLngs, featureGroup) {
    const div = document.createElement("div");
    div.innerHTML = "Menu";
    return div;
  }
  getPolygonGeoJSONFromFeatureGroup(featureGroup) {
    return {
      type: "Feature",
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [0, 0],
            [0, 1],
            [1, 1],
            [1, 0],
            [0, 0]
          ]
        ]
      },
      properties: {}
    };
  }
  getTotalPolygonPerimeter(polygonGeoJSON) {
    return 1e3;
  }
  generateInfoMarkerPopup(area2, perimeter) {
    const div = document.createElement("div");
    div.innerHTML = `Area: ${area2}, Perimeter: ${perimeter}`;
    return div;
  }
  onMarkerHoverForEdgeDeletion(marker, isHovering) {
  }
  highlightEdgeOnHover(edgePolyline, isHovering) {
  }
  // Additional methods for backward compatibility with tests
  onEdgeClick(e, edgePolyline) {
  }
  removeFeatureGroup(featureGroup) {
    this.removeFeatureGroupInternal(featureGroup);
  }
  onPolygonMouseMove(e) {
  }
  onPolygonMouseUp(e) {
  }
  updatePolygonAfterDrag(polygon2) {
  }
  setSubtractVisualMode(polygon2, enabled) {
  }
  performModifierSubtract(draggedGeoJSON, originalFeatureGroup) {
    try {
      const draggedPolygon = this.turfHelper.getTurfPolygon(draggedGeoJSON);
      const intersectingFeatureGroups = [];
      this.getFeatureGroups().forEach((featureGroup) => {
        if (featureGroup === originalFeatureGroup) {
          return;
        }
        try {
          const featureCollection2 = featureGroup.toGeoJSON();
          if (!featureCollection2 || !featureCollection2.features || !featureCollection2.features[0]) {
            return;
          }
          const firstFeature = featureCollection2.features[0];
          if (!firstFeature.geometry || !firstFeature.geometry.coordinates) {
            return;
          }
          const existingPolygon = this.turfHelper.getTurfPolygon(firstFeature);
          const hasIntersection = this.geometryManager.checkPolygonIntersection(
            existingPolygon,
            draggedPolygon
          );
          if (hasIntersection) {
            intersectingFeatureGroups.push(featureGroup);
          }
        } catch (error) {
        }
      });
      this.removeFeatureGroupInternal(originalFeatureGroup);
      intersectingFeatureGroups.forEach((featureGroup) => {
        try {
          const featureCollection2 = featureGroup.toGeoJSON();
          const existingPolygon = this.turfHelper.getTurfPolygon(featureCollection2.features[0]);
          this.removeFeatureGroupInternal(featureGroup);
          const result = this.geometryManager.subtractPolygon(existingPolygon, draggedPolygon);
          if (result.success && result.results) {
            for (const resultPolygon of result.results) {
              this.addPolygonLayer(resultPolygon, { simplify: true });
            }
          }
        } catch (error) {
        }
      });
    } catch (error) {
    }
  }
}
function injectDynamicStyles(config) {
  const style = document.createElement("style");
  style.innerHTML = `
    .leaflet-control a { background-color: ${config.colors.styles.controlButton.backgroundColor}; color: ${config.colors.styles.controlButton.color}; display: flex; align-items: center; justify-content: center; }
    .leaflet-control a:hover { background-color: ${config.colors.styles.controlButtonHover.backgroundColor}; }
    .leaflet-control a.active { background-color: ${config.colors.styles.controlButtonActive.backgroundColor}; color: ${config.colors.styles.controlButtonActive.color}; }
    .polydraw-indicator-active { background-color: ${config.colors.styles.indicatorActive.backgroundColor} !important; }
    .crosshair-cursor-enabled { cursor: crosshair !important; }
    .crosshair-cursor-enabled * { cursor: crosshair !important; }
    .leaflet-polydraw-p2p-marker { background-color: ${config.colors.styles.p2pMarker.backgroundColor}; border: 2px solid ${config.colors.styles.p2pMarker.borderColor}; border-radius: 50%; box-sizing: border-box; }
    .leaflet-polydraw-p2p-first-marker { position: relative; }
    .leaflet-polydraw-p2p-first-marker:hover { transform: scale(1.5); transition: all 0.2s ease; }
  `;
  document.head.appendChild(style);
}
class Polydraw extends L.Control {
  constructor(options) {
    super(options);
    __publicField(this, "map");
    __publicField(this, "tracer", {});
    __publicField(this, "turfHelper");
    __publicField(this, "subContainer");
    __publicField(this, "config");
    __publicField(this, "mapStateService");
    __publicField(this, "eventManager");
    __publicField(this, "polygonInformation");
    __publicField(this, "modeManager");
    __publicField(this, "polygonDrawManager");
    __publicField(this, "polygonMutationManager");
    __publicField(this, "arrayOfFeatureGroups", []);
    __publicField(this, "drawMode", DrawMode.Off);
    __publicField(this, "drawModeListeners", []);
    __publicField(this, "_boundKeyDownHandler");
    __publicField(this, "_boundKeyUpHandler");
    __publicField(this, "isModifierKeyHeld", false);
    __publicField(this, "_boundTouchMove");
    __publicField(this, "_boundTouchEnd");
    __publicField(this, "_boundTouchStart");
    /**
     * Updates map interactions based on the current drawing mode.
     */
    __publicField(this, "_handleActivateToggle", () => {
      const container = this.getContainer();
      if (!container) return;
      const activate = container.querySelector(".icon-activate");
      if (L.DomUtil.hasClass(activate, "active")) {
        L.DomUtil.removeClass(activate, "active");
        if (this.subContainer) {
          this.subContainer.style.maxHeight = "0px";
        }
      } else {
        L.DomUtil.addClass(activate, "active");
        if (this.subContainer) {
          this.subContainer.style.maxHeight = "250px";
        }
      }
      this.updateActivateButtonIndicator();
    });
    __publicField(this, "_handleDrawClick", (e) => {
      if (e) {
        e.preventDefault();
        e.stopPropagation();
      }
      if (this.modeManager.getCurrentMode() === DrawMode.Add) {
        this.setDrawMode(DrawMode.Off);
        return;
      }
      this.setDrawMode(DrawMode.Add);
      this.polygonInformation.saveCurrentState();
    });
    __publicField(this, "_handleSubtractClick", (e) => {
      if (e) {
        e.preventDefault();
        e.stopPropagation();
      }
      if (this.modeManager.getCurrentMode() === DrawMode.Subtract) {
        this.setDrawMode(DrawMode.Off);
        return;
      }
      this.setDrawMode(DrawMode.Subtract);
      this.polygonInformation.saveCurrentState();
    });
    __publicField(this, "_handleEraseClick", (e) => {
      this.map.closePopup();
      if (e) {
        e.preventDefault();
        e.stopPropagation();
      }
      if (this.arrayOfFeatureGroups.length === 0) {
        return;
      }
      this.removeAllFeatureGroups();
    });
    __publicField(this, "_handlePointToPointClick", (e) => {
      if (e) {
        e.preventDefault();
        e.stopPropagation();
      }
      if (this.modeManager.getCurrentMode() === DrawMode.PointToPoint) {
        this.setDrawMode(DrawMode.Off);
        return;
      }
      this.setDrawMode(DrawMode.PointToPoint);
      this.polygonInformation.saveCurrentState();
    });
    /**
     * Handle marker hover when modifier key is held - event handler version
     */
    __publicField(this, "onMarkerHoverForEdgeDeletionEvent", (e) => {
      if (!this.isModifierKeyHeld) return;
      const element = e.target;
      if (element) {
        element.style.backgroundColor = this.config.colors.edgeDeletion.hover;
        element.style.borderColor = this.config.colors.edgeDeletion.hover;
        element.classList.add("edge-deletion-hover");
      }
    });
    /**
     * Handle marker leave when modifier key is held - event handler version
     */
    __publicField(this, "onMarkerLeaveForEdgeDeletionEvent", (e) => {
      const element = e.target;
      if (element) {
        element.style.backgroundColor = "";
        element.style.borderColor = "";
        element.classList.remove("edge-deletion-hover");
      }
    });
    this.config = defaultConfig;
    if (options == null ? void 0 : options.configPath) {
      this.loadExternalConfig(options.configPath, options == null ? void 0 : options.config);
    } else {
      this.config = { ...defaultConfig, ...(options == null ? void 0 : options.config) || {} };
      this.initializeComponents();
    }
  }
  /**
   * Method called when the control is added to the map.
   * It initializes the control, creates the UI, and sets up event listeners.
   * @param _map - The map instance.
   * @returns The control's container element.
   */
  onAdd(_map) {
    const extendedMap = _map;
    const browser = L.Browser;
    extendedMap._onResize = () => {
    };
    if (browser.touch && browser.mobile) {
      extendedMap.tap = false;
    }
    this.map = _map;
    this.setupKeyboardHandlers();
    const container = L.DomUtil.create("div", "leaflet-control leaflet-bar");
    this.initializeUI(container);
    this.createTracer();
    this.initializeManagers();
    this.setupEventListeners();
    return container;
  }
  /**
   * Method called when the control is removed from the map.
   * It handles the cleanup of layers, events, and handlers.
   * @param _map - The map instance, unused but required by the L.Control interface.
   */
  onRemove(_map) {
    this.removeKeyboardHandlers();
    if (this.tracer) {
      this.map.removeLayer(this.tracer);
    }
    this.removeAllFeatureGroups();
  }
  /**
   * Adds the control to the given map.
   * @param map - The map instance.
   * @returns The current instance of the control.
   */
  addTo(map) {
    super.addTo(map);
    return this;
  }
  /**
   * Returns the array of feature groups currently managed by the control.
   * @returns An array of L.FeatureGroup objects.
   */
  getFeatureGroups() {
    return this.arrayOfFeatureGroups;
  }
  /**
   * Adds a predefined polygon to the map.
   * @param geographicBorders - An array of LatLng arrays representing the polygon's coordinates.
   * @param options - Optional parameters, including visual optimization level.
   */
  async addPredefinedPolygon(geographicBorders, options) {
    if (!geographicBorders || geographicBorders.length === 0) {
      throw new Error("Cannot add empty polygon array");
    }
    if (!this.map) {
      throw new Error("Map not initialized");
    }
    if (!this.polygonMutationManager) {
      throw new Error("PolygonMutationManager not initialized");
    }
    const visualOptimizationLevel = (options == null ? void 0 : options.visualOptimizationLevel) ?? 0;
    for (const [groupIndex, group] of geographicBorders.entries()) {
      if (!group || !group[0] || group[0].length < 4) {
        throw new Error(
          `Invalid polygon data at index ${groupIndex}: A polygon must have at least 3 unique vertices.`
        );
      }
      try {
        const coords = group.map((ring) => ring.map((latlng) => [latlng.lng, latlng.lat]));
        const polygon2 = this.turfHelper.getMultiPolygon([coords]);
        const result = await this.polygonMutationManager.addPolygon(polygon2, {
          simplify: false,
          noMerge: false,
          visualOptimizationLevel
        });
        if (!result.success) {
          console.error("Error adding polygon via manager:", result.error);
          throw new Error(result.error || "Failed to add polygon");
        }
        this.polygonInformation.createPolygonInformationStorage(this.arrayOfFeatureGroups);
      } catch (error) {
        console.error("Error adding auto polygon:", error);
        throw error;
      }
    }
  }
  /**
   * Sets the current drawing mode.
   * @param mode - The drawing mode to set.
   */
  setDrawMode(mode) {
    const previousMode = this.drawMode;
    this._updateDrawModeState(mode);
    if (previousMode === DrawMode.PointToPoint && mode !== DrawMode.PointToPoint) {
      this.polygonDrawManager.clearP2pMarkers();
      this.stopDraw();
    } else if (mode === DrawMode.Off) {
      this.stopDraw();
    } else if (mode !== DrawMode.PointToPoint) {
      this.stopDraw();
    }
    if (this.map) {
      this._updateUIAfterDrawModeChange(mode);
      this._updateMapInteractions();
    }
  }
  /**
   * Returns the current drawing mode.
   * @returns The current DrawMode.
   */
  getDrawMode() {
    return this.modeManager.getCurrentMode();
  }
  /**
   * Registers an event listener for a given event type.
   * @param event - The event type to listen for.
   * @param callback - The callback function to execute when the event is triggered.
   */
  on(event, callback) {
    this.eventManager.on(event, callback);
  }
  /**
   * Unregisters an event listener for a given event type.
   * @param event - The event type to stop listening for.
   * @param callback - The callback function to remove.
   */
  off(event, callback) {
    this.eventManager.off(event, callback);
  }
  /**
   * Removes all feature groups from the map and clears the internal storage.
   */
  removeAllFeatureGroups() {
    this.arrayOfFeatureGroups.forEach((featureGroups) => {
      try {
        this.map.removeLayer(featureGroups);
      } catch (error) {
      }
    });
    this.arrayOfFeatureGroups.length = 0;
    this.polygonInformation.deletePolygonInformationStorage();
    this.polygonInformation.updatePolygons();
    this.updateActivateButtonIndicator();
  }
  /**
   * Initializes the user interface, creates DOM elements, sets up buttons, and injects styles.
   * @param container - The main control container element.
   */
  initializeUI(container) {
    injectDynamicStyles(this.config);
    L.DomEvent.disableClickPropagation(container);
    L.DomEvent.on(container, "mousedown", L.DomEvent.stopPropagation);
    L.DomEvent.on(container, "touchstart", L.DomEvent.stopPropagation);
    L.DomEvent.on(container, "click", L.DomEvent.stopPropagation);
    container.style.display = "flex";
    container.style.flexDirection = "column-reverse";
    this.subContainer = L.DomUtil.create("div", "sub-buttons", container);
    this.subContainer.style.maxHeight = "0px";
    this.subContainer.style.overflow = "hidden";
    this.subContainer.style.transition = "max-height 0.3s ease";
    createButtons(
      container,
      this.subContainer,
      this.config,
      this._handleActivateToggle,
      this._handleDrawClick,
      this._handleSubtractClick,
      this._handleEraseClick,
      this._handlePointToPointClick
    );
    const uiUpdateListener = (mode) => {
      const drawButton = container.querySelector(".icon-draw");
      const subtractButton = container.querySelector(".icon-subtract");
      if (drawButton) drawButton.classList.toggle("active", mode === DrawMode.Add);
      if (subtractButton) subtractButton.classList.toggle("active", mode === DrawMode.Subtract);
    };
    this.drawModeListeners.push(uiUpdateListener);
  }
  /**
   * Attaches listeners to polygonMutationManager and eventManager.
   */
  setupEventListeners() {
    this.polygonMutationManager.on("polygonOperationComplete", (data) => {
      this.updateActivateButtonIndicator();
      this.modeManager.updateStateForMode(DrawMode.Off);
      this.drawMode = DrawMode.Off;
      this.emitDrawModeChanged();
      this.updateMarkerDraggableState();
      const shouldShowCrosshair = this.modeManager.shouldShowCrosshairCursor();
      const mapDragEnabled = this.modeManager.canPerformAction("mapDrag");
      const mapZoomEnabled = this.modeManager.canPerformAction("mapZoom");
      const mapDoubleClickEnabled = this.modeManager.canPerformAction("mapDoubleClickZoom");
      if (shouldShowCrosshair) {
        L.DomUtil.addClass(this.map.getContainer(), "crosshair-cursor-enabled");
      } else {
        L.DomUtil.removeClass(this.map.getContainer(), "crosshair-cursor-enabled");
      }
      this.events(false);
      this.setLeafletMapEvents(mapDragEnabled, mapDoubleClickEnabled, mapZoomEnabled);
      try {
        this.tracer.setStyle({ color: "" });
      } catch (error) {
      }
    });
    this.polygonMutationManager.on("polygonDeleted", () => {
      this.updateActivateButtonIndicator();
    });
    this.eventManager.on("polydraw:polygon:created", async (data) => {
      this.stopDraw();
      if (data.isPointToPoint) {
        await this.polygonMutationManager.addPolygon(data.polygon, {
          simplify: false,
          noMerge: false
        });
      } else {
        await this.handleFreehandDrawCompletion(data.polygon);
      }
      this.polygonInformation.createPolygonInformationStorage(this.arrayOfFeatureGroups);
    });
    this.eventManager.on("polydraw:draw:cancel", () => {
      this.stopDraw();
      this.setDrawMode(DrawMode.Off);
    });
  }
  /**
   * Initializes and adds the tracer polyline to the map.
   */
  createTracer() {
    this.tracer = L.polyline([], {
      ...this.config.polyLineOptions,
      color: this.config.colors.polyline
    });
    try {
      this.tracer.addTo(this.map);
    } catch (error) {
    }
  }
  /**
   * Sets up PolygonDrawManager and PolygonMutationManager with the map.
   */
  initializeManagers() {
    this.polygonDrawManager = new PolygonDrawManager({
      turfHelper: this.turfHelper,
      map: this.map,
      config: this.config,
      modeManager: this.modeManager,
      eventManager: this.eventManager,
      tracer: this.tracer
    });
    this.polygonMutationManager = new PolygonMutationManager({
      turfHelper: this.turfHelper,
      polygonInformation: this.polygonInformation,
      map: this.map,
      config: this.config,
      modeManager: this.modeManager,
      eventManager: this.eventManager,
      getFeatureGroups: () => this.arrayOfFeatureGroups
    });
  }
  /**
   * Loads an external configuration file and merges it with the default and inline configs.
   * @param configPath - The path to the external configuration file.
   * @param inlineConfig - An optional inline configuration object.
   */
  async loadExternalConfig(configPath, inlineConfig) {
    try {
      const response = await fetch(configPath);
      if (!response.ok) {
        throw new Error(
          `Failed to load config from ${configPath}: ${response.status} ${response.statusText}`
        );
      }
      const externalConfig = await response.json();
      this.config = {
        ...defaultConfig,
        ...externalConfig,
        ...inlineConfig || {}
      };
      this.initializeComponents();
    } catch (error) {
      console.warn(
        "Failed to load external config, falling back to default + inline config:",
        error
      );
      this.config = { ...defaultConfig, ...inlineConfig || {} };
      this.initializeComponents();
    }
  }
  /**
   * Initializes the core components of the Polydraw control.
   */
  /**
   * Updates the state of the drawing mode.
   * @param mode - The new drawing mode.
   */
  _updateDrawModeState(mode) {
    this.drawMode = mode;
    this.modeManager.updateStateForMode(mode);
    this.emitDrawModeChanged();
    this.updateMarkerDraggableState();
  }
  /**
   * Updates the UI after a change in the drawing mode.
   * @param mode - The new drawing mode.
   */
  _updateUIAfterDrawModeChange(mode) {
    const shouldShowCrosshair = this.modeManager.shouldShowCrosshairCursor();
    if (shouldShowCrosshair) {
      L.DomUtil.addClass(this.map.getContainer(), "crosshair-cursor-enabled");
    } else {
      L.DomUtil.removeClass(this.map.getContainer(), "crosshair-cursor-enabled");
    }
    try {
      switch (mode) {
        case DrawMode.Off:
          this.tracer.setStyle({ color: "" });
          break;
        case DrawMode.Add:
          this.tracer.setStyle({
            color: this.config.colors.polyline,
            dashArray: null
            // Reset to solid line
          });
          break;
        case DrawMode.Subtract:
          this.tracer.setStyle({
            color: this.config.colors.subtractLine,
            dashArray: null
            // Reset to solid line
          });
          break;
        case DrawMode.PointToPoint:
          this.tracer.setStyle({
            color: this.config.colors.polyline,
            dashArray: "5, 5"
          });
          break;
      }
    } catch (error) {
    }
  }
  _updateMapInteractions() {
    const mapDragEnabled = this.modeManager.canPerformAction("mapDrag");
    const mapZoomEnabled = this.modeManager.canPerformAction("mapZoom");
    const mapDoubleClickEnabled = this.modeManager.canPerformAction("mapDoubleClickZoom");
    this.events(this.drawMode !== DrawMode.Off);
    this.setLeafletMapEvents(mapDragEnabled, mapDoubleClickEnabled, mapZoomEnabled);
  }
  initializeComponents() {
    this.turfHelper = new TurfHelper(this.config);
    this.mapStateService = new MapStateService();
    this.eventManager = new EventManager();
    this.polygonInformation = new PolygonInformationService(this.mapStateService);
    this.modeManager = new ModeManager(this.config, this.eventManager);
    this.polygonInformation.onPolygonInfoUpdated((_k) => {
      this.updateActivateButtonIndicator();
    });
    this._boundKeyDownHandler = this.handleKeyDown.bind(this);
    this.polygonMutationManager = null;
    this.polygonDrawManager = null;
  }
  /**
   * Emits an event to notify listeners that the drawing mode has changed.
   */
  emitDrawModeChanged() {
    this.eventManager.emit("polydraw:mode:change", {
      mode: this.modeManager.getCurrentMode()
    });
    for (const cb of this.drawModeListeners) {
      cb(this.modeManager.getCurrentMode());
    }
  }
  /**
   * Update the draggable state of all existing markers when draw mode changes
   */
  updateMarkerDraggableState() {
    const shouldBeDraggable = this.modeManager.canPerformAction("markerDrag");
    this.arrayOfFeatureGroups.forEach((featureGroup) => {
      featureGroup.eachLayer((layer) => {
        if (layer instanceof L.Marker) {
          const marker = layer;
          try {
            marker.options.draggable = shouldBeDraggable;
            if (marker.dragging) {
              if (shouldBeDraggable) {
                marker.dragging.enable();
              } else {
                marker.dragging.disable();
              }
            }
          } catch (error) {
          }
        }
      });
    });
  }
  /**
   * Stops the current drawing operation and resets the tracer.
   */
  stopDraw() {
    this.resetTracker();
    this.drawStartedEvents(false);
  }
  /**
   * Enables or disables Leaflet's default map interactions.
   * @param enableDragging - Whether to enable map dragging.
   * @param enableDoubleClickZoom - Whether to enable double-click zoom.
   * @param enableScrollWheelZoom - Whether to enable scroll wheel zoom.
   */
  setLeafletMapEvents(enableDragging, enableDoubleClickZoom, enableScrollWheelZoom) {
    enableDragging ? this.map.dragging.enable() : this.map.dragging.disable();
    enableDoubleClickZoom ? this.map.doubleClickZoom.enable() : this.map.doubleClickZoom.disable();
    enableScrollWheelZoom ? this.map.scrollWheelZoom.enable() : this.map.scrollWheelZoom.disable();
  }
  /**
   * Resets the tracer polyline by clearing its LatLngs.
   */
  resetTracker() {
    this.tracer.setLatLngs([]);
  }
  /**
   * Attaches or detaches the mouse move and mouse up event listeners for drawing.
   * @param onoff - A boolean indicating whether to attach or detach the events.
   */
  drawStartedEvents(onoff) {
    const onoroff = onoff ? "on" : "off";
    this.map[onoroff]("mousemove", this.mouseMove, this);
    this.map[onoroff]("mouseup", this.mouseUpLeave, this);
    if (onoff) {
      this._boundTouchMove = (e) => this.mouseMove(e);
      this._boundTouchEnd = (e) => this.mouseUpLeave(e);
      this.map.getContainer().addEventListener("touchmove", this._boundTouchMove, { passive: false });
      this.map.getContainer().addEventListener("touchend", this._boundTouchEnd, { passive: false });
    } else {
      if (this._boundTouchMove) {
        this.map.getContainer().removeEventListener("touchmove", this._boundTouchMove);
      }
      if (this._boundTouchEnd) {
        this.map.getContainer().removeEventListener("touchend", this._boundTouchEnd);
      }
    }
  }
  /**
   * Attaches or detaches the main drawing event listeners.
   * @param onoff - A boolean indicating whether to attach or detach the events.
   */
  events(onoff) {
    const onoroff = onoff ? "on" : "off";
    this.map[onoroff]("mousedown", this.mouseDown, this);
    this.map[onoroff]("dblclick", this.handleDoubleClick, this);
    if (onoff) {
      this._boundTouchStart = (e) => this.mouseDown(e);
      this.map.getContainer().addEventListener("touchstart", this._boundTouchStart, { passive: false });
    } else {
      if (this._boundTouchStart) {
        this.map.getContainer().removeEventListener("touchstart", this._boundTouchStart);
      }
    }
  }
  /**
   * Handles the mouse down event to start a drawing operation.
   * @param event - The mouse or touch event.
   */
  mouseDown(event) {
    if ("cancelable" in event && event.cancelable) {
      event.preventDefault();
    }
    if (this.modeManager.isInOffMode()) {
      return;
    }
    let clickLatLng;
    if ("latlng" in event && event.latlng) {
      clickLatLng = event.latlng;
    } else if ("touches" in event && event.touches && event.touches.length > 0) {
      clickLatLng = this.map.containerPointToLatLng([
        event.touches[0].clientX,
        event.touches[0].clientY
      ]);
    }
    if (!clickLatLng) {
      return;
    }
    if (this.modeManager.getCurrentMode() === DrawMode.PointToPoint) {
      this.polygonDrawManager.handlePointToPointClick(clickLatLng);
      return;
    }
    this.tracer.setLatLngs([clickLatLng]);
    this.startDraw();
  }
  /**
   * Handles the mouse move event to draw the tracer polyline.
   * @param event - The mouse or touch event.
   */
  mouseMove(event) {
    if ("cancelable" in event && event.cancelable) {
      event.preventDefault();
    }
    if ("latlng" in event && event.latlng) {
      this.tracer.addLatLng(event.latlng);
    } else if ("touches" in event && event.touches && event.touches.length > 0) {
      const latlng = this.map.containerPointToLatLng([
        event.touches[0].clientX,
        event.touches[0].clientY
      ]);
      this.tracer.addLatLng(latlng);
    }
  }
  /**
   * Handles the mouse up event to complete a drawing operation.
   * @param event - The mouse or touch event.
   */
  async mouseUpLeave(event) {
    if ("cancelable" in event && event.cancelable) {
      event.preventDefault();
    }
    this.polygonInformation.deletePolygonInformationStorage();
    const tracerGeoJSON = this.tracer.toGeoJSON();
    if (!tracerGeoJSON || !tracerGeoJSON.geometry || !tracerGeoJSON.geometry.coordinates || tracerGeoJSON.geometry.coordinates.length < 3) {
      this.stopDraw();
      return;
    }
    let geoPos;
    try {
      geoPos = this.turfHelper.createPolygonFromTrace(tracerGeoJSON);
    } catch (error) {
      this.stopDraw();
      return;
    }
    if (!geoPos || !geoPos.geometry || !geoPos.geometry.coordinates || geoPos.geometry.coordinates.length === 0) {
      this.stopDraw();
      return;
    }
    this.stopDraw();
    try {
      switch (this.modeManager.getCurrentMode()) {
        case DrawMode.Add: {
          const result = await this.polygonMutationManager.addPolygon(geoPos, {
            simplify: true,
            noMerge: false
          });
          if (!result.success) {
            console.error("Error adding polygon via manager:", result.error);
          }
          break;
        }
        case DrawMode.Subtract: {
          const subtractResult = await this.polygonMutationManager.subtractPolygon(geoPos);
          if (!subtractResult.success) {
            console.error("Error subtracting polygon via manager:", subtractResult.error);
          }
          break;
        }
        default:
          break;
      }
    } catch (error) {
      console.error("Error in mouseUpLeave polygon operation:", error);
    }
    this.polygonInformation.createPolygonInformationStorage(this.arrayOfFeatureGroups);
  }
  /**
   * Handles the completion of a freehand drawing operation.
   * @param geoPos - The GeoJSON feature representing the drawn polygon.
   */
  async handleFreehandDrawCompletion(geoPos) {
    try {
      switch (this.modeManager.getCurrentMode()) {
        case DrawMode.Add: {
          const result = await this.polygonMutationManager.addPolygon(geoPos, {
            simplify: true,
            noMerge: false
          });
          if (!result.success) {
            console.error("Error adding polygon via manager:", result.error);
          }
          break;
        }
        case DrawMode.Subtract: {
          const subtractResult = await this.polygonMutationManager.subtractPolygon(geoPos);
          if (!subtractResult.success) {
            console.error("Error subtracting polygon via manager:", subtractResult.error);
          }
          break;
        }
        default:
          break;
      }
    } catch (error) {
      console.error("Error in mouseUpLeave polygon operation:", error);
    }
  }
  /**
   * Starts a drawing operation by attaching the necessary event listeners.
   */
  startDraw() {
    this.drawStartedEvents(true);
  }
  /**
   * Sets up the keyboard event handlers for the document.
   */
  setupKeyboardHandlers() {
    this._boundKeyUpHandler = this.handleKeyUp.bind(this);
    document.addEventListener("keydown", this._boundKeyDownHandler);
    document.addEventListener("keyup", this._boundKeyUpHandler);
  }
  /**
   * Removes the keyboard event handlers from the document.
   */
  removeKeyboardHandlers() {
    document.removeEventListener("keydown", this._boundKeyDownHandler);
    document.removeEventListener("keyup", this._boundKeyUpHandler);
  }
  /**
   * Handles the key down event for keyboard shortcuts.
   * @param e - The keyboard event.
   */
  handleKeyDown(e) {
    if (e.key === "Escape") {
      if (this.modeManager.getCurrentMode() === DrawMode.PointToPoint) {
        this.polygonDrawManager.cancelPointToPointDrawing();
      }
    }
    const isModifierPressed = this.isModifierKeyPressed(e);
    if (isModifierPressed && !this.isModifierKeyHeld) {
      this.isModifierKeyHeld = true;
      this.polygonDrawManager.setModifierKey(true);
      this.updateAllMarkersForEdgeDeletion(true);
    }
  }
  /**
   * Handles the key up event for keyboard shortcuts.
   * @param e - The keyboard event.
   */
  handleKeyUp(e) {
    const isModifierPressed = this.isModifierKeyPressed(e);
    if (!isModifierPressed && this.isModifierKeyHeld) {
      this.isModifierKeyHeld = false;
      this.polygonDrawManager.setModifierKey(false);
      this.updateAllMarkersForEdgeDeletion(false);
    }
  }
  /**
   * Update all markers to show/hide edge deletion visual feedback
   */
  updateAllMarkersForEdgeDeletion(showFeedback) {
    this.arrayOfFeatureGroups.forEach((featureGroup) => {
      featureGroup.eachLayer((layer) => {
        if (layer instanceof L.Marker) {
          this.updateMarkerForEdgeDeletion(layer, showFeedback);
        }
      });
    });
  }
  /**
   * Update individual marker for edge deletion visual feedback
   */
  updateMarkerForEdgeDeletion(marker, showFeedback) {
    const element = marker.getElement();
    if (!element) return;
    if (showFeedback) {
      element.addEventListener("mouseenter", this.onMarkerHoverForEdgeDeletionEvent);
      element.addEventListener("mouseleave", this.onMarkerLeaveForEdgeDeletionEvent);
    } else {
      element.removeEventListener("mouseenter", this.onMarkerHoverForEdgeDeletionEvent);
      element.removeEventListener("mouseleave", this.onMarkerLeaveForEdgeDeletionEvent);
      element.style.backgroundColor = "";
      element.style.borderColor = "";
    }
  }
  /**
   * Handles the double-click event for point-to-point drawing.
   * @param e - The mouse event.
   */
  handleDoubleClick(e) {
    if (this.modeManager.getCurrentMode() !== DrawMode.PointToPoint) {
      return;
    }
    this.polygonDrawManager.handleDoubleClick(e);
  }
  /**
   * Detect if modifier key is pressed (Ctrl on Windows/Linux, Cmd on Mac)
   */
  isModifierKeyPressed(event) {
    const userAgent = navigator.userAgent.toLowerCase();
    const isMac = userAgent.includes("mac");
    if (isMac) {
      return event.metaKey;
    } else {
      return event.ctrlKey;
    }
  }
  /**
   * Updates the visual indicator on the activate button to show if there are active polygons.
   */
  updateActivateButtonIndicator() {
    if (typeof this.getContainer !== "function") {
      return;
    }
    const container = this.getContainer();
    if (!container) return;
    const activateButton = container.querySelector(".icon-activate");
    if (!activateButton) return;
    const hasPolygons = this.arrayOfFeatureGroups.length > 0;
    const isPanelClosed = !L.DomUtil.hasClass(activateButton, "active");
    if (hasPolygons && isPanelClosed) {
      L.DomUtil.addClass(activateButton, "polydraw-indicator-active");
    } else {
      L.DomUtil.removeClass(activateButton, "polydraw-indicator-active");
    }
  }
}
L.control.polydraw = function(options) {
  return new Polydraw(options);
};
export {
  Polydraw as default
};
//# sourceMappingURL=polydraw.es.js.map
